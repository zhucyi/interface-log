/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 9:0-14 */
/***/ ((module) => {

"use strict";

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names

module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js":
/*!************************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/cssWithMappingToString.js ***!
  \************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 61:0-14 */
/***/ ((module) => {

"use strict";


function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = function cssWithMappingToString(item) {
  var _item = _slicedToArray(item, 4),
      content = _item[1],
      cssMapping = _item[3];

  if (typeof btoa === 'function') {
    // eslint-disable-next-line no-undef
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
};

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: __webpack_exports__, module.loaded, module.id, module, __webpack_require__.nmd, top-level-this-exports, __webpack_require__.g, __webpack_require__, __webpack_require__.* */
/*! CommonJS bailout: this is used directly at 9453:18-22 */
/*! CommonJS bailout: exports is used directly at 19:2620-2627 */
/*! CommonJS bailout: exports is used directly at 19:2648-2655 */
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.20';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof __webpack_require__.g=='object'&&__webpack_require__.g&&__webpack_require__.g.Object===Object&&__webpack_require__.g;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports= true&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&"object"=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined,symIterator=Symbol?Symbol.iterator:undefined,symToStringTag=Symbol?Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){// No operation performed.
}/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else{iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&typeof value=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
// The sourceURL gets injected into the source that's eval-ed, so be careful
// to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
// and escape the comment, thus injecting code that gets evaled.
var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){// No operation performed.
}/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if(true){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return _;}).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
else {}}).call(this);

/***/ }),

/***/ "./node_modules/nunjucks/browser/nunjucks.js":
/*!***************************************************!*\
  !*** ./node_modules/nunjucks/browser/nunjucks.js ***!
  \***************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, top-level-this-exports */
/*! CommonJS bailout: this is used directly at 4:40-44 */
/*! CommonJS bailout: module.exports is used directly at 3:65-79 */
/***/ (function(module) {

/*! Browser bundle of nunjucks 3.2.2  */
(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory();else {}
})(typeof self !== 'undefined' ? self : this, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __nested_webpack_require_681__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_681__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __nested_webpack_require_681__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __nested_webpack_require_681__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __nested_webpack_require_681__.d = function (exports, name, getter) {
        /******/
        if (!__nested_webpack_require_681__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            /******/
            configurable: false,

            /******/
            enumerable: true,

            /******/
            get: getter
            /******/

          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __nested_webpack_require_681__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __nested_webpack_require_681__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __nested_webpack_require_681__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __nested_webpack_require_681__.p = "";
      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __nested_webpack_require_681__(__nested_webpack_require_681__.s = 11);
      /******/
    }(
    /************************************************************************/

    /******/
    [
    /* 0 */

    /***/
    function (module, exports, __nested_webpack_require_3806__) {
      "use strict";

      var ArrayProto = Array.prototype;
      var ObjProto = Object.prototype;
      var escapeMap = {
        '&': '&amp;',
        '"': '&quot;',
        '\'': '&#39;',
        '<': '&lt;',
        '>': '&gt;'
      };
      var escapeRegex = /[&"'<>]/g;
      var exports = module.exports = {};

      function hasOwnProp(obj, k) {
        return ObjProto.hasOwnProperty.call(obj, k);
      }

      exports.hasOwnProp = hasOwnProp;

      function lookupEscape(ch) {
        return escapeMap[ch];
      }

      function _prettifyError(path, withInternals, err) {
        if (!err.Update) {
          // not one of ours, cast it
          err = new exports.TemplateError(err);
        }

        err.Update(path); // Unless they marked the dev flag, show them a trace from here

        if (!withInternals) {
          var old = err;
          err = new Error(old.message);
          err.name = old.name;
        }

        return err;
      }

      exports._prettifyError = _prettifyError;

      function TemplateError(message, lineno, colno) {
        var err;
        var cause;

        if (message instanceof Error) {
          cause = message;
          message = cause.name + ": " + cause.message;
        }

        if (Object.setPrototypeOf) {
          err = new Error(message);
          Object.setPrototypeOf(err, TemplateError.prototype);
        } else {
          err = this;
          Object.defineProperty(err, 'message', {
            enumerable: false,
            writable: true,
            value: message
          });
        }

        Object.defineProperty(err, 'name', {
          value: 'Template render error'
        });

        if (Error.captureStackTrace) {
          Error.captureStackTrace(err, this.constructor);
        }

        var getStack;

        if (cause) {
          var stackDescriptor = Object.getOwnPropertyDescriptor(cause, 'stack');

          getStack = stackDescriptor && (stackDescriptor.get || function () {
            return stackDescriptor.value;
          });

          if (!getStack) {
            getStack = function getStack() {
              return cause.stack;
            };
          }
        } else {
          var stack = new Error(message).stack;

          getStack = function getStack() {
            return stack;
          };
        }

        Object.defineProperty(err, 'stack', {
          get: function get() {
            return getStack.call(err);
          }
        });
        Object.defineProperty(err, 'cause', {
          value: cause
        });
        err.lineno = lineno;
        err.colno = colno;
        err.firstUpdate = true;

        err.Update = function Update(path) {
          var msg = '(' + (path || 'unknown path') + ')'; // only show lineno + colno next to path of template
          // where error occurred

          if (this.firstUpdate) {
            if (this.lineno && this.colno) {
              msg += " [Line " + this.lineno + ", Column " + this.colno + "]";
            } else if (this.lineno) {
              msg += " [Line " + this.lineno + "]";
            }
          }

          msg += '\n ';

          if (this.firstUpdate) {
            msg += ' ';
          }

          this.message = msg + (this.message || '');
          this.firstUpdate = false;
          return this;
        };

        return err;
      }

      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
      } else {
        TemplateError.prototype = Object.create(Error.prototype, {
          constructor: {
            value: TemplateError
          }
        });
      }

      exports.TemplateError = TemplateError;

      function escape(val) {
        return val.replace(escapeRegex, lookupEscape);
      }

      exports.escape = escape;

      function isFunction(obj) {
        return ObjProto.toString.call(obj) === '[object Function]';
      }

      exports.isFunction = isFunction;

      function isArray(obj) {
        return ObjProto.toString.call(obj) === '[object Array]';
      }

      exports.isArray = isArray;

      function isString(obj) {
        return ObjProto.toString.call(obj) === '[object String]';
      }

      exports.isString = isString;

      function isObject(obj) {
        return ObjProto.toString.call(obj) === '[object Object]';
      }

      exports.isObject = isObject;
      /**
       * @param {string|number} attr
       * @returns {(string|number)[]}
       * @private
       */

      function _prepareAttributeParts(attr) {
        if (!attr) {
          return [];
        }

        if (typeof attr === 'string') {
          return attr.split('.');
        }

        return [attr];
      }
      /**
       * @param {string}   attribute      Attribute value. Dots allowed.
       * @returns {function(Object): *}
       */


      function getAttrGetter(attribute) {
        var parts = _prepareAttributeParts(attribute);

        return function attrGetter(item) {
          var _item = item;

          for (var i = 0; i < parts.length; i++) {
            var part = parts[i]; // If item is not an object, and we still got parts to handle, it means
            // that something goes wrong. Just roll out to undefined in that case.

            if (hasOwnProp(_item, part)) {
              _item = _item[part];
            } else {
              return undefined;
            }
          }

          return _item;
        };
      }

      function groupBy(obj, val, throwOnUndefined) {
        var result = {};
        var iterator = isFunction(val) ? val : getAttrGetter(val);

        for (var i = 0; i < obj.length; i++) {
          var value = obj[i];
          var key = iterator(value, i);

          if (key === undefined && throwOnUndefined === true) {
            throw new TypeError("groupby: attribute \"" + val + "\" resolved to undefined");
          }

          (result[key] || (result[key] = [])).push(value);
        }

        return result;
      }

      exports.groupBy = groupBy;

      function toArray(obj) {
        return Array.prototype.slice.call(obj);
      }

      exports.toArray = toArray;

      function without(array) {
        var result = [];

        if (!array) {
          return result;
        }

        var length = array.length;
        var contains = toArray(arguments).slice(1);
        var index = -1;

        while (++index < length) {
          if (indexOf(contains, array[index]) === -1) {
            result.push(array[index]);
          }
        }

        return result;
      }

      exports.without = without;

      function repeat(char_, n) {
        var str = '';

        for (var i = 0; i < n; i++) {
          str += char_;
        }

        return str;
      }

      exports.repeat = repeat;

      function each(obj, func, context) {
        if (obj == null) {
          return;
        }

        if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
          obj.forEach(func, context);
        } else if (obj.length === +obj.length) {
          for (var i = 0, l = obj.length; i < l; i++) {
            func.call(context, obj[i], i, obj);
          }
        }
      }

      exports.each = each;

      function map(obj, func) {
        var results = [];

        if (obj == null) {
          return results;
        }

        if (ArrayProto.map && obj.map === ArrayProto.map) {
          return obj.map(func);
        }

        for (var i = 0; i < obj.length; i++) {
          results[results.length] = func(obj[i], i);
        }

        if (obj.length === +obj.length) {
          results.length = obj.length;
        }

        return results;
      }

      exports.map = map;

      function asyncIter(arr, iter, cb) {
        var i = -1;

        function next() {
          i++;

          if (i < arr.length) {
            iter(arr[i], i, next, cb);
          } else {
            cb();
          }
        }

        next();
      }

      exports.asyncIter = asyncIter;

      function asyncFor(obj, iter, cb) {
        var keys = keys_(obj || {});
        var len = keys.length;
        var i = -1;

        function next() {
          i++;
          var k = keys[i];

          if (i < len) {
            iter(k, obj[k], i, len, next);
          } else {
            cb();
          }
        }

        next();
      }

      exports.asyncFor = asyncFor;

      function indexOf(arr, searchElement, fromIndex) {
        return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
      }

      exports.indexOf = indexOf;

      function keys_(obj) {
        /* eslint-disable no-restricted-syntax */
        var arr = [];

        for (var k in obj) {
          if (hasOwnProp(obj, k)) {
            arr.push(k);
          }
        }

        return arr;
      }

      exports.keys = keys_;

      function _entries(obj) {
        return keys_(obj).map(function (k) {
          return [k, obj[k]];
        });
      }

      exports._entries = _entries;

      function _values(obj) {
        return keys_(obj).map(function (k) {
          return obj[k];
        });
      }

      exports._values = _values;

      function extend(obj1, obj2) {
        obj1 = obj1 || {};
        keys_(obj2).forEach(function (k) {
          obj1[k] = obj2[k];
        });
        return obj1;
      }

      exports._assign = exports.extend = extend;

      function inOperator(key, val) {
        if (isArray(val) || isString(val)) {
          return val.indexOf(key) !== -1;
        } else if (isObject(val)) {
          return key in val;
        }

        throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
      }

      exports.inOperator = inOperator;
      /***/
    },
    /* 1 */

    /***/
    function (module, exports, __nested_webpack_require_13639__) {
      "use strict"; // A simple class system, more documentation to come

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var EventEmitter = __nested_webpack_require_13639__(16);

      var lib = __nested_webpack_require_13639__(0);

      function parentWrap(parent, prop) {
        if (typeof parent !== 'function' || typeof prop !== 'function') {
          return prop;
        }

        return function wrap() {
          // Save the current parent method
          var tmp = this.parent; // Set parent to the previous method, call, and restore

          this.parent = parent;
          var res = prop.apply(this, arguments);
          this.parent = tmp;
          return res;
        };
      }

      function extendClass(cls, name, props) {
        props = props || {};
        lib.keys(props).forEach(function (k) {
          props[k] = parentWrap(cls.prototype[k], props[k]);
        });

        var subclass = /*#__PURE__*/function (_cls) {
          _inheritsLoose(subclass, _cls);

          function subclass() {
            return _cls.apply(this, arguments) || this;
          }

          _createClass(subclass, [{
            key: "typename",
            get: function get() {
              return name;
            }
          }]);

          return subclass;
        }(cls);

        lib._assign(subclass.prototype, props);

        return subclass;
      }

      var Obj = /*#__PURE__*/function () {
        function Obj() {
          // Unfortunately necessary for backwards compatibility
          this.init.apply(this, arguments);
        }

        var _proto = Obj.prototype;

        _proto.init = function init() {};

        Obj.extend = function extend(name, props) {
          if (typeof name === 'object') {
            props = name;
            name = 'anonymous';
          }

          return extendClass(this, name, props);
        };

        _createClass(Obj, [{
          key: "typename",
          get: function get() {
            return this.constructor.name;
          }
        }]);

        return Obj;
      }();

      var EmitterObj = /*#__PURE__*/function (_EventEmitter) {
        _inheritsLoose(EmitterObj, _EventEmitter);

        function EmitterObj() {
          var _this2;

          var _this;

          _this = _EventEmitter.call(this) || this; // Unfortunately necessary for backwards compatibility

          (_this2 = _this).init.apply(_this2, arguments);

          return _this;
        }

        var _proto2 = EmitterObj.prototype;

        _proto2.init = function init() {};

        EmitterObj.extend = function extend(name, props) {
          if (typeof name === 'object') {
            props = name;
            name = 'anonymous';
          }

          return extendClass(this, name, props);
        };

        _createClass(EmitterObj, [{
          key: "typename",
          get: function get() {
            return this.constructor.name;
          }
        }]);

        return EmitterObj;
      }(EventEmitter);

      module.exports = {
        Obj: Obj,
        EmitterObj: EmitterObj
      };
      /***/
    },
    /* 2 */

    /***/
    function (module, exports, __nested_webpack_require_17614__) {
      "use strict";

      var lib = __nested_webpack_require_17614__(0);

      var arrayFrom = Array.from;
      var supportsIterators = typeof Symbol === 'function' && Symbol.iterator && typeof arrayFrom === 'function'; // Frames keep track of scoping both at compile-time and run-time so
      // we know how to access variables. Block tags can introduce special
      // variables, for example.

      var Frame = /*#__PURE__*/function () {
        function Frame(parent, isolateWrites) {
          this.variables = {};
          this.parent = parent;
          this.topLevel = false; // if this is true, writes (set) should never propagate upwards past
          // this frame to its parent (though reads may).

          this.isolateWrites = isolateWrites;
        }

        var _proto = Frame.prototype;

        _proto.set = function set(name, val, resolveUp) {
          // Allow variables with dots by automatically creating the
          // nested structure
          var parts = name.split('.');
          var obj = this.variables;
          var frame = this;

          if (resolveUp) {
            if (frame = this.resolve(parts[0], true)) {
              frame.set(name, val);
              return;
            }
          }

          for (var i = 0; i < parts.length - 1; i++) {
            var id = parts[i];

            if (!obj[id]) {
              obj[id] = {};
            }

            obj = obj[id];
          }

          obj[parts[parts.length - 1]] = val;
        };

        _proto.get = function get(name) {
          var val = this.variables[name];

          if (val !== undefined) {
            return val;
          }

          return null;
        };

        _proto.lookup = function lookup(name) {
          var p = this.parent;
          var val = this.variables[name];

          if (val !== undefined) {
            return val;
          }

          return p && p.lookup(name);
        };

        _proto.resolve = function resolve(name, forWrite) {
          var p = forWrite && this.isolateWrites ? undefined : this.parent;
          var val = this.variables[name];

          if (val !== undefined) {
            return this;
          }

          return p && p.resolve(name);
        };

        _proto.push = function push(isolateWrites) {
          return new Frame(this, isolateWrites);
        };

        _proto.pop = function pop() {
          return this.parent;
        };

        return Frame;
      }();

      function makeMacro(argNames, kwargNames, func) {
        var _this = this;

        return function () {
          for (var _len = arguments.length, macroArgs = new Array(_len), _key = 0; _key < _len; _key++) {
            macroArgs[_key] = arguments[_key];
          }

          var argCount = numArgs(macroArgs);
          var args;
          var kwargs = getKeywordArgs(macroArgs);

          if (argCount > argNames.length) {
            args = macroArgs.slice(0, argNames.length); // Positional arguments that should be passed in as
            // keyword arguments (essentially default values)

            macroArgs.slice(args.length, argCount).forEach(function (val, i) {
              if (i < kwargNames.length) {
                kwargs[kwargNames[i]] = val;
              }
            });
            args.push(kwargs);
          } else if (argCount < argNames.length) {
            args = macroArgs.slice(0, argCount);

            for (var i = argCount; i < argNames.length; i++) {
              var arg = argNames[i]; // Keyword arguments that should be passed as
              // positional arguments, i.e. the caller explicitly
              // used the name of a positional arg

              args.push(kwargs[arg]);
              delete kwargs[arg];
            }

            args.push(kwargs);
          } else {
            args = macroArgs;
          }

          return func.apply(_this, args);
        };
      }

      function makeKeywordArgs(obj) {
        obj.__keywords = true;
        return obj;
      }

      function isKeywordArgs(obj) {
        return obj && Object.prototype.hasOwnProperty.call(obj, '__keywords');
      }

      function getKeywordArgs(args) {
        var len = args.length;

        if (len) {
          var lastArg = args[len - 1];

          if (isKeywordArgs(lastArg)) {
            return lastArg;
          }
        }

        return {};
      }

      function numArgs(args) {
        var len = args.length;

        if (len === 0) {
          return 0;
        }

        var lastArg = args[len - 1];

        if (isKeywordArgs(lastArg)) {
          return len - 1;
        } else {
          return len;
        }
      } // A SafeString object indicates that the string should not be
      // autoescaped. This happens magically because autoescaping only
      // occurs on primitive string objects.


      function SafeString(val) {
        if (typeof val !== 'string') {
          return val;
        }

        this.val = val;
        this.length = val.length;
      }

      SafeString.prototype = Object.create(String.prototype, {
        length: {
          writable: true,
          configurable: true,
          value: 0
        }
      });

      SafeString.prototype.valueOf = function valueOf() {
        return this.val;
      };

      SafeString.prototype.toString = function toString() {
        return this.val;
      };

      function copySafeness(dest, target) {
        if (dest instanceof SafeString) {
          return new SafeString(target);
        }

        return target.toString();
      }

      function markSafe(val) {
        var type = typeof val;

        if (type === 'string') {
          return new SafeString(val);
        } else if (type !== 'function') {
          return val;
        } else {
          return function wrapSafe(args) {
            var ret = val.apply(this, arguments);

            if (typeof ret === 'string') {
              return new SafeString(ret);
            }

            return ret;
          };
        }
      }

      function suppressValue(val, autoescape) {
        val = val !== undefined && val !== null ? val : '';

        if (autoescape && !(val instanceof SafeString)) {
          val = lib.escape(val.toString());
        }

        return val;
      }

      function ensureDefined(val, lineno, colno) {
        if (val === null || val === undefined) {
          throw new lib.TemplateError('attempted to output null or undefined value', lineno + 1, colno + 1);
        }

        return val;
      }

      function memberLookup(obj, val) {
        if (obj === undefined || obj === null) {
          return undefined;
        }

        if (typeof obj[val] === 'function') {
          return function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            return obj[val].apply(obj, args);
          };
        }

        return obj[val];
      }

      function callWrap(obj, name, context, args) {
        if (!obj) {
          throw new Error('Unable to call `' + name + '`, which is undefined or falsey');
        } else if (typeof obj !== 'function') {
          throw new Error('Unable to call `' + name + '`, which is not a function');
        }

        return obj.apply(context, args);
      }

      function contextOrFrameLookup(context, frame, name) {
        var val = frame.lookup(name);
        return val !== undefined ? val : context.lookup(name);
      }

      function handleError(error, lineno, colno) {
        if (error.lineno) {
          return error;
        } else {
          return new lib.TemplateError(error, lineno, colno);
        }
      }

      function asyncEach(arr, dimen, iter, cb) {
        if (lib.isArray(arr)) {
          var len = arr.length;
          lib.asyncIter(arr, function iterCallback(item, i, next) {
            switch (dimen) {
              case 1:
                iter(item, i, len, next);
                break;

              case 2:
                iter(item[0], item[1], i, len, next);
                break;

              case 3:
                iter(item[0], item[1], item[2], i, len, next);
                break;

              default:
                item.push(i, len, next);
                iter.apply(this, item);
            }
          }, cb);
        } else {
          lib.asyncFor(arr, function iterCallback(key, val, i, len, next) {
            iter(key, val, i, len, next);
          }, cb);
        }
      }

      function asyncAll(arr, dimen, func, cb) {
        var finished = 0;
        var len;
        var outputArr;

        function done(i, output) {
          finished++;
          outputArr[i] = output;

          if (finished === len) {
            cb(null, outputArr.join(''));
          }
        }

        if (lib.isArray(arr)) {
          len = arr.length;
          outputArr = new Array(len);

          if (len === 0) {
            cb(null, '');
          } else {
            for (var i = 0; i < arr.length; i++) {
              var item = arr[i];

              switch (dimen) {
                case 1:
                  func(item, i, len, done);
                  break;

                case 2:
                  func(item[0], item[1], i, len, done);
                  break;

                case 3:
                  func(item[0], item[1], item[2], i, len, done);
                  break;

                default:
                  item.push(i, len, done);
                  func.apply(this, item);
              }
            }
          }
        } else {
          var keys = lib.keys(arr || {});
          len = keys.length;
          outputArr = new Array(len);

          if (len === 0) {
            cb(null, '');
          } else {
            for (var _i = 0; _i < keys.length; _i++) {
              var k = keys[_i];
              func(k, arr[k], _i, len, done);
            }
          }
        }
      }

      function fromIterator(arr) {
        if (typeof arr !== 'object' || arr === null || lib.isArray(arr)) {
          return arr;
        } else if (supportsIterators && Symbol.iterator in arr) {
          return arrayFrom(arr);
        } else {
          return arr;
        }
      }

      module.exports = {
        Frame: Frame,
        makeMacro: makeMacro,
        makeKeywordArgs: makeKeywordArgs,
        numArgs: numArgs,
        suppressValue: suppressValue,
        ensureDefined: ensureDefined,
        memberLookup: memberLookup,
        contextOrFrameLookup: contextOrFrameLookup,
        callWrap: callWrap,
        handleError: handleError,
        isArray: lib.isArray,
        keys: lib.keys,
        SafeString: SafeString,
        copySafeness: copySafeness,
        markSafe: markSafe,
        asyncEach: asyncEach,
        asyncAll: asyncAll,
        inOperator: lib.inOperator,
        fromIterator: fromIterator
      };
      /***/
    },
    /* 3 */

    /***/
    function (module, exports, __nested_webpack_require_28625__) {
      "use strict";

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var _require = __nested_webpack_require_28625__(1),
          Obj = _require.Obj;

      function traverseAndCheck(obj, type, results) {
        if (obj instanceof type) {
          results.push(obj);
        }

        if (obj instanceof Node) {
          obj.findAll(type, results);
        }
      }

      var Node = /*#__PURE__*/function (_Obj) {
        _inheritsLoose(Node, _Obj);

        function Node() {
          return _Obj.apply(this, arguments) || this;
        }

        var _proto = Node.prototype;

        _proto.init = function init(lineno, colno) {
          var _arguments = arguments,
              _this = this;

          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          this.lineno = lineno;
          this.colno = colno;
          this.fields.forEach(function (field, i) {
            // The first two args are line/col numbers, so offset by 2
            var val = _arguments[i + 2]; // Fields should never be undefined, but null. It makes
            // testing easier to normalize values.

            if (val === undefined) {
              val = null;
            }

            _this[field] = val;
          });
        };

        _proto.findAll = function findAll(type, results) {
          var _this2 = this;

          results = results || [];

          if (this instanceof NodeList) {
            this.children.forEach(function (child) {
              return traverseAndCheck(child, type, results);
            });
          } else {
            this.fields.forEach(function (field) {
              return traverseAndCheck(_this2[field], type, results);
            });
          }

          return results;
        };

        _proto.iterFields = function iterFields(func) {
          var _this3 = this;

          this.fields.forEach(function (field) {
            func(_this3[field], field);
          });
        };

        return Node;
      }(Obj); // Abstract nodes


      var Value = /*#__PURE__*/function (_Node) {
        _inheritsLoose(Value, _Node);

        function Value() {
          return _Node.apply(this, arguments) || this;
        }

        _createClass(Value, [{
          key: "typename",
          get: function get() {
            return 'Value';
          }
        }, {
          key: "fields",
          get: function get() {
            return ['value'];
          }
        }]);

        return Value;
      }(Node); // Concrete nodes


      var NodeList = /*#__PURE__*/function (_Node2) {
        _inheritsLoose(NodeList, _Node2);

        function NodeList() {
          return _Node2.apply(this, arguments) || this;
        }

        var _proto2 = NodeList.prototype;

        _proto2.init = function init(lineno, colno, nodes) {
          _Node2.prototype.init.call(this, lineno, colno, nodes || []);
        };

        _proto2.addChild = function addChild(node) {
          this.children.push(node);
        };

        _createClass(NodeList, [{
          key: "typename",
          get: function get() {
            return 'NodeList';
          }
        }, {
          key: "fields",
          get: function get() {
            return ['children'];
          }
        }]);

        return NodeList;
      }(Node);

      var Root = NodeList.extend('Root');
      var Literal = Value.extend('Literal');
      var Symbol = Value.extend('Symbol');
      var Group = NodeList.extend('Group');
      var ArrayNode = NodeList.extend('Array');
      var Pair = Node.extend('Pair', {
        fields: ['key', 'value']
      });
      var Dict = NodeList.extend('Dict');
      var LookupVal = Node.extend('LookupVal', {
        fields: ['target', 'val']
      });
      var If = Node.extend('If', {
        fields: ['cond', 'body', 'else_']
      });
      var IfAsync = If.extend('IfAsync');
      var InlineIf = Node.extend('InlineIf', {
        fields: ['cond', 'body', 'else_']
      });
      var For = Node.extend('For', {
        fields: ['arr', 'name', 'body', 'else_']
      });
      var AsyncEach = For.extend('AsyncEach');
      var AsyncAll = For.extend('AsyncAll');
      var Macro = Node.extend('Macro', {
        fields: ['name', 'args', 'body']
      });
      var Caller = Macro.extend('Caller');
      var Import = Node.extend('Import', {
        fields: ['template', 'target', 'withContext']
      });

      var FromImport = /*#__PURE__*/function (_Node3) {
        _inheritsLoose(FromImport, _Node3);

        function FromImport() {
          return _Node3.apply(this, arguments) || this;
        }

        var _proto3 = FromImport.prototype;

        _proto3.init = function init(lineno, colno, template, names, withContext) {
          _Node3.prototype.init.call(this, lineno, colno, template, names || new NodeList(), withContext);
        };

        _createClass(FromImport, [{
          key: "typename",
          get: function get() {
            return 'FromImport';
          }
        }, {
          key: "fields",
          get: function get() {
            return ['template', 'names', 'withContext'];
          }
        }]);

        return FromImport;
      }(Node);

      var FunCall = Node.extend('FunCall', {
        fields: ['name', 'args']
      });
      var Filter = FunCall.extend('Filter');
      var FilterAsync = Filter.extend('FilterAsync', {
        fields: ['name', 'args', 'symbol']
      });
      var KeywordArgs = Dict.extend('KeywordArgs');
      var Block = Node.extend('Block', {
        fields: ['name', 'body']
      });
      var Super = Node.extend('Super', {
        fields: ['blockName', 'symbol']
      });
      var TemplateRef = Node.extend('TemplateRef', {
        fields: ['template']
      });
      var Extends = TemplateRef.extend('Extends');
      var Include = Node.extend('Include', {
        fields: ['template', 'ignoreMissing']
      });
      var Set = Node.extend('Set', {
        fields: ['targets', 'value']
      });
      var Switch = Node.extend('Switch', {
        fields: ['expr', 'cases', 'default']
      });
      var Case = Node.extend('Case', {
        fields: ['cond', 'body']
      });
      var Output = NodeList.extend('Output');
      var Capture = Node.extend('Capture', {
        fields: ['body']
      });
      var TemplateData = Literal.extend('TemplateData');
      var UnaryOp = Node.extend('UnaryOp', {
        fields: ['target']
      });
      var BinOp = Node.extend('BinOp', {
        fields: ['left', 'right']
      });
      var In = BinOp.extend('In');
      var Is = BinOp.extend('Is');
      var Or = BinOp.extend('Or');
      var And = BinOp.extend('And');
      var Not = UnaryOp.extend('Not');
      var Add = BinOp.extend('Add');
      var Concat = BinOp.extend('Concat');
      var Sub = BinOp.extend('Sub');
      var Mul = BinOp.extend('Mul');
      var Div = BinOp.extend('Div');
      var FloorDiv = BinOp.extend('FloorDiv');
      var Mod = BinOp.extend('Mod');
      var Pow = BinOp.extend('Pow');
      var Neg = UnaryOp.extend('Neg');
      var Pos = UnaryOp.extend('Pos');
      var Compare = Node.extend('Compare', {
        fields: ['expr', 'ops']
      });
      var CompareOperand = Node.extend('CompareOperand', {
        fields: ['expr', 'type']
      });
      var CallExtension = Node.extend('CallExtension', {
        init: function init(ext, prop, args, contentArgs) {
          this.parent();
          this.extName = ext.__name || ext;
          this.prop = prop;
          this.args = args || new NodeList();
          this.contentArgs = contentArgs || [];
          this.autoescape = ext.autoescape;
        },
        fields: ['extName', 'prop', 'args', 'contentArgs']
      });
      var CallExtensionAsync = CallExtension.extend('CallExtensionAsync'); // This is hacky, but this is just a debugging function anyway

      function print(str, indent, inline) {
        var lines = str.split('\n');
        lines.forEach(function (line, i) {
          if (line && (inline && i > 0 || !inline)) {
            process.stdout.write(' '.repeat(indent));
          }

          var nl = i === lines.length - 1 ? '' : '\n';
          process.stdout.write("" + line + nl);
        });
      } // Print the AST in a nicely formatted tree format for debuggin


      function printNodes(node, indent) {
        indent = indent || 0;
        print(node.typename + ': ', indent);

        if (node instanceof NodeList) {
          print('\n');
          node.children.forEach(function (n) {
            printNodes(n, indent + 2);
          });
        } else if (node instanceof CallExtension) {
          print(node.extName + "." + node.prop + "\n");

          if (node.args) {
            printNodes(node.args, indent + 2);
          }

          if (node.contentArgs) {
            node.contentArgs.forEach(function (n) {
              printNodes(n, indent + 2);
            });
          }
        } else {
          var nodes = [];
          var props = null;
          node.iterFields(function (val, fieldName) {
            if (val instanceof Node) {
              nodes.push([fieldName, val]);
            } else {
              props = props || {};
              props[fieldName] = val;
            }
          });

          if (props) {
            print(JSON.stringify(props, null, 2) + '\n', null, true);
          } else {
            print('\n');
          }

          nodes.forEach(function (_ref) {
            var fieldName = _ref[0],
                n = _ref[1];
            print("[" + fieldName + "] =>", indent + 2);
            printNodes(n, indent + 4);
          });
        }
      }

      module.exports = {
        Node: Node,
        Root: Root,
        NodeList: NodeList,
        Value: Value,
        Literal: Literal,
        Symbol: Symbol,
        Group: Group,
        Array: ArrayNode,
        Pair: Pair,
        Dict: Dict,
        Output: Output,
        Capture: Capture,
        TemplateData: TemplateData,
        If: If,
        IfAsync: IfAsync,
        InlineIf: InlineIf,
        For: For,
        AsyncEach: AsyncEach,
        AsyncAll: AsyncAll,
        Macro: Macro,
        Caller: Caller,
        Import: Import,
        FromImport: FromImport,
        FunCall: FunCall,
        Filter: Filter,
        FilterAsync: FilterAsync,
        KeywordArgs: KeywordArgs,
        Block: Block,
        Super: Super,
        Extends: Extends,
        Include: Include,
        Set: Set,
        Switch: Switch,
        Case: Case,
        LookupVal: LookupVal,
        BinOp: BinOp,
        In: In,
        Is: Is,
        Or: Or,
        And: And,
        Not: Not,
        Add: Add,
        Concat: Concat,
        Sub: Sub,
        Mul: Mul,
        Div: Div,
        FloorDiv: FloorDiv,
        Mod: Mod,
        Pow: Pow,
        Neg: Neg,
        Pos: Pos,
        Compare: Compare,
        CompareOperand: CompareOperand,
        CallExtension: CallExtension,
        CallExtensionAsync: CallExtensionAsync,
        printNodes: printNodes
      };
      /***/
    },
    /* 4 */

    /***/
    function (module, exports) {
      /***/
    },
    /* 5 */

    /***/
    function (module, exports, __nested_webpack_require_40721__) {
      "use strict";

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var parser = __nested_webpack_require_40721__(8);

      var transformer = __nested_webpack_require_40721__(17);

      var nodes = __nested_webpack_require_40721__(3);

      var _require = __nested_webpack_require_40721__(0),
          TemplateError = _require.TemplateError;

      var _require2 = __nested_webpack_require_40721__(2),
          Frame = _require2.Frame;

      var _require3 = __nested_webpack_require_40721__(1),
          Obj = _require3.Obj; // These are all the same for now, but shouldn't be passed straight
      // through


      var compareOps = {
        '==': '==',
        '===': '===',
        '!=': '!=',
        '!==': '!==',
        '<': '<',
        '>': '>',
        '<=': '<=',
        '>=': '>='
      };

      var Compiler = /*#__PURE__*/function (_Obj) {
        _inheritsLoose(Compiler, _Obj);

        function Compiler() {
          return _Obj.apply(this, arguments) || this;
        }

        var _proto = Compiler.prototype;

        _proto.init = function init(templateName, throwOnUndefined) {
          this.templateName = templateName;
          this.codebuf = [];
          this.lastId = 0;
          this.buffer = null;
          this.bufferStack = [];
          this._scopeClosers = '';
          this.inBlock = false;
          this.throwOnUndefined = throwOnUndefined;
        };

        _proto.fail = function fail(msg, lineno, colno) {
          if (lineno !== undefined) {
            lineno += 1;
          }

          if (colno !== undefined) {
            colno += 1;
          }

          throw new TemplateError(msg, lineno, colno);
        };

        _proto._pushBuffer = function _pushBuffer() {
          var id = this._tmpid();

          this.bufferStack.push(this.buffer);
          this.buffer = id;

          this._emit("var " + this.buffer + " = \"\";");

          return id;
        };

        _proto._popBuffer = function _popBuffer() {
          this.buffer = this.bufferStack.pop();
        };

        _proto._emit = function _emit(code) {
          this.codebuf.push(code);
        };

        _proto._emitLine = function _emitLine(code) {
          this._emit(code + '\n');
        };

        _proto._emitLines = function _emitLines() {
          var _this = this;

          for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
            lines[_key] = arguments[_key];
          }

          lines.forEach(function (line) {
            return _this._emitLine(line);
          });
        };

        _proto._emitFuncBegin = function _emitFuncBegin(node, name) {
          this.buffer = 'output';
          this._scopeClosers = '';

          this._emitLine("function " + name + "(env, context, frame, runtime, cb) {");

          this._emitLine("var lineno = " + node.lineno + ";");

          this._emitLine("var colno = " + node.colno + ";");

          this._emitLine("var " + this.buffer + " = \"\";");

          this._emitLine('try {');
        };

        _proto._emitFuncEnd = function _emitFuncEnd(noReturn) {
          if (!noReturn) {
            this._emitLine('cb(null, ' + this.buffer + ');');
          }

          this._closeScopeLevels();

          this._emitLine('} catch (e) {');

          this._emitLine('  cb(runtime.handleError(e, lineno, colno));');

          this._emitLine('}');

          this._emitLine('}');

          this.buffer = null;
        };

        _proto._addScopeLevel = function _addScopeLevel() {
          this._scopeClosers += '})';
        };

        _proto._closeScopeLevels = function _closeScopeLevels() {
          this._emitLine(this._scopeClosers + ';');

          this._scopeClosers = '';
        };

        _proto._withScopedSyntax = function _withScopedSyntax(func) {
          var _scopeClosers = this._scopeClosers;
          this._scopeClosers = '';
          func.call(this);

          this._closeScopeLevels();

          this._scopeClosers = _scopeClosers;
        };

        _proto._makeCallback = function _makeCallback(res) {
          var err = this._tmpid();

          return 'function(' + err + (res ? ',' + res : '') + ') {\n' + 'if(' + err + ') { cb(' + err + '); return; }';
        };

        _proto._tmpid = function _tmpid() {
          this.lastId++;
          return 't_' + this.lastId;
        };

        _proto._templateName = function _templateName() {
          return this.templateName == null ? 'undefined' : JSON.stringify(this.templateName);
        };

        _proto._compileChildren = function _compileChildren(node, frame) {
          var _this2 = this;

          node.children.forEach(function (child) {
            _this2.compile(child, frame);
          });
        };

        _proto._compileAggregate = function _compileAggregate(node, frame, startChar, endChar) {
          var _this3 = this;

          if (startChar) {
            this._emit(startChar);
          }

          node.children.forEach(function (child, i) {
            if (i > 0) {
              _this3._emit(',');
            }

            _this3.compile(child, frame);
          });

          if (endChar) {
            this._emit(endChar);
          }
        };

        _proto._compileExpression = function _compileExpression(node, frame) {
          // TODO: I'm not really sure if this type check is worth it or
          // not.
          this.assertType(node, nodes.Literal, nodes.Symbol, nodes.Group, nodes.Array, nodes.Dict, nodes.FunCall, nodes.Caller, nodes.Filter, nodes.LookupVal, nodes.Compare, nodes.InlineIf, nodes.In, nodes.Is, nodes.And, nodes.Or, nodes.Not, nodes.Add, nodes.Concat, nodes.Sub, nodes.Mul, nodes.Div, nodes.FloorDiv, nodes.Mod, nodes.Pow, nodes.Neg, nodes.Pos, nodes.Compare, nodes.NodeList);
          this.compile(node, frame);
        };

        _proto.assertType = function assertType(node) {
          for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            types[_key2 - 1] = arguments[_key2];
          }

          if (!types.some(function (t) {
            return node instanceof t;
          })) {
            this.fail("assertType: invalid type: " + node.typename, node.lineno, node.colno);
          }
        };

        _proto.compileCallExtension = function compileCallExtension(node, frame, async) {
          var _this4 = this;

          var args = node.args;
          var contentArgs = node.contentArgs;
          var autoescape = typeof node.autoescape === 'boolean' ? node.autoescape : true;

          if (!async) {
            this._emit(this.buffer + " += runtime.suppressValue(");
          }

          this._emit("env.getExtension(\"" + node.extName + "\")[\"" + node.prop + "\"](");

          this._emit('context');

          if (args || contentArgs) {
            this._emit(',');
          }

          if (args) {
            if (!(args instanceof nodes.NodeList)) {
              this.fail('compileCallExtension: arguments must be a NodeList, ' + 'use `parser.parseSignature`');
            }

            args.children.forEach(function (arg, i) {
              // Tag arguments are passed normally to the call. Note
              // that keyword arguments are turned into a single js
              // object as the last argument, if they exist.
              _this4._compileExpression(arg, frame);

              if (i !== args.children.length - 1 || contentArgs.length) {
                _this4._emit(',');
              }
            });
          }

          if (contentArgs.length) {
            contentArgs.forEach(function (arg, i) {
              if (i > 0) {
                _this4._emit(',');
              }

              if (arg) {
                _this4._emitLine('function(cb) {');

                _this4._emitLine('if(!cb) { cb = function(err) { if(err) { throw err; }}}');

                var id = _this4._pushBuffer();

                _this4._withScopedSyntax(function () {
                  _this4.compile(arg, frame);

                  _this4._emitLine("cb(null, " + id + ");");
                });

                _this4._popBuffer();

                _this4._emitLine("return " + id + ";");

                _this4._emitLine('}');
              } else {
                _this4._emit('null');
              }
            });
          }

          if (async) {
            var res = this._tmpid();

            this._emitLine(', ' + this._makeCallback(res));

            this._emitLine(this.buffer + " += runtime.suppressValue(" + res + ", " + autoescape + " && env.opts.autoescape);");

            this._addScopeLevel();
          } else {
            this._emit(')');

            this._emit(", " + autoescape + " && env.opts.autoescape);\n");
          }
        };

        _proto.compileCallExtensionAsync = function compileCallExtensionAsync(node, frame) {
          this.compileCallExtension(node, frame, true);
        };

        _proto.compileNodeList = function compileNodeList(node, frame) {
          this._compileChildren(node, frame);
        };

        _proto.compileLiteral = function compileLiteral(node) {
          if (typeof node.value === 'string') {
            var val = node.value.replace(/\\/g, '\\\\');
            val = val.replace(/"/g, '\\"');
            val = val.replace(/\n/g, '\\n');
            val = val.replace(/\r/g, '\\r');
            val = val.replace(/\t/g, '\\t');
            val = val.replace(/\u2028/g, "\\u2028");

            this._emit("\"" + val + "\"");
          } else if (node.value === null) {
            this._emit('null');
          } else {
            this._emit(node.value.toString());
          }
        };

        _proto.compileSymbol = function compileSymbol(node, frame) {
          var name = node.value;
          var v = frame.lookup(name);

          if (v) {
            this._emit(v);
          } else {
            this._emit('runtime.contextOrFrameLookup(' + 'context, frame, "' + name + '")');
          }
        };

        _proto.compileGroup = function compileGroup(node, frame) {
          this._compileAggregate(node, frame, '(', ')');
        };

        _proto.compileArray = function compileArray(node, frame) {
          this._compileAggregate(node, frame, '[', ']');
        };

        _proto.compileDict = function compileDict(node, frame) {
          this._compileAggregate(node, frame, '{', '}');
        };

        _proto.compilePair = function compilePair(node, frame) {
          var key = node.key;
          var val = node.value;

          if (key instanceof nodes.Symbol) {
            key = new nodes.Literal(key.lineno, key.colno, key.value);
          } else if (!(key instanceof nodes.Literal && typeof key.value === 'string')) {
            this.fail('compilePair: Dict keys must be strings or names', key.lineno, key.colno);
          }

          this.compile(key, frame);

          this._emit(': ');

          this._compileExpression(val, frame);
        };

        _proto.compileInlineIf = function compileInlineIf(node, frame) {
          this._emit('(');

          this.compile(node.cond, frame);

          this._emit('?');

          this.compile(node.body, frame);

          this._emit(':');

          if (node.else_ !== null) {
            this.compile(node.else_, frame);
          } else {
            this._emit('""');
          }

          this._emit(')');
        };

        _proto.compileIn = function compileIn(node, frame) {
          this._emit('runtime.inOperator(');

          this.compile(node.left, frame);

          this._emit(',');

          this.compile(node.right, frame);

          this._emit(')');
        };

        _proto.compileIs = function compileIs(node, frame) {
          // first, we need to try to get the name of the test function, if it's a
          // callable (i.e., has args) and not a symbol.
          var right = node.right.name ? node.right.name.value // otherwise go with the symbol value
          : node.right.value;

          this._emit('env.getTest("' + right + '").call(context, ');

          this.compile(node.left, frame); // compile the arguments for the callable if they exist

          if (node.right.args) {
            this._emit(',');

            this.compile(node.right.args, frame);
          }

          this._emit(') === true');
        };

        _proto._binOpEmitter = function _binOpEmitter(node, frame, str) {
          this.compile(node.left, frame);

          this._emit(str);

          this.compile(node.right, frame);
        } // ensure concatenation instead of addition
        // by adding empty string in between
        ;

        _proto.compileOr = function compileOr(node, frame) {
          return this._binOpEmitter(node, frame, ' || ');
        };

        _proto.compileAnd = function compileAnd(node, frame) {
          return this._binOpEmitter(node, frame, ' && ');
        };

        _proto.compileAdd = function compileAdd(node, frame) {
          return this._binOpEmitter(node, frame, ' + ');
        };

        _proto.compileConcat = function compileConcat(node, frame) {
          return this._binOpEmitter(node, frame, ' + "" + ');
        };

        _proto.compileSub = function compileSub(node, frame) {
          return this._binOpEmitter(node, frame, ' - ');
        };

        _proto.compileMul = function compileMul(node, frame) {
          return this._binOpEmitter(node, frame, ' * ');
        };

        _proto.compileDiv = function compileDiv(node, frame) {
          return this._binOpEmitter(node, frame, ' / ');
        };

        _proto.compileMod = function compileMod(node, frame) {
          return this._binOpEmitter(node, frame, ' % ');
        };

        _proto.compileNot = function compileNot(node, frame) {
          this._emit('!');

          this.compile(node.target, frame);
        };

        _proto.compileFloorDiv = function compileFloorDiv(node, frame) {
          this._emit('Math.floor(');

          this.compile(node.left, frame);

          this._emit(' / ');

          this.compile(node.right, frame);

          this._emit(')');
        };

        _proto.compilePow = function compilePow(node, frame) {
          this._emit('Math.pow(');

          this.compile(node.left, frame);

          this._emit(', ');

          this.compile(node.right, frame);

          this._emit(')');
        };

        _proto.compileNeg = function compileNeg(node, frame) {
          this._emit('-');

          this.compile(node.target, frame);
        };

        _proto.compilePos = function compilePos(node, frame) {
          this._emit('+');

          this.compile(node.target, frame);
        };

        _proto.compileCompare = function compileCompare(node, frame) {
          var _this5 = this;

          this.compile(node.expr, frame);
          node.ops.forEach(function (op) {
            _this5._emit(" " + compareOps[op.type] + " ");

            _this5.compile(op.expr, frame);
          });
        };

        _proto.compileLookupVal = function compileLookupVal(node, frame) {
          this._emit('runtime.memberLookup((');

          this._compileExpression(node.target, frame);

          this._emit('),');

          this._compileExpression(node.val, frame);

          this._emit(')');
        };

        _proto._getNodeName = function _getNodeName(node) {
          switch (node.typename) {
            case 'Symbol':
              return node.value;

            case 'FunCall':
              return 'the return value of (' + this._getNodeName(node.name) + ')';

            case 'LookupVal':
              return this._getNodeName(node.target) + '["' + this._getNodeName(node.val) + '"]';

            case 'Literal':
              return node.value.toString();

            default:
              return '--expression--';
          }
        };

        _proto.compileFunCall = function compileFunCall(node, frame) {
          // Keep track of line/col info at runtime by settings
          // variables within an expression. An expression in javascript
          // like (x, y, z) returns the last value, and x and y can be
          // anything
          this._emit('(lineno = ' + node.lineno + ', colno = ' + node.colno + ', ');

          this._emit('runtime.callWrap('); // Compile it as normal.


          this._compileExpression(node.name, frame); // Output the name of what we're calling so we can get friendly errors
          // if the lookup fails.


          this._emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');

          this._compileAggregate(node.args, frame, '[', '])');

          this._emit(')');
        };

        _proto.compileFilter = function compileFilter(node, frame) {
          var name = node.name;
          this.assertType(name, nodes.Symbol);

          this._emit('env.getFilter("' + name.value + '").call(context, ');

          this._compileAggregate(node.args, frame);

          this._emit(')');
        };

        _proto.compileFilterAsync = function compileFilterAsync(node, frame) {
          var name = node.name;
          var symbol = node.symbol.value;
          this.assertType(name, nodes.Symbol);
          frame.set(symbol, symbol);

          this._emit('env.getFilter("' + name.value + '").call(context, ');

          this._compileAggregate(node.args, frame);

          this._emitLine(', ' + this._makeCallback(symbol));

          this._addScopeLevel();
        };

        _proto.compileKeywordArgs = function compileKeywordArgs(node, frame) {
          this._emit('runtime.makeKeywordArgs(');

          this.compileDict(node, frame);

          this._emit(')');
        };

        _proto.compileSet = function compileSet(node, frame) {
          var _this6 = this;

          var ids = []; // Lookup the variable names for each identifier and create
          // new ones if necessary

          node.targets.forEach(function (target) {
            var name = target.value;
            var id = frame.lookup(name);

            if (id === null || id === undefined) {
              id = _this6._tmpid(); // Note: This relies on js allowing scope across
              // blocks, in case this is created inside an `if`

              _this6._emitLine('var ' + id + ';');
            }

            ids.push(id);
          });

          if (node.value) {
            this._emit(ids.join(' = ') + ' = ');

            this._compileExpression(node.value, frame);

            this._emitLine(';');
          } else {
            this._emit(ids.join(' = ') + ' = ');

            this.compile(node.body, frame);

            this._emitLine(';');
          }

          node.targets.forEach(function (target, i) {
            var id = ids[i];
            var name = target.value; // We are running this for every var, but it's very
            // uncommon to assign to multiple vars anyway

            _this6._emitLine("frame.set(\"" + name + "\", " + id + ", true);");

            _this6._emitLine('if(frame.topLevel) {');

            _this6._emitLine("context.setVariable(\"" + name + "\", " + id + ");");

            _this6._emitLine('}');

            if (name.charAt(0) !== '_') {
              _this6._emitLine('if(frame.topLevel) {');

              _this6._emitLine("context.addExport(\"" + name + "\", " + id + ");");

              _this6._emitLine('}');
            }
          });
        };

        _proto.compileSwitch = function compileSwitch(node, frame) {
          var _this7 = this;

          this._emit('switch (');

          this.compile(node.expr, frame);

          this._emit(') {');

          node.cases.forEach(function (c, i) {
            _this7._emit('case ');

            _this7.compile(c.cond, frame);

            _this7._emit(': ');

            _this7.compile(c.body, frame); // preserve fall-throughs


            if (c.body.children.length) {
              _this7._emitLine('break;');
            }
          });

          if (node.default) {
            this._emit('default:');

            this.compile(node.default, frame);
          }

          this._emit('}');
        };

        _proto.compileIf = function compileIf(node, frame, async) {
          var _this8 = this;

          this._emit('if(');

          this._compileExpression(node.cond, frame);

          this._emitLine(') {');

          this._withScopedSyntax(function () {
            _this8.compile(node.body, frame);

            if (async) {
              _this8._emit('cb()');
            }
          });

          if (node.else_) {
            this._emitLine('}\nelse {');

            this._withScopedSyntax(function () {
              _this8.compile(node.else_, frame);

              if (async) {
                _this8._emit('cb()');
              }
            });
          } else if (async) {
            this._emitLine('}\nelse {');

            this._emit('cb()');
          }

          this._emitLine('}');
        };

        _proto.compileIfAsync = function compileIfAsync(node, frame) {
          this._emit('(function(cb) {');

          this.compileIf(node, frame, true);

          this._emit('})(' + this._makeCallback());

          this._addScopeLevel();
        };

        _proto._emitLoopBindings = function _emitLoopBindings(node, arr, i, len) {
          var _this9 = this;

          var bindings = [{
            name: 'index',
            val: i + " + 1"
          }, {
            name: 'index0',
            val: i
          }, {
            name: 'revindex',
            val: len + " - " + i
          }, {
            name: 'revindex0',
            val: len + " - " + i + " - 1"
          }, {
            name: 'first',
            val: i + " === 0"
          }, {
            name: 'last',
            val: i + " === " + len + " - 1"
          }, {
            name: 'length',
            val: len
          }];
          bindings.forEach(function (b) {
            _this9._emitLine("frame.set(\"loop." + b.name + "\", " + b.val + ");");
          });
        };

        _proto.compileFor = function compileFor(node, frame) {
          var _this10 = this; // Some of this code is ugly, but it keeps the generated code
          // as fast as possible. ForAsync also shares some of this, but
          // not much.


          var i = this._tmpid();

          var len = this._tmpid();

          var arr = this._tmpid();

          frame = frame.push();

          this._emitLine('frame = frame.push();');

          this._emit("var " + arr + " = ");

          this._compileExpression(node.arr, frame);

          this._emitLine(';');

          this._emit("if(" + arr + ") {");

          this._emitLine(arr + ' = runtime.fromIterator(' + arr + ');'); // If multiple names are passed, we need to bind them
          // appropriately


          if (node.name instanceof nodes.Array) {
            this._emitLine("var " + i + ";"); // The object could be an arroy or object. Note that the
            // body of the loop is duplicated for each condition, but
            // we are optimizing for speed over size.


            this._emitLine("if(runtime.isArray(" + arr + ")) {");

            this._emitLine("var " + len + " = " + arr + ".length;");

            this._emitLine("for(" + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {"); // Bind each declared var


            node.name.children.forEach(function (child, u) {
              var tid = _this10._tmpid();

              _this10._emitLine("var " + tid + " = " + arr + "[" + i + "][" + u + "];");

              _this10._emitLine("frame.set(\"" + child + "\", " + arr + "[" + i + "][" + u + "]);");

              frame.set(node.name.children[u].value, tid);
            });

            this._emitLoopBindings(node, arr, i, len);

            this._withScopedSyntax(function () {
              _this10.compile(node.body, frame);
            });

            this._emitLine('}');

            this._emitLine('} else {'); // Iterate over the key/values of an object


            var _node$name$children = node.name.children,
                key = _node$name$children[0],
                val = _node$name$children[1];

            var k = this._tmpid();

            var v = this._tmpid();

            frame.set(key.value, k);
            frame.set(val.value, v);

            this._emitLine(i + " = -1;");

            this._emitLine("var " + len + " = runtime.keys(" + arr + ").length;");

            this._emitLine("for(var " + k + " in " + arr + ") {");

            this._emitLine(i + "++;");

            this._emitLine("var " + v + " = " + arr + "[" + k + "];");

            this._emitLine("frame.set(\"" + key.value + "\", " + k + ");");

            this._emitLine("frame.set(\"" + val.value + "\", " + v + ");");

            this._emitLoopBindings(node, arr, i, len);

            this._withScopedSyntax(function () {
              _this10.compile(node.body, frame);
            });

            this._emitLine('}');

            this._emitLine('}');
          } else {
            // Generate a typical array iteration
            var _v = this._tmpid();

            frame.set(node.name.value, _v);

            this._emitLine("var " + len + " = " + arr + ".length;");

            this._emitLine("for(var " + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {");

            this._emitLine("var " + _v + " = " + arr + "[" + i + "];");

            this._emitLine("frame.set(\"" + node.name.value + "\", " + _v + ");");

            this._emitLoopBindings(node, arr, i, len);

            this._withScopedSyntax(function () {
              _this10.compile(node.body, frame);
            });

            this._emitLine('}');
          }

          this._emitLine('}');

          if (node.else_) {
            this._emitLine('if (!' + len + ') {');

            this.compile(node.else_, frame);

            this._emitLine('}');
          }

          this._emitLine('frame = frame.pop();');
        };

        _proto._compileAsyncLoop = function _compileAsyncLoop(node, frame, parallel) {
          var _this11 = this; // This shares some code with the For tag, but not enough to
          // worry about. This iterates across an object asynchronously,
          // but not in parallel.


          var i = this._tmpid();

          var len = this._tmpid();

          var arr = this._tmpid();

          var asyncMethod = parallel ? 'asyncAll' : 'asyncEach';
          frame = frame.push();

          this._emitLine('frame = frame.push();');

          this._emit('var ' + arr + ' = runtime.fromIterator(');

          this._compileExpression(node.arr, frame);

          this._emitLine(');');

          if (node.name instanceof nodes.Array) {
            var arrayLen = node.name.children.length;

            this._emit("runtime." + asyncMethod + "(" + arr + ", " + arrayLen + ", function(");

            node.name.children.forEach(function (name) {
              _this11._emit(name.value + ",");
            });

            this._emit(i + ',' + len + ',next) {');

            node.name.children.forEach(function (name) {
              var id = name.value;
              frame.set(id, id);

              _this11._emitLine("frame.set(\"" + id + "\", " + id + ");");
            });
          } else {
            var id = node.name.value;

            this._emitLine("runtime." + asyncMethod + "(" + arr + ", 1, function(" + id + ", " + i + ", " + len + ",next) {");

            this._emitLine('frame.set("' + id + '", ' + id + ');');

            frame.set(id, id);
          }

          this._emitLoopBindings(node, arr, i, len);

          this._withScopedSyntax(function () {
            var buf;

            if (parallel) {
              buf = _this11._pushBuffer();
            }

            _this11.compile(node.body, frame);

            _this11._emitLine('next(' + i + (buf ? ',' + buf : '') + ');');

            if (parallel) {
              _this11._popBuffer();
            }
          });

          var output = this._tmpid();

          this._emitLine('}, ' + this._makeCallback(output));

          this._addScopeLevel();

          if (parallel) {
            this._emitLine(this.buffer + ' += ' + output + ';');
          }

          if (node.else_) {
            this._emitLine('if (!' + arr + '.length) {');

            this.compile(node.else_, frame);

            this._emitLine('}');
          }

          this._emitLine('frame = frame.pop();');
        };

        _proto.compileAsyncEach = function compileAsyncEach(node, frame) {
          this._compileAsyncLoop(node, frame);
        };

        _proto.compileAsyncAll = function compileAsyncAll(node, frame) {
          this._compileAsyncLoop(node, frame, true);
        };

        _proto._compileMacro = function _compileMacro(node, frame) {
          var _this12 = this;

          var args = [];
          var kwargs = null;

          var funcId = 'macro_' + this._tmpid();

          var keepFrame = frame !== undefined; // Type check the definition of the args

          node.args.children.forEach(function (arg, i) {
            if (i === node.args.children.length - 1 && arg instanceof nodes.Dict) {
              kwargs = arg;
            } else {
              _this12.assertType(arg, nodes.Symbol);

              args.push(arg);
            }
          });
          var realNames = [].concat(args.map(function (n) {
            return "l_" + n.value;
          }), ['kwargs']); // Quoted argument names

          var argNames = args.map(function (n) {
            return "\"" + n.value + "\"";
          });
          var kwargNames = (kwargs && kwargs.children || []).map(function (n) {
            return "\"" + n.key.value + "\"";
          }); // We pass a function to makeMacro which destructures the
          // arguments so support setting positional args with keywords
          // args and passing keyword args as positional args
          // (essentially default values). See runtime.js.

          var currFrame;

          if (keepFrame) {
            currFrame = frame.push(true);
          } else {
            currFrame = new Frame();
          }

          this._emitLines("var " + funcId + " = runtime.makeMacro(", "[" + argNames.join(', ') + "], ", "[" + kwargNames.join(', ') + "], ", "function (" + realNames.join(', ') + ") {", 'var callerFrame = frame;', 'frame = ' + (keepFrame ? 'frame.push(true);' : 'new runtime.Frame();'), 'kwargs = kwargs || {};', 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }'); // Expose the arguments to the template. Don't need to use
          // random names because the function
          // will create a new run-time scope for us


          args.forEach(function (arg) {
            _this12._emitLine("frame.set(\"" + arg.value + "\", l_" + arg.value + ");");

            currFrame.set(arg.value, "l_" + arg.value);
          }); // Expose the keyword arguments

          if (kwargs) {
            kwargs.children.forEach(function (pair) {
              var name = pair.key.value;

              _this12._emit("frame.set(\"" + name + "\", ");

              _this12._emit("Object.prototype.hasOwnProperty.call(kwargs, \"" + name + "\")");

              _this12._emit(" ? kwargs[\"" + name + "\"] : ");

              _this12._compileExpression(pair.value, currFrame);

              _this12._emit(');');
            });
          }

          var bufferId = this._pushBuffer();

          this._withScopedSyntax(function () {
            _this12.compile(node.body, currFrame);
          });

          this._emitLine('frame = ' + (keepFrame ? 'frame.pop();' : 'callerFrame;'));

          this._emitLine("return new runtime.SafeString(" + bufferId + ");");

          this._emitLine('});');

          this._popBuffer();

          return funcId;
        };

        _proto.compileMacro = function compileMacro(node, frame) {
          var funcId = this._compileMacro(node); // Expose the macro to the templates


          var name = node.name.value;
          frame.set(name, funcId);

          if (frame.parent) {
            this._emitLine("frame.set(\"" + name + "\", " + funcId + ");");
          } else {
            if (node.name.value.charAt(0) !== '_') {
              this._emitLine("context.addExport(\"" + name + "\");");
            }

            this._emitLine("context.setVariable(\"" + name + "\", " + funcId + ");");
          }
        };

        _proto.compileCaller = function compileCaller(node, frame) {
          // basically an anonymous "macro expression"
          this._emit('(function (){');

          var funcId = this._compileMacro(node, frame);

          this._emit("return " + funcId + ";})()");
        };

        _proto._compileGetTemplate = function _compileGetTemplate(node, frame, eagerCompile, ignoreMissing) {
          var parentTemplateId = this._tmpid();

          var parentName = this._templateName();

          var cb = this._makeCallback(parentTemplateId);

          var eagerCompileArg = eagerCompile ? 'true' : 'false';
          var ignoreMissingArg = ignoreMissing ? 'true' : 'false';

          this._emit('env.getTemplate(');

          this._compileExpression(node.template, frame);

          this._emitLine(", " + eagerCompileArg + ", " + parentName + ", " + ignoreMissingArg + ", " + cb);

          return parentTemplateId;
        };

        _proto.compileImport = function compileImport(node, frame) {
          var target = node.target.value;

          var id = this._compileGetTemplate(node, frame, false, false);

          this._addScopeLevel();

          this._emitLine(id + '.getExported(' + (node.withContext ? 'context.getVariables(), frame, ' : '') + this._makeCallback(id));

          this._addScopeLevel();

          frame.set(target, id);

          if (frame.parent) {
            this._emitLine("frame.set(\"" + target + "\", " + id + ");");
          } else {
            this._emitLine("context.setVariable(\"" + target + "\", " + id + ");");
          }
        };

        _proto.compileFromImport = function compileFromImport(node, frame) {
          var _this13 = this;

          var importedId = this._compileGetTemplate(node, frame, false, false);

          this._addScopeLevel();

          this._emitLine(importedId + '.getExported(' + (node.withContext ? 'context.getVariables(), frame, ' : '') + this._makeCallback(importedId));

          this._addScopeLevel();

          node.names.children.forEach(function (nameNode) {
            var name;
            var alias;

            var id = _this13._tmpid();

            if (nameNode instanceof nodes.Pair) {
              name = nameNode.key.value;
              alias = nameNode.value.value;
            } else {
              name = nameNode.value;
              alias = name;
            }

            _this13._emitLine("if(Object.prototype.hasOwnProperty.call(" + importedId + ", \"" + name + "\")) {");

            _this13._emitLine("var " + id + " = " + importedId + "." + name + ";");

            _this13._emitLine('} else {');

            _this13._emitLine("cb(new Error(\"cannot import '" + name + "'\")); return;");

            _this13._emitLine('}');

            frame.set(alias, id);

            if (frame.parent) {
              _this13._emitLine("frame.set(\"" + alias + "\", " + id + ");");
            } else {
              _this13._emitLine("context.setVariable(\"" + alias + "\", " + id + ");");
            }
          });
        };

        _proto.compileBlock = function compileBlock(node) {
          var id = this._tmpid(); // If we are executing outside a block (creating a top-level
          // block), we really don't want to execute its code because it
          // will execute twice: once when the child template runs and
          // again when the parent template runs. Note that blocks
          // within blocks will *always* execute immediately *and*
          // wherever else they are invoked (like used in a parent
          // template). This may have behavioral differences from jinja
          // because blocks can have side effects, but it seems like a
          // waste of performance to always execute huge top-level
          // blocks twice


          if (!this.inBlock) {
            this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
          }

          this._emit("context.getBlock(\"" + node.name.value + "\")");

          if (!this.inBlock) {
            this._emit(')');
          }

          this._emitLine('(env, context, frame, runtime, ' + this._makeCallback(id));

          this._emitLine(this.buffer + " += " + id + ";");

          this._addScopeLevel();
        };

        _proto.compileSuper = function compileSuper(node, frame) {
          var name = node.blockName.value;
          var id = node.symbol.value;

          var cb = this._makeCallback(id);

          this._emitLine("context.getSuper(env, \"" + name + "\", b_" + name + ", frame, runtime, " + cb);

          this._emitLine(id + " = runtime.markSafe(" + id + ");");

          this._addScopeLevel();

          frame.set(id, id);
        };

        _proto.compileExtends = function compileExtends(node, frame) {
          var k = this._tmpid();

          var parentTemplateId = this._compileGetTemplate(node, frame, true, false); // extends is a dynamic tag and can occur within a block like
          // `if`, so if this happens we need to capture the parent
          // template in the top-level scope


          this._emitLine("parentTemplate = " + parentTemplateId);

          this._emitLine("for(var " + k + " in parentTemplate.blocks) {");

          this._emitLine("context.addBlock(" + k + ", parentTemplate.blocks[" + k + "]);");

          this._emitLine('}');

          this._addScopeLevel();
        };

        _proto.compileInclude = function compileInclude(node, frame) {
          this._emitLine('var tasks = [];');

          this._emitLine('tasks.push(');

          this._emitLine('function(callback) {');

          var id = this._compileGetTemplate(node, frame, false, node.ignoreMissing);

          this._emitLine("callback(null," + id + ");});");

          this._emitLine('});');

          var id2 = this._tmpid();

          this._emitLine('tasks.push(');

          this._emitLine('function(template, callback){');

          this._emitLine('template.render(context.getVariables(), frame, ' + this._makeCallback(id2));

          this._emitLine('callback(null,' + id2 + ');});');

          this._emitLine('});');

          this._emitLine('tasks.push(');

          this._emitLine('function(result, callback){');

          this._emitLine(this.buffer + " += result;");

          this._emitLine('callback(null);');

          this._emitLine('});');

          this._emitLine('env.waterfall(tasks, function(){');

          this._addScopeLevel();
        };

        _proto.compileTemplateData = function compileTemplateData(node, frame) {
          this.compileLiteral(node, frame);
        };

        _proto.compileCapture = function compileCapture(node, frame) {
          var _this14 = this; // we need to temporarily override the current buffer id as 'output'
          // so the set block writes to the capture output instead of the buffer


          var buffer = this.buffer;
          this.buffer = 'output';

          this._emitLine('(function() {');

          this._emitLine('var output = "";');

          this._withScopedSyntax(function () {
            _this14.compile(node.body, frame);
          });

          this._emitLine('return output;');

          this._emitLine('})()'); // and of course, revert back to the old buffer id


          this.buffer = buffer;
        };

        _proto.compileOutput = function compileOutput(node, frame) {
          var _this15 = this;

          var children = node.children;
          children.forEach(function (child) {
            // TemplateData is a special case because it is never
            // autoescaped, so simply output it for optimization
            if (child instanceof nodes.TemplateData) {
              if (child.value) {
                _this15._emit(_this15.buffer + " += ");

                _this15.compileLiteral(child, frame);

                _this15._emitLine(';');
              }
            } else {
              _this15._emit(_this15.buffer + " += runtime.suppressValue(");

              if (_this15.throwOnUndefined) {
                _this15._emit('runtime.ensureDefined(');
              }

              _this15.compile(child, frame);

              if (_this15.throwOnUndefined) {
                _this15._emit("," + node.lineno + "," + node.colno + ")");
              }

              _this15._emit(', env.opts.autoescape);\n');
            }
          });
        };

        _proto.compileRoot = function compileRoot(node, frame) {
          var _this16 = this;

          if (frame) {
            this.fail('compileRoot: root node can\'t have frame');
          }

          frame = new Frame();

          this._emitFuncBegin(node, 'root');

          this._emitLine('var parentTemplate = null;');

          this._compileChildren(node, frame);

          this._emitLine('if(parentTemplate) {');

          this._emitLine('parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);');

          this._emitLine('} else {');

          this._emitLine("cb(null, " + this.buffer + ");");

          this._emitLine('}');

          this._emitFuncEnd(true);

          this.inBlock = true;
          var blockNames = [];
          var blocks = node.findAll(nodes.Block);
          blocks.forEach(function (block, i) {
            var name = block.name.value;

            if (blockNames.indexOf(name) !== -1) {
              throw new Error("Block \"" + name + "\" defined more than once.");
            }

            blockNames.push(name);

            _this16._emitFuncBegin(block, "b_" + name);

            var tmpFrame = new Frame();

            _this16._emitLine('var frame = frame.push(true);');

            _this16.compile(block.body, tmpFrame);

            _this16._emitFuncEnd();
          });

          this._emitLine('return {');

          blocks.forEach(function (block, i) {
            var blockName = "b_" + block.name.value;

            _this16._emitLine(blockName + ": " + blockName + ",");
          });

          this._emitLine('root: root\n};');
        };

        _proto.compile = function compile(node, frame) {
          var _compile = this['compile' + node.typename];

          if (_compile) {
            _compile.call(this, node, frame);
          } else {
            this.fail("compile: Cannot compile node: " + node.typename, node.lineno, node.colno);
          }
        };

        _proto.getCode = function getCode() {
          return this.codebuf.join('');
        };

        return Compiler;
      }(Obj);

      module.exports = {
        compile: function compile(src, asyncFilters, extensions, name, opts) {
          if (opts === void 0) {
            opts = {};
          }

          var c = new Compiler(name, opts.throwOnUndefined); // Run the extension preprocessors against the source.

          var preprocessors = (extensions || []).map(function (ext) {
            return ext.preprocess;
          }).filter(function (f) {
            return !!f;
          });
          var processedSrc = preprocessors.reduce(function (s, processor) {
            return processor(s);
          }, src);
          c.compile(transformer.transform(parser.parse(processedSrc, extensions, opts), asyncFilters, name));
          return c.getCode();
        },
        Compiler: Compiler
      };
      /***/
    },
    /* 6 */

    /***/
    function (module, exports, __nested_webpack_require_84615__) {
      "use strict";

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var path = __nested_webpack_require_84615__(4);

      var _require = __nested_webpack_require_84615__(1),
          EmitterObj = _require.EmitterObj;

      module.exports = /*#__PURE__*/function (_EmitterObj) {
        _inheritsLoose(Loader, _EmitterObj);

        function Loader() {
          return _EmitterObj.apply(this, arguments) || this;
        }

        var _proto = Loader.prototype;

        _proto.resolve = function resolve(from, to) {
          return path.resolve(path.dirname(from), to);
        };

        _proto.isRelative = function isRelative(filename) {
          return filename.indexOf('./') === 0 || filename.indexOf('../') === 0;
        };

        return Loader;
      }(EmitterObj);
      /***/

    },
    /* 7 */

    /***/
    function (module, exports, __nested_webpack_require_85650__) {
      "use strict";

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var asap = __nested_webpack_require_85650__(12);

      var _waterfall = __nested_webpack_require_85650__(15);

      var lib = __nested_webpack_require_85650__(0);

      var compiler = __nested_webpack_require_85650__(5);

      var filters = __nested_webpack_require_85650__(18);

      var _require = __nested_webpack_require_85650__(10),
          FileSystemLoader = _require.FileSystemLoader,
          WebLoader = _require.WebLoader,
          PrecompiledLoader = _require.PrecompiledLoader;

      var tests = __nested_webpack_require_85650__(20);

      var globals = __nested_webpack_require_85650__(21);

      var _require2 = __nested_webpack_require_85650__(1),
          Obj = _require2.Obj,
          EmitterObj = _require2.EmitterObj;

      var globalRuntime = __nested_webpack_require_85650__(2);

      var handleError = globalRuntime.handleError,
          Frame = globalRuntime.Frame;

      var expressApp = __nested_webpack_require_85650__(22); // If the user is using the async API, *always* call it
      // asynchronously even if the template was synchronous.


      function callbackAsap(cb, err, res) {
        asap(function () {
          cb(err, res);
        });
      }
      /**
       * A no-op template, for use with {% include ignore missing %}
       */


      var noopTmplSrc = {
        type: 'code',
        obj: {
          root: function root(env, context, frame, runtime, cb) {
            try {
              cb(null, '');
            } catch (e) {
              cb(handleError(e, null, null));
            }
          }
        }
      };

      var Environment = /*#__PURE__*/function (_EmitterObj) {
        _inheritsLoose(Environment, _EmitterObj);

        function Environment() {
          return _EmitterObj.apply(this, arguments) || this;
        }

        var _proto = Environment.prototype;

        _proto.init = function init(loaders, opts) {
          var _this = this; // The dev flag determines the trace that'll be shown on errors.
          // If set to true, returns the full trace from the error point,
          // otherwise will return trace starting from Template.render
          // (the full trace from within nunjucks may confuse developers using
          //  the library)
          // defaults to false


          opts = this.opts = opts || {};
          this.opts.dev = !!opts.dev; // The autoescape flag sets global autoescaping. If true,
          // every string variable will be escaped by default.
          // If false, strings can be manually escaped using the `escape` filter.
          // defaults to true

          this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true; // If true, this will make the system throw errors if trying
          // to output a null or undefined value

          this.opts.throwOnUndefined = !!opts.throwOnUndefined;
          this.opts.trimBlocks = !!opts.trimBlocks;
          this.opts.lstripBlocks = !!opts.lstripBlocks;
          this.loaders = [];

          if (!loaders) {
            // The filesystem loader is only available server-side
            if (FileSystemLoader) {
              this.loaders = [new FileSystemLoader('views')];
            } else if (WebLoader) {
              this.loaders = [new WebLoader('/views')];
            }
          } else {
            this.loaders = lib.isArray(loaders) ? loaders : [loaders];
          } // It's easy to use precompiled templates: just include them
          // before you configure nunjucks and this will automatically
          // pick it up and use it


          if (typeof window !== 'undefined' && window.nunjucksPrecompiled) {
            this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
          }

          this._initLoaders();

          this.globals = globals();
          this.filters = {};
          this.tests = {};
          this.asyncFilters = [];
          this.extensions = {};
          this.extensionsList = [];

          lib._entries(filters).forEach(function (_ref) {
            var name = _ref[0],
                filter = _ref[1];
            return _this.addFilter(name, filter);
          });

          lib._entries(tests).forEach(function (_ref2) {
            var name = _ref2[0],
                test = _ref2[1];
            return _this.addTest(name, test);
          });
        };

        _proto._initLoaders = function _initLoaders() {
          var _this2 = this;

          this.loaders.forEach(function (loader) {
            // Caching and cache busting
            loader.cache = {};

            if (typeof loader.on === 'function') {
              loader.on('update', function (name, fullname) {
                loader.cache[name] = null;

                _this2.emit('update', name, fullname, loader);
              });
              loader.on('load', function (name, source) {
                _this2.emit('load', name, source, loader);
              });
            }
          });
        };

        _proto.invalidateCache = function invalidateCache() {
          this.loaders.forEach(function (loader) {
            loader.cache = {};
          });
        };

        _proto.addExtension = function addExtension(name, extension) {
          extension.__name = name;
          this.extensions[name] = extension;
          this.extensionsList.push(extension);
          return this;
        };

        _proto.removeExtension = function removeExtension(name) {
          var extension = this.getExtension(name);

          if (!extension) {
            return;
          }

          this.extensionsList = lib.without(this.extensionsList, extension);
          delete this.extensions[name];
        };

        _proto.getExtension = function getExtension(name) {
          return this.extensions[name];
        };

        _proto.hasExtension = function hasExtension(name) {
          return !!this.extensions[name];
        };

        _proto.addGlobal = function addGlobal(name, value) {
          this.globals[name] = value;
          return this;
        };

        _proto.getGlobal = function getGlobal(name) {
          if (typeof this.globals[name] === 'undefined') {
            throw new Error('global not found: ' + name);
          }

          return this.globals[name];
        };

        _proto.addFilter = function addFilter(name, func, async) {
          var wrapped = func;

          if (async) {
            this.asyncFilters.push(name);
          }

          this.filters[name] = wrapped;
          return this;
        };

        _proto.getFilter = function getFilter(name) {
          if (!this.filters[name]) {
            throw new Error('filter not found: ' + name);
          }

          return this.filters[name];
        };

        _proto.addTest = function addTest(name, func) {
          this.tests[name] = func;
          return this;
        };

        _proto.getTest = function getTest(name) {
          if (!this.tests[name]) {
            throw new Error('test not found: ' + name);
          }

          return this.tests[name];
        };

        _proto.resolveTemplate = function resolveTemplate(loader, parentName, filename) {
          var isRelative = loader.isRelative && parentName ? loader.isRelative(filename) : false;
          return isRelative && loader.resolve ? loader.resolve(parentName, filename) : filename;
        };

        _proto.getTemplate = function getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
          var _this3 = this;

          var that = this;
          var tmpl = null;

          if (name && name.raw) {
            // this fixes autoescape for templates referenced in symbols
            name = name.raw;
          }

          if (lib.isFunction(parentName)) {
            cb = parentName;
            parentName = null;
            eagerCompile = eagerCompile || false;
          }

          if (lib.isFunction(eagerCompile)) {
            cb = eagerCompile;
            eagerCompile = false;
          }

          if (name instanceof Template) {
            tmpl = name;
          } else if (typeof name !== 'string') {
            throw new Error('template names must be a string: ' + name);
          } else {
            for (var i = 0; i < this.loaders.length; i++) {
              var loader = this.loaders[i];
              tmpl = loader.cache[this.resolveTemplate(loader, parentName, name)];

              if (tmpl) {
                break;
              }
            }
          }

          if (tmpl) {
            if (eagerCompile) {
              tmpl.compile();
            }

            if (cb) {
              cb(null, tmpl);
              return undefined;
            } else {
              return tmpl;
            }
          }

          var syncResult;

          var createTemplate = function createTemplate(err, info) {
            if (!info && !err && !ignoreMissing) {
              err = new Error('template not found: ' + name);
            }

            if (err) {
              if (cb) {
                cb(err);
                return;
              } else {
                throw err;
              }
            }

            var newTmpl;

            if (!info) {
              newTmpl = new Template(noopTmplSrc, _this3, '', eagerCompile);
            } else {
              newTmpl = new Template(info.src, _this3, info.path, eagerCompile);

              if (!info.noCache) {
                info.loader.cache[name] = newTmpl;
              }
            }

            if (cb) {
              cb(null, newTmpl);
            } else {
              syncResult = newTmpl;
            }
          };

          lib.asyncIter(this.loaders, function (loader, i, next, done) {
            function handle(err, src) {
              if (err) {
                done(err);
              } else if (src) {
                src.loader = loader;
                done(null, src);
              } else {
                next();
              }
            } // Resolve name relative to parentName


            name = that.resolveTemplate(loader, parentName, name);

            if (loader.async) {
              loader.getSource(name, handle);
            } else {
              handle(null, loader.getSource(name));
            }
          }, createTemplate);
          return syncResult;
        };

        _proto.express = function express(app) {
          return expressApp(this, app);
        };

        _proto.render = function render(name, ctx, cb) {
          if (lib.isFunction(ctx)) {
            cb = ctx;
            ctx = null;
          } // We support a synchronous API to make it easier to migrate
          // existing code to async. This works because if you don't do
          // anything async work, the whole thing is actually run
          // synchronously.


          var syncResult = null;
          this.getTemplate(name, function (err, tmpl) {
            if (err && cb) {
              callbackAsap(cb, err);
            } else if (err) {
              throw err;
            } else {
              syncResult = tmpl.render(ctx, cb);
            }
          });
          return syncResult;
        };

        _proto.renderString = function renderString(src, ctx, opts, cb) {
          if (lib.isFunction(opts)) {
            cb = opts;
            opts = {};
          }

          opts = opts || {};
          var tmpl = new Template(src, this, opts.path);
          return tmpl.render(ctx, cb);
        };

        _proto.waterfall = function waterfall(tasks, callback, forceAsync) {
          return _waterfall(tasks, callback, forceAsync);
        };

        return Environment;
      }(EmitterObj);

      var Context = /*#__PURE__*/function (_Obj) {
        _inheritsLoose(Context, _Obj);

        function Context() {
          return _Obj.apply(this, arguments) || this;
        }

        var _proto2 = Context.prototype;

        _proto2.init = function init(ctx, blocks, env) {
          var _this4 = this; // Has to be tied to an environment so we can tap into its globals.


          this.env = env || new Environment(); // Make a duplicate of ctx

          this.ctx = lib.extend({}, ctx);
          this.blocks = {};
          this.exported = [];
          lib.keys(blocks).forEach(function (name) {
            _this4.addBlock(name, blocks[name]);
          });
        };

        _proto2.lookup = function lookup(name) {
          // This is one of the most called functions, so optimize for
          // the typical case where the name isn't in the globals
          if (name in this.env.globals && !(name in this.ctx)) {
            return this.env.globals[name];
          } else {
            return this.ctx[name];
          }
        };

        _proto2.setVariable = function setVariable(name, val) {
          this.ctx[name] = val;
        };

        _proto2.getVariables = function getVariables() {
          return this.ctx;
        };

        _proto2.addBlock = function addBlock(name, block) {
          this.blocks[name] = this.blocks[name] || [];
          this.blocks[name].push(block);
          return this;
        };

        _proto2.getBlock = function getBlock(name) {
          if (!this.blocks[name]) {
            throw new Error('unknown block "' + name + '"');
          }

          return this.blocks[name][0];
        };

        _proto2.getSuper = function getSuper(env, name, block, frame, runtime, cb) {
          var idx = lib.indexOf(this.blocks[name] || [], block);
          var blk = this.blocks[name][idx + 1];
          var context = this;

          if (idx === -1 || !blk) {
            throw new Error('no super block available for "' + name + '"');
          }

          blk(env, context, frame, runtime, cb);
        };

        _proto2.addExport = function addExport(name) {
          this.exported.push(name);
        };

        _proto2.getExported = function getExported() {
          var _this5 = this;

          var exported = {};
          this.exported.forEach(function (name) {
            exported[name] = _this5.ctx[name];
          });
          return exported;
        };

        return Context;
      }(Obj);

      var Template = /*#__PURE__*/function (_Obj2) {
        _inheritsLoose(Template, _Obj2);

        function Template() {
          return _Obj2.apply(this, arguments) || this;
        }

        var _proto3 = Template.prototype;

        _proto3.init = function init(src, env, path, eagerCompile) {
          this.env = env || new Environment();

          if (lib.isObject(src)) {
            switch (src.type) {
              case 'code':
                this.tmplProps = src.obj;
                break;

              case 'string':
                this.tmplStr = src.obj;
                break;

              default:
                throw new Error("Unexpected template object type " + src.type + "; expected 'code', or 'string'");
            }
          } else if (lib.isString(src)) {
            this.tmplStr = src;
          } else {
            throw new Error('src must be a string or an object describing the source');
          }

          this.path = path;

          if (eagerCompile) {
            try {
              this._compile();
            } catch (err) {
              throw lib._prettifyError(this.path, this.env.opts.dev, err);
            }
          } else {
            this.compiled = false;
          }
        };

        _proto3.render = function render(ctx, parentFrame, cb) {
          var _this6 = this;

          if (typeof ctx === 'function') {
            cb = ctx;
            ctx = {};
          } else if (typeof parentFrame === 'function') {
            cb = parentFrame;
            parentFrame = null;
          } // If there is a parent frame, we are being called from internal
          // code of another template, and the internal system
          // depends on the sync/async nature of the parent template
          // to be inherited, so force an async callback


          var forceAsync = !parentFrame; // Catch compile errors for async rendering

          try {
            this.compile();
          } catch (e) {
            var err = lib._prettifyError(this.path, this.env.opts.dev, e);

            if (cb) {
              return callbackAsap(cb, err);
            } else {
              throw err;
            }
          }

          var context = new Context(ctx || {}, this.blocks, this.env);
          var frame = parentFrame ? parentFrame.push(true) : new Frame();
          frame.topLevel = true;
          var syncResult = null;
          var didError = false;
          this.rootRenderFunc(this.env, context, frame, globalRuntime, function (err, res) {
            // TODO: this is actually a bug in the compiled template (because waterfall
            // tasks are both not passing errors up the chain of callbacks AND are not
            // causing a return from the top-most render function). But fixing that
            // will require a more substantial change to the compiler.
            if (didError && cb && typeof res !== 'undefined') {
              // prevent multiple calls to cb
              return;
            }

            if (err) {
              err = lib._prettifyError(_this6.path, _this6.env.opts.dev, err);
              didError = true;
            }

            if (cb) {
              if (forceAsync) {
                callbackAsap(cb, err, res);
              } else {
                cb(err, res);
              }
            } else {
              if (err) {
                throw err;
              }

              syncResult = res;
            }
          });
          return syncResult;
        };

        _proto3.getExported = function getExported(ctx, parentFrame, cb) {
          // eslint-disable-line consistent-return
          if (typeof ctx === 'function') {
            cb = ctx;
            ctx = {};
          }

          if (typeof parentFrame === 'function') {
            cb = parentFrame;
            parentFrame = null;
          } // Catch compile errors for async rendering


          try {
            this.compile();
          } catch (e) {
            if (cb) {
              return cb(e);
            } else {
              throw e;
            }
          }

          var frame = parentFrame ? parentFrame.push() : new Frame();
          frame.topLevel = true; // Run the rootRenderFunc to populate the context with exported vars

          var context = new Context(ctx || {}, this.blocks, this.env);
          this.rootRenderFunc(this.env, context, frame, globalRuntime, function (err) {
            if (err) {
              cb(err, null);
            } else {
              cb(null, context.getExported());
            }
          });
        };

        _proto3.compile = function compile() {
          if (!this.compiled) {
            this._compile();
          }
        };

        _proto3._compile = function _compile() {
          var props;

          if (this.tmplProps) {
            props = this.tmplProps;
          } else {
            var source = compiler.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
            var func = new Function(source); // eslint-disable-line no-new-func

            props = func();
          }

          this.blocks = this._getBlocks(props);
          this.rootRenderFunc = props.root;
          this.compiled = true;
        };

        _proto3._getBlocks = function _getBlocks(props) {
          var blocks = {};
          lib.keys(props).forEach(function (k) {
            if (k.slice(0, 2) === 'b_') {
              blocks[k.slice(2)] = props[k];
            }
          });
          return blocks;
        };

        return Template;
      }(Obj);

      module.exports = {
        Environment: Environment,
        Template: Template
      };
      /***/
    },
    /* 8 */

    /***/
    function (module, exports, __nested_webpack_require_105671__) {
      "use strict";

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var lexer = __nested_webpack_require_105671__(9);

      var nodes = __nested_webpack_require_105671__(3);

      var Obj = __nested_webpack_require_105671__(1).Obj;

      var lib = __nested_webpack_require_105671__(0);

      var Parser = /*#__PURE__*/function (_Obj) {
        _inheritsLoose(Parser, _Obj);

        function Parser() {
          return _Obj.apply(this, arguments) || this;
        }

        var _proto = Parser.prototype;

        _proto.init = function init(tokens) {
          this.tokens = tokens;
          this.peeked = null;
          this.breakOnBlocks = null;
          this.dropLeadingWhitespace = false;
          this.extensions = [];
        };

        _proto.nextToken = function nextToken(withWhitespace) {
          var tok;

          if (this.peeked) {
            if (!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
              this.peeked = null;
            } else {
              tok = this.peeked;
              this.peeked = null;
              return tok;
            }
          }

          tok = this.tokens.nextToken();

          if (!withWhitespace) {
            while (tok && tok.type === lexer.TOKEN_WHITESPACE) {
              tok = this.tokens.nextToken();
            }
          }

          return tok;
        };

        _proto.peekToken = function peekToken() {
          this.peeked = this.peeked || this.nextToken();
          return this.peeked;
        };

        _proto.pushToken = function pushToken(tok) {
          if (this.peeked) {
            throw new Error('pushToken: can only push one token on between reads');
          }

          this.peeked = tok;
        };

        _proto.error = function error(msg, lineno, colno) {
          if (lineno === undefined || colno === undefined) {
            var tok = this.peekToken() || {};
            lineno = tok.lineno;
            colno = tok.colno;
          }

          if (lineno !== undefined) {
            lineno += 1;
          }

          if (colno !== undefined) {
            colno += 1;
          }

          return new lib.TemplateError(msg, lineno, colno);
        };

        _proto.fail = function fail(msg, lineno, colno) {
          throw this.error(msg, lineno, colno);
        };

        _proto.skip = function skip(type) {
          var tok = this.nextToken();

          if (!tok || tok.type !== type) {
            this.pushToken(tok);
            return false;
          }

          return true;
        };

        _proto.expect = function expect(type) {
          var tok = this.nextToken();

          if (tok.type !== type) {
            this.fail('expected ' + type + ', got ' + tok.type, tok.lineno, tok.colno);
          }

          return tok;
        };

        _proto.skipValue = function skipValue(type, val) {
          var tok = this.nextToken();

          if (!tok || tok.type !== type || tok.value !== val) {
            this.pushToken(tok);
            return false;
          }

          return true;
        };

        _proto.skipSymbol = function skipSymbol(val) {
          return this.skipValue(lexer.TOKEN_SYMBOL, val);
        };

        _proto.advanceAfterBlockEnd = function advanceAfterBlockEnd(name) {
          var tok;

          if (!name) {
            tok = this.peekToken();

            if (!tok) {
              this.fail('unexpected end of file');
            }

            if (tok.type !== lexer.TOKEN_SYMBOL) {
              this.fail('advanceAfterBlockEnd: expected symbol token or ' + 'explicit name to be passed');
            }

            name = this.nextToken().value;
          }

          tok = this.nextToken();

          if (tok && tok.type === lexer.TOKEN_BLOCK_END) {
            if (tok.value.charAt(0) === '-') {
              this.dropLeadingWhitespace = true;
            }
          } else {
            this.fail('expected block end in ' + name + ' statement');
          }

          return tok;
        };

        _proto.advanceAfterVariableEnd = function advanceAfterVariableEnd() {
          var tok = this.nextToken();

          if (tok && tok.type === lexer.TOKEN_VARIABLE_END) {
            this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === '-';
          } else {
            this.pushToken(tok);
            this.fail('expected variable end');
          }
        };

        _proto.parseFor = function parseFor() {
          var forTok = this.peekToken();
          var node;
          var endBlock;

          if (this.skipSymbol('for')) {
            node = new nodes.For(forTok.lineno, forTok.colno);
            endBlock = 'endfor';
          } else if (this.skipSymbol('asyncEach')) {
            node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
            endBlock = 'endeach';
          } else if (this.skipSymbol('asyncAll')) {
            node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
            endBlock = 'endall';
          } else {
            this.fail('parseFor: expected for{Async}', forTok.lineno, forTok.colno);
          }

          node.name = this.parsePrimary();

          if (!(node.name instanceof nodes.Symbol)) {
            this.fail('parseFor: variable name expected for loop');
          }

          var type = this.peekToken().type;

          if (type === lexer.TOKEN_COMMA) {
            // key/value iteration
            var key = node.name;
            node.name = new nodes.Array(key.lineno, key.colno);
            node.name.addChild(key);

            while (this.skip(lexer.TOKEN_COMMA)) {
              var prim = this.parsePrimary();
              node.name.addChild(prim);
            }
          }

          if (!this.skipSymbol('in')) {
            this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
          }

          node.arr = this.parseExpression();
          this.advanceAfterBlockEnd(forTok.value);
          node.body = this.parseUntilBlocks(endBlock, 'else');

          if (this.skipSymbol('else')) {
            this.advanceAfterBlockEnd('else');
            node.else_ = this.parseUntilBlocks(endBlock);
          }

          this.advanceAfterBlockEnd();
          return node;
        };

        _proto.parseMacro = function parseMacro() {
          var macroTok = this.peekToken();

          if (!this.skipSymbol('macro')) {
            this.fail('expected macro');
          }

          var name = this.parsePrimary(true);
          var args = this.parseSignature();
          var node = new nodes.Macro(macroTok.lineno, macroTok.colno, name, args);
          this.advanceAfterBlockEnd(macroTok.value);
          node.body = this.parseUntilBlocks('endmacro');
          this.advanceAfterBlockEnd();
          return node;
        };

        _proto.parseCall = function parseCall() {
          // a call block is parsed as a normal FunCall, but with an added
          // 'caller' kwarg which is a Caller node.
          var callTok = this.peekToken();

          if (!this.skipSymbol('call')) {
            this.fail('expected call');
          }

          var callerArgs = this.parseSignature(true) || new nodes.NodeList();
          var macroCall = this.parsePrimary();
          this.advanceAfterBlockEnd(callTok.value);
          var body = this.parseUntilBlocks('endcall');
          this.advanceAfterBlockEnd();
          var callerName = new nodes.Symbol(callTok.lineno, callTok.colno, 'caller');
          var callerNode = new nodes.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body); // add the additional caller kwarg, adding kwargs if necessary

          var args = macroCall.args.children;

          if (!(args[args.length - 1] instanceof nodes.KeywordArgs)) {
            args.push(new nodes.KeywordArgs());
          }

          var kwargs = args[args.length - 1];
          kwargs.addChild(new nodes.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
          return new nodes.Output(callTok.lineno, callTok.colno, [macroCall]);
        };

        _proto.parseWithContext = function parseWithContext() {
          var tok = this.peekToken();
          var withContext = null;

          if (this.skipSymbol('with')) {
            withContext = true;
          } else if (this.skipSymbol('without')) {
            withContext = false;
          }

          if (withContext !== null) {
            if (!this.skipSymbol('context')) {
              this.fail('parseFrom: expected context after with/without', tok.lineno, tok.colno);
            }
          }

          return withContext;
        };

        _proto.parseImport = function parseImport() {
          var importTok = this.peekToken();

          if (!this.skipSymbol('import')) {
            this.fail('parseImport: expected import', importTok.lineno, importTok.colno);
          }

          var template = this.parseExpression();

          if (!this.skipSymbol('as')) {
            this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
          }

          var target = this.parseExpression();
          var withContext = this.parseWithContext();
          var node = new nodes.Import(importTok.lineno, importTok.colno, template, target, withContext);
          this.advanceAfterBlockEnd(importTok.value);
          return node;
        };

        _proto.parseFrom = function parseFrom() {
          var fromTok = this.peekToken();

          if (!this.skipSymbol('from')) {
            this.fail('parseFrom: expected from');
          }

          var template = this.parseExpression();

          if (!this.skipSymbol('import')) {
            this.fail('parseFrom: expected import', fromTok.lineno, fromTok.colno);
          }

          var names = new nodes.NodeList();
          var withContext;

          while (1) {
            // eslint-disable-line no-constant-condition
            var nextTok = this.peekToken();

            if (nextTok.type === lexer.TOKEN_BLOCK_END) {
              if (!names.children.length) {
                this.fail('parseFrom: Expected at least one import name', fromTok.lineno, fromTok.colno);
              } // Since we are manually advancing past the block end,
              // need to keep track of whitespace control (normally
              // this is done in `advanceAfterBlockEnd`


              if (nextTok.value.charAt(0) === '-') {
                this.dropLeadingWhitespace = true;
              }

              this.nextToken();
              break;
            }

            if (names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
              this.fail('parseFrom: expected comma', fromTok.lineno, fromTok.colno);
            }

            var name = this.parsePrimary();

            if (name.value.charAt(0) === '_') {
              this.fail('parseFrom: names starting with an underscore cannot be imported', name.lineno, name.colno);
            }

            if (this.skipSymbol('as')) {
              var alias = this.parsePrimary();
              names.addChild(new nodes.Pair(name.lineno, name.colno, name, alias));
            } else {
              names.addChild(name);
            }

            withContext = this.parseWithContext();
          }

          return new nodes.FromImport(fromTok.lineno, fromTok.colno, template, names, withContext);
        };

        _proto.parseBlock = function parseBlock() {
          var tag = this.peekToken();

          if (!this.skipSymbol('block')) {
            this.fail('parseBlock: expected block', tag.lineno, tag.colno);
          }

          var node = new nodes.Block(tag.lineno, tag.colno);
          node.name = this.parsePrimary();

          if (!(node.name instanceof nodes.Symbol)) {
            this.fail('parseBlock: variable name expected', tag.lineno, tag.colno);
          }

          this.advanceAfterBlockEnd(tag.value);
          node.body = this.parseUntilBlocks('endblock');
          this.skipSymbol('endblock');
          this.skipSymbol(node.name.value);
          var tok = this.peekToken();

          if (!tok) {
            this.fail('parseBlock: expected endblock, got end of file');
          }

          this.advanceAfterBlockEnd(tok.value);
          return node;
        };

        _proto.parseExtends = function parseExtends() {
          var tagName = 'extends';
          var tag = this.peekToken();

          if (!this.skipSymbol(tagName)) {
            this.fail('parseTemplateRef: expected ' + tagName);
          }

          var node = new nodes.Extends(tag.lineno, tag.colno);
          node.template = this.parseExpression();
          this.advanceAfterBlockEnd(tag.value);
          return node;
        };

        _proto.parseInclude = function parseInclude() {
          var tagName = 'include';
          var tag = this.peekToken();

          if (!this.skipSymbol(tagName)) {
            this.fail('parseInclude: expected ' + tagName);
          }

          var node = new nodes.Include(tag.lineno, tag.colno);
          node.template = this.parseExpression();

          if (this.skipSymbol('ignore') && this.skipSymbol('missing')) {
            node.ignoreMissing = true;
          }

          this.advanceAfterBlockEnd(tag.value);
          return node;
        };

        _proto.parseIf = function parseIf() {
          var tag = this.peekToken();
          var node;

          if (this.skipSymbol('if') || this.skipSymbol('elif') || this.skipSymbol('elseif')) {
            node = new nodes.If(tag.lineno, tag.colno);
          } else if (this.skipSymbol('ifAsync')) {
            node = new nodes.IfAsync(tag.lineno, tag.colno);
          } else {
            this.fail('parseIf: expected if, elif, or elseif', tag.lineno, tag.colno);
          }

          node.cond = this.parseExpression();
          this.advanceAfterBlockEnd(tag.value);
          node.body = this.parseUntilBlocks('elif', 'elseif', 'else', 'endif');
          var tok = this.peekToken();

          switch (tok && tok.value) {
            case 'elseif':
            case 'elif':
              node.else_ = this.parseIf();
              break;

            case 'else':
              this.advanceAfterBlockEnd();
              node.else_ = this.parseUntilBlocks('endif');
              this.advanceAfterBlockEnd();
              break;

            case 'endif':
              node.else_ = null;
              this.advanceAfterBlockEnd();
              break;

            default:
              this.fail('parseIf: expected elif, else, or endif, got end of file');
          }

          return node;
        };

        _proto.parseSet = function parseSet() {
          var tag = this.peekToken();

          if (!this.skipSymbol('set')) {
            this.fail('parseSet: expected set', tag.lineno, tag.colno);
          }

          var node = new nodes.Set(tag.lineno, tag.colno, []);
          var target;

          while (target = this.parsePrimary()) {
            node.targets.push(target);

            if (!this.skip(lexer.TOKEN_COMMA)) {
              break;
            }
          }

          if (!this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
            if (!this.skip(lexer.TOKEN_BLOCK_END)) {
              this.fail('parseSet: expected = or block end in set tag', tag.lineno, tag.colno);
            } else {
              node.body = new nodes.Capture(tag.lineno, tag.colno, this.parseUntilBlocks('endset'));
              node.value = null;
              this.advanceAfterBlockEnd();
            }
          } else {
            node.value = this.parseExpression();
            this.advanceAfterBlockEnd(tag.value);
          }

          return node;
        };

        _proto.parseSwitch = function parseSwitch() {
          /*
           * Store the tag names in variables in case someone ever wants to
           * customize this.
           */
          var switchStart = 'switch';
          var switchEnd = 'endswitch';
          var caseStart = 'case';
          var caseDefault = 'default'; // Get the switch tag.

          var tag = this.peekToken(); // fail early if we get some unexpected tag.

          if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
            this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
          } // parse the switch expression


          var expr = this.parseExpression(); // advance until a start of a case, a default case or an endswitch.

          this.advanceAfterBlockEnd(switchStart);
          this.parseUntilBlocks(caseStart, caseDefault, switchEnd); // this is the first case. it could also be an endswitch, we'll check.

          var tok = this.peekToken(); // create new variables for our cases and default case.

          var cases = [];
          var defaultCase; // while we're dealing with new cases nodes...

          do {
            // skip the start symbol and get the case expression
            this.skipSymbol(caseStart);
            var cond = this.parseExpression();
            this.advanceAfterBlockEnd(switchStart); // get the body of the case node and add it to the array of cases.

            var body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
            cases.push(new nodes.Case(tok.line, tok.col, cond, body)); // get our next case

            tok = this.peekToken();
          } while (tok && tok.value === caseStart); // we either have a default case or a switch end.


          switch (tok.value) {
            case caseDefault:
              this.advanceAfterBlockEnd();
              defaultCase = this.parseUntilBlocks(switchEnd);
              this.advanceAfterBlockEnd();
              break;

            case switchEnd:
              this.advanceAfterBlockEnd();
              break;

            default:
              // otherwise bail because EOF
              this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
          } // and return the switch node.


          return new nodes.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
        };

        _proto.parseStatement = function parseStatement() {
          var tok = this.peekToken();
          var node;

          if (tok.type !== lexer.TOKEN_SYMBOL) {
            this.fail('tag name expected', tok.lineno, tok.colno);
          }

          if (this.breakOnBlocks && lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
            return null;
          }

          switch (tok.value) {
            case 'raw':
              return this.parseRaw();

            case 'verbatim':
              return this.parseRaw('verbatim');

            case 'if':
            case 'ifAsync':
              return this.parseIf();

            case 'for':
            case 'asyncEach':
            case 'asyncAll':
              return this.parseFor();

            case 'block':
              return this.parseBlock();

            case 'extends':
              return this.parseExtends();

            case 'include':
              return this.parseInclude();

            case 'set':
              return this.parseSet();

            case 'macro':
              return this.parseMacro();

            case 'call':
              return this.parseCall();

            case 'import':
              return this.parseImport();

            case 'from':
              return this.parseFrom();

            case 'filter':
              return this.parseFilterStatement();

            case 'switch':
              return this.parseSwitch();

            default:
              if (this.extensions.length) {
                for (var i = 0; i < this.extensions.length; i++) {
                  var ext = this.extensions[i];

                  if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
                    return ext.parse(this, nodes, lexer);
                  }
                }
              }

              this.fail('unknown block tag: ' + tok.value, tok.lineno, tok.colno);
          }

          return node;
        };

        _proto.parseRaw = function parseRaw(tagName) {
          tagName = tagName || 'raw';
          var endTagName = 'end' + tagName; // Look for upcoming raw blocks (ignore all other kinds of blocks)

          var rawBlockRegex = new RegExp('([\\s\\S]*?){%\\s*(' + tagName + '|' + endTagName + ')\\s*(?=%})%}');
          var rawLevel = 1;
          var str = '';
          var matches = null; // Skip opening raw token
          // Keep this token to track line and column numbers

          var begun = this.advanceAfterBlockEnd(); // Exit when there's nothing to match
          // or when we've found the matching "endraw" block

          while ((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
            var all = matches[0];
            var pre = matches[1];
            var blockName = matches[2]; // Adjust rawlevel

            if (blockName === tagName) {
              rawLevel += 1;
            } else if (blockName === endTagName) {
              rawLevel -= 1;
            } // Add to str


            if (rawLevel === 0) {
              // We want to exclude the last "endraw"
              str += pre; // Move tokenizer to beginning of endraw block

              this.tokens.backN(all.length - pre.length);
            } else {
              str += all;
            }
          }

          return new nodes.Output(begun.lineno, begun.colno, [new nodes.TemplateData(begun.lineno, begun.colno, str)]);
        };

        _proto.parsePostfix = function parsePostfix(node) {
          var lookup;
          var tok = this.peekToken();

          while (tok) {
            if (tok.type === lexer.TOKEN_LEFT_PAREN) {
              // Function call
              node = new nodes.FunCall(tok.lineno, tok.colno, node, this.parseSignature());
            } else if (tok.type === lexer.TOKEN_LEFT_BRACKET) {
              // Reference
              lookup = this.parseAggregate();

              if (lookup.children.length > 1) {
                this.fail('invalid index');
              }

              node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup.children[0]);
            } else if (tok.type === lexer.TOKEN_OPERATOR && tok.value === '.') {
              // Reference
              this.nextToken();
              var val = this.nextToken();

              if (val.type !== lexer.TOKEN_SYMBOL) {
                this.fail('expected name as lookup value, got ' + val.value, val.lineno, val.colno);
              } // Make a literal string because it's not a variable
              // reference


              lookup = new nodes.Literal(val.lineno, val.colno, val.value);
              node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup);
            } else {
              break;
            }

            tok = this.peekToken();
          }

          return node;
        };

        _proto.parseExpression = function parseExpression() {
          var node = this.parseInlineIf();
          return node;
        };

        _proto.parseInlineIf = function parseInlineIf() {
          var node = this.parseOr();

          if (this.skipSymbol('if')) {
            var condNode = this.parseOr();
            var bodyNode = node;
            node = new nodes.InlineIf(node.lineno, node.colno);
            node.body = bodyNode;
            node.cond = condNode;

            if (this.skipSymbol('else')) {
              node.else_ = this.parseOr();
            } else {
              node.else_ = null;
            }
          }

          return node;
        };

        _proto.parseOr = function parseOr() {
          var node = this.parseAnd();

          while (this.skipSymbol('or')) {
            var node2 = this.parseAnd();
            node = new nodes.Or(node.lineno, node.colno, node, node2);
          }

          return node;
        };

        _proto.parseAnd = function parseAnd() {
          var node = this.parseNot();

          while (this.skipSymbol('and')) {
            var node2 = this.parseNot();
            node = new nodes.And(node.lineno, node.colno, node, node2);
          }

          return node;
        };

        _proto.parseNot = function parseNot() {
          var tok = this.peekToken();

          if (this.skipSymbol('not')) {
            return new nodes.Not(tok.lineno, tok.colno, this.parseNot());
          }

          return this.parseIn();
        };

        _proto.parseIn = function parseIn() {
          var node = this.parseIs();

          while (1) {
            // eslint-disable-line no-constant-condition
            // check if the next token is 'not'
            var tok = this.nextToken();

            if (!tok) {
              break;
            }

            var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === 'not'; // if it wasn't 'not', put it back

            if (!invert) {
              this.pushToken(tok);
            }

            if (this.skipSymbol('in')) {
              var node2 = this.parseIs();
              node = new nodes.In(node.lineno, node.colno, node, node2);

              if (invert) {
                node = new nodes.Not(node.lineno, node.colno, node);
              }
            } else {
              // if we'd found a 'not' but this wasn't an 'in', put back the 'not'
              if (invert) {
                this.pushToken(tok);
              }

              break;
            }
          }

          return node;
        } // I put this right after "in" in the operator precedence stack. That can
        // obviously be changed to be closer to Jinja.
        ;

        _proto.parseIs = function parseIs() {
          var node = this.parseCompare(); // look for an is

          if (this.skipSymbol('is')) {
            // look for a not
            var not = this.skipSymbol('not'); // get the next node

            var node2 = this.parseCompare(); // create an Is node using the next node and the info from our Is node.

            node = new nodes.Is(node.lineno, node.colno, node, node2); // if we have a Not, create a Not node from our Is node.

            if (not) {
              node = new nodes.Not(node.lineno, node.colno, node);
            }
          } // return the node.


          return node;
        };

        _proto.parseCompare = function parseCompare() {
          var compareOps = ['==', '===', '!=', '!==', '<', '>', '<=', '>='];
          var expr = this.parseConcat();
          var ops = [];

          while (1) {
            // eslint-disable-line no-constant-condition
            var tok = this.nextToken();

            if (!tok) {
              break;
            } else if (compareOps.indexOf(tok.value) !== -1) {
              ops.push(new nodes.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
            } else {
              this.pushToken(tok);
              break;
            }
          }

          if (ops.length) {
            return new nodes.Compare(ops[0].lineno, ops[0].colno, expr, ops);
          } else {
            return expr;
          }
        } // finds the '~' for string concatenation
        ;

        _proto.parseConcat = function parseConcat() {
          var node = this.parseAdd();

          while (this.skipValue(lexer.TOKEN_TILDE, '~')) {
            var node2 = this.parseAdd();
            node = new nodes.Concat(node.lineno, node.colno, node, node2);
          }

          return node;
        };

        _proto.parseAdd = function parseAdd() {
          var node = this.parseSub();

          while (this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
            var node2 = this.parseSub();
            node = new nodes.Add(node.lineno, node.colno, node, node2);
          }

          return node;
        };

        _proto.parseSub = function parseSub() {
          var node = this.parseMul();

          while (this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
            var node2 = this.parseMul();
            node = new nodes.Sub(node.lineno, node.colno, node, node2);
          }

          return node;
        };

        _proto.parseMul = function parseMul() {
          var node = this.parseDiv();

          while (this.skipValue(lexer.TOKEN_OPERATOR, '*')) {
            var node2 = this.parseDiv();
            node = new nodes.Mul(node.lineno, node.colno, node, node2);
          }

          return node;
        };

        _proto.parseDiv = function parseDiv() {
          var node = this.parseFloorDiv();

          while (this.skipValue(lexer.TOKEN_OPERATOR, '/')) {
            var node2 = this.parseFloorDiv();
            node = new nodes.Div(node.lineno, node.colno, node, node2);
          }

          return node;
        };

        _proto.parseFloorDiv = function parseFloorDiv() {
          var node = this.parseMod();

          while (this.skipValue(lexer.TOKEN_OPERATOR, '//')) {
            var node2 = this.parseMod();
            node = new nodes.FloorDiv(node.lineno, node.colno, node, node2);
          }

          return node;
        };

        _proto.parseMod = function parseMod() {
          var node = this.parsePow();

          while (this.skipValue(lexer.TOKEN_OPERATOR, '%')) {
            var node2 = this.parsePow();
            node = new nodes.Mod(node.lineno, node.colno, node, node2);
          }

          return node;
        };

        _proto.parsePow = function parsePow() {
          var node = this.parseUnary();

          while (this.skipValue(lexer.TOKEN_OPERATOR, '**')) {
            var node2 = this.parseUnary();
            node = new nodes.Pow(node.lineno, node.colno, node, node2);
          }

          return node;
        };

        _proto.parseUnary = function parseUnary(noFilters) {
          var tok = this.peekToken();
          var node;

          if (this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
            node = new nodes.Neg(tok.lineno, tok.colno, this.parseUnary(true));
          } else if (this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
            node = new nodes.Pos(tok.lineno, tok.colno, this.parseUnary(true));
          } else {
            node = this.parsePrimary();
          }

          if (!noFilters) {
            node = this.parseFilter(node);
          }

          return node;
        };

        _proto.parsePrimary = function parsePrimary(noPostfix) {
          var tok = this.nextToken();
          var val;
          var node = null;

          if (!tok) {
            this.fail('expected expression, got end of file');
          } else if (tok.type === lexer.TOKEN_STRING) {
            val = tok.value;
          } else if (tok.type === lexer.TOKEN_INT) {
            val = parseInt(tok.value, 10);
          } else if (tok.type === lexer.TOKEN_FLOAT) {
            val = parseFloat(tok.value);
          } else if (tok.type === lexer.TOKEN_BOOLEAN) {
            if (tok.value === 'true') {
              val = true;
            } else if (tok.value === 'false') {
              val = false;
            } else {
              this.fail('invalid boolean: ' + tok.value, tok.lineno, tok.colno);
            }
          } else if (tok.type === lexer.TOKEN_NONE) {
            val = null;
          } else if (tok.type === lexer.TOKEN_REGEX) {
            val = new RegExp(tok.value.body, tok.value.flags);
          }

          if (val !== undefined) {
            node = new nodes.Literal(tok.lineno, tok.colno, val);
          } else if (tok.type === lexer.TOKEN_SYMBOL) {
            node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
          } else {
            // See if it's an aggregate type, we need to push the
            // current delimiter token back on
            this.pushToken(tok);
            node = this.parseAggregate();
          }

          if (!noPostfix) {
            node = this.parsePostfix(node);
          }

          if (node) {
            return node;
          } else {
            throw this.error("unexpected token: " + tok.value, tok.lineno, tok.colno);
          }
        };

        _proto.parseFilterName = function parseFilterName() {
          var tok = this.expect(lexer.TOKEN_SYMBOL);
          var name = tok.value;

          while (this.skipValue(lexer.TOKEN_OPERATOR, '.')) {
            name += '.' + this.expect(lexer.TOKEN_SYMBOL).value;
          }

          return new nodes.Symbol(tok.lineno, tok.colno, name);
        };

        _proto.parseFilterArgs = function parseFilterArgs(node) {
          if (this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
            // Get a FunCall node and add the parameters to the
            // filter
            var call = this.parsePostfix(node);
            return call.args.children;
          }

          return [];
        };

        _proto.parseFilter = function parseFilter(node) {
          while (this.skip(lexer.TOKEN_PIPE)) {
            var name = this.parseFilterName();
            node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [node].concat(this.parseFilterArgs(node))));
          }

          return node;
        };

        _proto.parseFilterStatement = function parseFilterStatement() {
          var filterTok = this.peekToken();

          if (!this.skipSymbol('filter')) {
            this.fail('parseFilterStatement: expected filter');
          }

          var name = this.parseFilterName();
          var args = this.parseFilterArgs(name);
          this.advanceAfterBlockEnd(filterTok.value);
          var body = new nodes.Capture(name.lineno, name.colno, this.parseUntilBlocks('endfilter'));
          this.advanceAfterBlockEnd();
          var node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [body].concat(args)));
          return new nodes.Output(name.lineno, name.colno, [node]);
        };

        _proto.parseAggregate = function parseAggregate() {
          var tok = this.nextToken();
          var node;

          switch (tok.type) {
            case lexer.TOKEN_LEFT_PAREN:
              node = new nodes.Group(tok.lineno, tok.colno);
              break;

            case lexer.TOKEN_LEFT_BRACKET:
              node = new nodes.Array(tok.lineno, tok.colno);
              break;

            case lexer.TOKEN_LEFT_CURLY:
              node = new nodes.Dict(tok.lineno, tok.colno);
              break;

            default:
              return null;
          }

          while (1) {
            // eslint-disable-line no-constant-condition
            var type = this.peekToken().type;

            if (type === lexer.TOKEN_RIGHT_PAREN || type === lexer.TOKEN_RIGHT_BRACKET || type === lexer.TOKEN_RIGHT_CURLY) {
              this.nextToken();
              break;
            }

            if (node.children.length > 0) {
              if (!this.skip(lexer.TOKEN_COMMA)) {
                this.fail('parseAggregate: expected comma after expression', tok.lineno, tok.colno);
              }
            }

            if (node instanceof nodes.Dict) {
              // TODO: check for errors
              var key = this.parsePrimary(); // We expect a key/value pair for dicts, separated by a
              // colon

              if (!this.skip(lexer.TOKEN_COLON)) {
                this.fail('parseAggregate: expected colon after dict key', tok.lineno, tok.colno);
              } // TODO: check for errors


              var value = this.parseExpression();
              node.addChild(new nodes.Pair(key.lineno, key.colno, key, value));
            } else {
              // TODO: check for errors
              var expr = this.parseExpression();
              node.addChild(expr);
            }
          }

          return node;
        };

        _proto.parseSignature = function parseSignature(tolerant, noParens) {
          var tok = this.peekToken();

          if (!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
            if (tolerant) {
              return null;
            } else {
              this.fail('expected arguments', tok.lineno, tok.colno);
            }
          }

          if (tok.type === lexer.TOKEN_LEFT_PAREN) {
            tok = this.nextToken();
          }

          var args = new nodes.NodeList(tok.lineno, tok.colno);
          var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
          var checkComma = false;

          while (1) {
            // eslint-disable-line no-constant-condition
            tok = this.peekToken();

            if (!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
              this.nextToken();
              break;
            } else if (noParens && tok.type === lexer.TOKEN_BLOCK_END) {
              break;
            }

            if (checkComma && !this.skip(lexer.TOKEN_COMMA)) {
              this.fail('parseSignature: expected comma after expression', tok.lineno, tok.colno);
            } else {
              var arg = this.parseExpression();

              if (this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
                kwargs.addChild(new nodes.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
              } else {
                args.addChild(arg);
              }
            }

            checkComma = true;
          }

          if (kwargs.children.length) {
            args.addChild(kwargs);
          }

          return args;
        };

        _proto.parseUntilBlocks = function parseUntilBlocks() {
          var prev = this.breakOnBlocks;

          for (var _len = arguments.length, blockNames = new Array(_len), _key = 0; _key < _len; _key++) {
            blockNames[_key] = arguments[_key];
          }

          this.breakOnBlocks = blockNames;
          var ret = this.parse();
          this.breakOnBlocks = prev;
          return ret;
        };

        _proto.parseNodes = function parseNodes() {
          var tok;
          var buf = [];

          while (tok = this.nextToken()) {
            if (tok.type === lexer.TOKEN_DATA) {
              var data = tok.value;
              var nextToken = this.peekToken();
              var nextVal = nextToken && nextToken.value; // If the last token has "-" we need to trim the
              // leading whitespace of the data. This is marked with
              // the `dropLeadingWhitespace` variable.

              if (this.dropLeadingWhitespace) {
                // TODO: this could be optimized (don't use regex)
                data = data.replace(/^\s*/, '');
                this.dropLeadingWhitespace = false;
              } // Same for the succeeding block start token


              if (nextToken && (nextToken.type === lexer.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === '-' || nextToken.type === lexer.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === '-' || nextToken.type === lexer.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === '-')) {
                // TODO: this could be optimized (don't use regex)
                data = data.replace(/\s*$/, '');
              }

              buf.push(new nodes.Output(tok.lineno, tok.colno, [new nodes.TemplateData(tok.lineno, tok.colno, data)]));
            } else if (tok.type === lexer.TOKEN_BLOCK_START) {
              this.dropLeadingWhitespace = false;
              var n = this.parseStatement();

              if (!n) {
                break;
              }

              buf.push(n);
            } else if (tok.type === lexer.TOKEN_VARIABLE_START) {
              var e = this.parseExpression();
              this.dropLeadingWhitespace = false;
              this.advanceAfterVariableEnd();
              buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));
            } else if (tok.type === lexer.TOKEN_COMMENT) {
              this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === '-';
            } else {
              // Ignore comments, otherwise this should be an error
              this.fail('Unexpected token at top-level: ' + tok.type, tok.lineno, tok.colno);
            }
          }

          return buf;
        };

        _proto.parse = function parse() {
          return new nodes.NodeList(0, 0, this.parseNodes());
        };

        _proto.parseAsRoot = function parseAsRoot() {
          return new nodes.Root(0, 0, this.parseNodes());
        };

        return Parser;
      }(Obj); // var util = require('util');
      // var l = lexer.lex('{%- if x -%}\n hello {% endif %}');
      // var t;
      // while((t = l.nextToken())) {
      //     console.log(util.inspect(t));
      // }
      // var p = new Parser(lexer.lex('hello {% filter title %}' +
      //                              'Hello madam how are you' +
      //                              '{% endfilter %}'));
      // var n = p.parseAsRoot();
      // nodes.printNodes(n);


      module.exports = {
        parse: function parse(src, extensions, opts) {
          var p = new Parser(lexer.lex(src, opts));

          if (extensions !== undefined) {
            p.extensions = extensions;
          }

          return p.parseAsRoot();
        },
        Parser: Parser
      };
      /***/
    },
    /* 9 */

    /***/
    function (module, exports, __nested_webpack_require_147017__) {
      "use strict";

      var lib = __nested_webpack_require_147017__(0);

      var whitespaceChars = " \n\t\r\xA0";
      var delimChars = '()[]{}%*-+~/#,:|.<>=!';
      var intChars = '0123456789';
      var BLOCK_START = '{%';
      var BLOCK_END = '%}';
      var VARIABLE_START = '{{';
      var VARIABLE_END = '}}';
      var COMMENT_START = '{#';
      var COMMENT_END = '#}';
      var TOKEN_STRING = 'string';
      var TOKEN_WHITESPACE = 'whitespace';
      var TOKEN_DATA = 'data';
      var TOKEN_BLOCK_START = 'block-start';
      var TOKEN_BLOCK_END = 'block-end';
      var TOKEN_VARIABLE_START = 'variable-start';
      var TOKEN_VARIABLE_END = 'variable-end';
      var TOKEN_COMMENT = 'comment';
      var TOKEN_LEFT_PAREN = 'left-paren';
      var TOKEN_RIGHT_PAREN = 'right-paren';
      var TOKEN_LEFT_BRACKET = 'left-bracket';
      var TOKEN_RIGHT_BRACKET = 'right-bracket';
      var TOKEN_LEFT_CURLY = 'left-curly';
      var TOKEN_RIGHT_CURLY = 'right-curly';
      var TOKEN_OPERATOR = 'operator';
      var TOKEN_COMMA = 'comma';
      var TOKEN_COLON = 'colon';
      var TOKEN_TILDE = 'tilde';
      var TOKEN_PIPE = 'pipe';
      var TOKEN_INT = 'int';
      var TOKEN_FLOAT = 'float';
      var TOKEN_BOOLEAN = 'boolean';
      var TOKEN_NONE = 'none';
      var TOKEN_SYMBOL = 'symbol';
      var TOKEN_SPECIAL = 'special';
      var TOKEN_REGEX = 'regex';

      function token(type, value, lineno, colno) {
        return {
          type: type,
          value: value,
          lineno: lineno,
          colno: colno
        };
      }

      var Tokenizer = /*#__PURE__*/function () {
        function Tokenizer(str, opts) {
          this.str = str;
          this.index = 0;
          this.len = str.length;
          this.lineno = 0;
          this.colno = 0;
          this.in_code = false;
          opts = opts || {};
          var tags = opts.tags || {};
          this.tags = {
            BLOCK_START: tags.blockStart || BLOCK_START,
            BLOCK_END: tags.blockEnd || BLOCK_END,
            VARIABLE_START: tags.variableStart || VARIABLE_START,
            VARIABLE_END: tags.variableEnd || VARIABLE_END,
            COMMENT_START: tags.commentStart || COMMENT_START,
            COMMENT_END: tags.commentEnd || COMMENT_END
          };
          this.trimBlocks = !!opts.trimBlocks;
          this.lstripBlocks = !!opts.lstripBlocks;
        }

        var _proto = Tokenizer.prototype;

        _proto.nextToken = function nextToken() {
          var lineno = this.lineno;
          var colno = this.colno;
          var tok;

          if (this.in_code) {
            // Otherwise, if we are in a block parse it as code
            var cur = this.current();

            if (this.isFinished()) {
              // We have nothing else to parse
              return null;
            } else if (cur === '"' || cur === '\'') {
              // We've hit a string
              return token(TOKEN_STRING, this._parseString(cur), lineno, colno);
            } else if (tok = this._extract(whitespaceChars)) {
              // We hit some whitespace
              return token(TOKEN_WHITESPACE, tok, lineno, colno);
            } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString('-' + this.tags.BLOCK_END))) {
              // Special check for the block end tag
              //
              // It is a requirement that start and end tags are composed of
              // delimiter characters (%{}[] etc), and our code always
              // breaks on delimiters so we can assume the token parsing
              // doesn't consume these elsewhere
              this.in_code = false;

              if (this.trimBlocks) {
                cur = this.current();

                if (cur === '\n') {
                  // Skip newline
                  this.forward();
                } else if (cur === '\r') {
                  // Skip CRLF newline
                  this.forward();
                  cur = this.current();

                  if (cur === '\n') {
                    this.forward();
                  } else {
                    // Was not a CRLF, so go back
                    this.back();
                  }
                }
              }

              return token(TOKEN_BLOCK_END, tok, lineno, colno);
            } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString('-' + this.tags.VARIABLE_END))) {
              // Special check for variable end tag (see above)
              this.in_code = false;
              return token(TOKEN_VARIABLE_END, tok, lineno, colno);
            } else if (cur === 'r' && this.str.charAt(this.index + 1) === '/') {
              // Skip past 'r/'.
              this.forwardN(2); // Extract until the end of the regex -- / ends it, \/ does not.

              var regexBody = '';

              while (!this.isFinished()) {
                if (this.current() === '/' && this.previous() !== '\\') {
                  this.forward();
                  break;
                } else {
                  regexBody += this.current();
                  this.forward();
                }
              } // Check for flags.
              // The possible flags are according to https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp)


              var POSSIBLE_FLAGS = ['g', 'i', 'm', 'y'];
              var regexFlags = '';

              while (!this.isFinished()) {
                var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;

                if (isCurrentAFlag) {
                  regexFlags += this.current();
                  this.forward();
                } else {
                  break;
                }
              }

              return token(TOKEN_REGEX, {
                body: regexBody,
                flags: regexFlags
              }, lineno, colno);
            } else if (delimChars.indexOf(cur) !== -1) {
              // We've hit a delimiter (a special char like a bracket)
              this.forward();
              var complexOps = ['==', '===', '!=', '!==', '<=', '>=', '//', '**'];
              var curComplex = cur + this.current();
              var type;

              if (lib.indexOf(complexOps, curComplex) !== -1) {
                this.forward();
                cur = curComplex; // See if this is a strict equality/inequality comparator

                if (lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
                  cur = curComplex + this.current();
                  this.forward();
                }
              }

              switch (cur) {
                case '(':
                  type = TOKEN_LEFT_PAREN;
                  break;

                case ')':
                  type = TOKEN_RIGHT_PAREN;
                  break;

                case '[':
                  type = TOKEN_LEFT_BRACKET;
                  break;

                case ']':
                  type = TOKEN_RIGHT_BRACKET;
                  break;

                case '{':
                  type = TOKEN_LEFT_CURLY;
                  break;

                case '}':
                  type = TOKEN_RIGHT_CURLY;
                  break;

                case ',':
                  type = TOKEN_COMMA;
                  break;

                case ':':
                  type = TOKEN_COLON;
                  break;

                case '~':
                  type = TOKEN_TILDE;
                  break;

                case '|':
                  type = TOKEN_PIPE;
                  break;

                default:
                  type = TOKEN_OPERATOR;
              }

              return token(type, cur, lineno, colno);
            } else {
              // We are not at whitespace or a delimiter, so extract the
              // text and parse it
              tok = this._extractUntil(whitespaceChars + delimChars);

              if (tok.match(/^[-+]?[0-9]+$/)) {
                if (this.current() === '.') {
                  this.forward();

                  var dec = this._extract(intChars);

                  return token(TOKEN_FLOAT, tok + '.' + dec, lineno, colno);
                } else {
                  return token(TOKEN_INT, tok, lineno, colno);
                }
              } else if (tok.match(/^(true|false)$/)) {
                return token(TOKEN_BOOLEAN, tok, lineno, colno);
              } else if (tok === 'none') {
                return token(TOKEN_NONE, tok, lineno, colno);
                /*
                 * Added to make the test `null is null` evaluate truthily.
                 * Otherwise, Nunjucks will look up null in the context and
                 * return `undefined`, which is not what we want. This *may* have
                 * consequences is someone is using null in their templates as a
                 * variable.
                 */
              } else if (tok === 'null') {
                return token(TOKEN_NONE, tok, lineno, colno);
              } else if (tok) {
                return token(TOKEN_SYMBOL, tok, lineno, colno);
              } else {
                throw new Error('Unexpected value while parsing: ' + tok);
              }
            }
          } else {
            // Parse out the template text, breaking on tag
            // delimiters because we need to look for block/variable start
            // tags (don't use the full delimChars for optimization)
            var beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);

            if (this.isFinished()) {
              return null;
            } else if ((tok = this._extractString(this.tags.BLOCK_START + '-')) || (tok = this._extractString(this.tags.BLOCK_START))) {
              this.in_code = true;
              return token(TOKEN_BLOCK_START, tok, lineno, colno);
            } else if ((tok = this._extractString(this.tags.VARIABLE_START + '-')) || (tok = this._extractString(this.tags.VARIABLE_START))) {
              this.in_code = true;
              return token(TOKEN_VARIABLE_START, tok, lineno, colno);
            } else {
              tok = '';
              var data;
              var inComment = false;

              if (this._matches(this.tags.COMMENT_START)) {
                inComment = true;
                tok = this._extractString(this.tags.COMMENT_START);
              } // Continually consume text, breaking on the tag delimiter
              // characters and checking to see if it's a start tag.
              //
              // We could hit the end of the template in the middle of
              // our looping, so check for the null return value from
              // _extractUntil


              while ((data = this._extractUntil(beginChars)) !== null) {
                tok += data;

                if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
                  if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
                    var lastLine = tok.slice(-this.colno);

                    if (/^\s+$/.test(lastLine)) {
                      // Remove block leading whitespace from beginning of the string
                      tok = tok.slice(0, -this.colno);

                      if (!tok.length) {
                        // All data removed, collapse to avoid unnecessary nodes
                        // by returning next token (block start)
                        return this.nextToken();
                      }
                    }
                  } // If it is a start tag, stop looping


                  break;
                } else if (this._matches(this.tags.COMMENT_END)) {
                  if (!inComment) {
                    throw new Error('unexpected end of comment');
                  }

                  tok += this._extractString(this.tags.COMMENT_END);
                  break;
                } else {
                  // It does not match any tag, so add the character and
                  // carry on
                  tok += this.current();
                  this.forward();
                }
              }

              if (data === null && inComment) {
                throw new Error('expected end of comment, got end of file');
              }

              return token(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
            }
          }
        };

        _proto._parseString = function _parseString(delimiter) {
          this.forward();
          var str = '';

          while (!this.isFinished() && this.current() !== delimiter) {
            var cur = this.current();

            if (cur === '\\') {
              this.forward();

              switch (this.current()) {
                case 'n':
                  str += '\n';
                  break;

                case 't':
                  str += '\t';
                  break;

                case 'r':
                  str += '\r';
                  break;

                default:
                  str += this.current();
              }

              this.forward();
            } else {
              str += cur;
              this.forward();
            }
          }

          this.forward();
          return str;
        };

        _proto._matches = function _matches(str) {
          if (this.index + str.length > this.len) {
            return null;
          }

          var m = this.str.slice(this.index, this.index + str.length);
          return m === str;
        };

        _proto._extractString = function _extractString(str) {
          if (this._matches(str)) {
            this.forwardN(str.length);
            return str;
          }

          return null;
        };

        _proto._extractUntil = function _extractUntil(charString) {
          // Extract all non-matching chars, with the default matching set
          // to everything
          return this._extractMatching(true, charString || '');
        };

        _proto._extract = function _extract(charString) {
          // Extract all matching chars (no default, so charString must be
          // explicit)
          return this._extractMatching(false, charString);
        };

        _proto._extractMatching = function _extractMatching(breakOnMatch, charString) {
          // Pull out characters until a breaking char is hit.
          // If breakOnMatch is false, a non-matching char stops it.
          // If breakOnMatch is true, a matching char stops it.
          if (this.isFinished()) {
            return null;
          }

          var first = charString.indexOf(this.current()); // Only proceed if the first character doesn't meet our condition

          if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
            var t = this.current();
            this.forward(); // And pull out all the chars one at a time until we hit a
            // breaking char

            var idx = charString.indexOf(this.current());

            while ((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()) {
              t += this.current();
              this.forward();
              idx = charString.indexOf(this.current());
            }

            return t;
          }

          return '';
        };

        _proto._extractRegex = function _extractRegex(regex) {
          var matches = this.currentStr().match(regex);

          if (!matches) {
            return null;
          } // Move forward whatever was matched


          this.forwardN(matches[0].length);
          return matches;
        };

        _proto.isFinished = function isFinished() {
          return this.index >= this.len;
        };

        _proto.forwardN = function forwardN(n) {
          for (var i = 0; i < n; i++) {
            this.forward();
          }
        };

        _proto.forward = function forward() {
          this.index++;

          if (this.previous() === '\n') {
            this.lineno++;
            this.colno = 0;
          } else {
            this.colno++;
          }
        };

        _proto.backN = function backN(n) {
          for (var i = 0; i < n; i++) {
            this.back();
          }
        };

        _proto.back = function back() {
          this.index--;

          if (this.current() === '\n') {
            this.lineno--;
            var idx = this.src.lastIndexOf('\n', this.index - 1);

            if (idx === -1) {
              this.colno = this.index;
            } else {
              this.colno = this.index - idx;
            }
          } else {
            this.colno--;
          }
        } // current returns current character
        ;

        _proto.current = function current() {
          if (!this.isFinished()) {
            return this.str.charAt(this.index);
          }

          return '';
        } // currentStr returns what's left of the unparsed string
        ;

        _proto.currentStr = function currentStr() {
          if (!this.isFinished()) {
            return this.str.substr(this.index);
          }

          return '';
        };

        _proto.previous = function previous() {
          return this.str.charAt(this.index - 1);
        };

        return Tokenizer;
      }();

      module.exports = {
        lex: function lex(src, opts) {
          return new Tokenizer(src, opts);
        },
        TOKEN_STRING: TOKEN_STRING,
        TOKEN_WHITESPACE: TOKEN_WHITESPACE,
        TOKEN_DATA: TOKEN_DATA,
        TOKEN_BLOCK_START: TOKEN_BLOCK_START,
        TOKEN_BLOCK_END: TOKEN_BLOCK_END,
        TOKEN_VARIABLE_START: TOKEN_VARIABLE_START,
        TOKEN_VARIABLE_END: TOKEN_VARIABLE_END,
        TOKEN_COMMENT: TOKEN_COMMENT,
        TOKEN_LEFT_PAREN: TOKEN_LEFT_PAREN,
        TOKEN_RIGHT_PAREN: TOKEN_RIGHT_PAREN,
        TOKEN_LEFT_BRACKET: TOKEN_LEFT_BRACKET,
        TOKEN_RIGHT_BRACKET: TOKEN_RIGHT_BRACKET,
        TOKEN_LEFT_CURLY: TOKEN_LEFT_CURLY,
        TOKEN_RIGHT_CURLY: TOKEN_RIGHT_CURLY,
        TOKEN_OPERATOR: TOKEN_OPERATOR,
        TOKEN_COMMA: TOKEN_COMMA,
        TOKEN_COLON: TOKEN_COLON,
        TOKEN_TILDE: TOKEN_TILDE,
        TOKEN_PIPE: TOKEN_PIPE,
        TOKEN_INT: TOKEN_INT,
        TOKEN_FLOAT: TOKEN_FLOAT,
        TOKEN_BOOLEAN: TOKEN_BOOLEAN,
        TOKEN_NONE: TOKEN_NONE,
        TOKEN_SYMBOL: TOKEN_SYMBOL,
        TOKEN_SPECIAL: TOKEN_SPECIAL,
        TOKEN_REGEX: TOKEN_REGEX
      };
      /***/
    },
    /* 10 */

    /***/
    function (module, exports, __nested_webpack_require_165671__) {
      "use strict";

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Loader = __nested_webpack_require_165671__(6);

      var _require = __nested_webpack_require_165671__(19),
          PrecompiledLoader = _require.PrecompiledLoader;

      var WebLoader = /*#__PURE__*/function (_Loader) {
        _inheritsLoose(WebLoader, _Loader);

        function WebLoader(baseURL, opts) {
          var _this;

          _this = _Loader.call(this) || this;
          _this.baseURL = baseURL || '.';
          opts = opts || {}; // By default, the cache is turned off because there's no way
          // to "watch" templates over HTTP, so they are re-downloaded
          // and compiled each time. (Remember, PRECOMPILE YOUR
          // TEMPLATES in production!)

          _this.useCache = !!opts.useCache; // We default `async` to false so that the simple synchronous
          // API can be used when you aren't doing anything async in
          // your templates (which is most of the time). This performs a
          // sync ajax request, but that's ok because it should *only*
          // happen in development. PRECOMPILE YOUR TEMPLATES.

          _this.async = !!opts.async;
          return _this;
        }

        var _proto = WebLoader.prototype;

        _proto.resolve = function resolve(from, to) {
          throw new Error('relative templates not support in the browser yet');
        };

        _proto.getSource = function getSource(name, cb) {
          var _this2 = this;

          var useCache = this.useCache;
          var result;
          this.fetch(this.baseURL + '/' + name, function (err, src) {
            if (err) {
              if (cb) {
                cb(err.content);
              } else if (err.status === 404) {
                result = null;
              } else {
                throw err.content;
              }
            } else {
              result = {
                src: src,
                path: name,
                noCache: !useCache
              };

              _this2.emit('load', name, result);

              if (cb) {
                cb(null, result);
              }
            }
          }); // if this WebLoader isn't running asynchronously, the
          // fetch above would actually run sync and we'll have a
          // result here

          return result;
        };

        _proto.fetch = function fetch(url, cb) {
          // Only in the browser please
          if (typeof window === 'undefined') {
            throw new Error('WebLoader can only by used in a browser');
          }

          var ajax = new XMLHttpRequest();
          var loading = true;

          ajax.onreadystatechange = function () {
            if (ajax.readyState === 4 && loading) {
              loading = false;

              if (ajax.status === 0 || ajax.status === 200) {
                cb(null, ajax.responseText);
              } else {
                cb({
                  status: ajax.status,
                  content: ajax.responseText
                });
              }
            }
          };

          url += (url.indexOf('?') === -1 ? '?' : '&') + 's=' + new Date().getTime();
          ajax.open('GET', url, this.async);
          ajax.send();
        };

        return WebLoader;
      }(Loader);

      module.exports = {
        WebLoader: WebLoader,
        PrecompiledLoader: PrecompiledLoader
      };
      /***/
    },
    /* 11 */

    /***/
    function (module, exports, __nested_webpack_require_169313__) {
      "use strict";

      var lib = __nested_webpack_require_169313__(0);

      var _require = __nested_webpack_require_169313__(7),
          Environment = _require.Environment,
          Template = _require.Template;

      var Loader = __nested_webpack_require_169313__(6);

      var loaders = __nested_webpack_require_169313__(10);

      var precompile = __nested_webpack_require_169313__(23);

      var compiler = __nested_webpack_require_169313__(5);

      var parser = __nested_webpack_require_169313__(8);

      var lexer = __nested_webpack_require_169313__(9);

      var runtime = __nested_webpack_require_169313__(2);

      var nodes = __nested_webpack_require_169313__(3);

      var installJinjaCompat = __nested_webpack_require_169313__(25); // A single instance of an environment, since this is so commonly used


      var e;

      function configure(templatesPath, opts) {
        opts = opts || {};

        if (lib.isObject(templatesPath)) {
          opts = templatesPath;
          templatesPath = null;
        }

        var TemplateLoader;

        if (loaders.FileSystemLoader) {
          TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
            watch: opts.watch,
            noCache: opts.noCache
          });
        } else if (loaders.WebLoader) {
          TemplateLoader = new loaders.WebLoader(templatesPath, {
            useCache: opts.web && opts.web.useCache,
            async: opts.web && opts.web.async
          });
        }

        e = new Environment(TemplateLoader, opts);

        if (opts && opts.express) {
          e.express(opts.express);
        }

        return e;
      }

      module.exports = {
        Environment: Environment,
        Template: Template,
        Loader: Loader,
        FileSystemLoader: loaders.FileSystemLoader,
        NodeResolveLoader: loaders.NodeResolveLoader,
        PrecompiledLoader: loaders.PrecompiledLoader,
        WebLoader: loaders.WebLoader,
        compiler: compiler,
        parser: parser,
        lexer: lexer,
        runtime: runtime,
        lib: lib,
        nodes: nodes,
        installJinjaCompat: installJinjaCompat,
        configure: configure,
        reset: function reset() {
          e = undefined;
        },
        compile: function compile(src, env, path, eagerCompile) {
          if (!e) {
            configure();
          }

          return new Template(src, env, path, eagerCompile);
        },
        render: function render(name, ctx, cb) {
          if (!e) {
            configure();
          }

          return e.render(name, ctx, cb);
        },
        renderString: function renderString(src, ctx, cb) {
          if (!e) {
            configure();
          }

          return e.renderString(src, ctx, cb);
        },
        precompile: precompile ? precompile.precompile : undefined,
        precompileString: precompile ? precompile.precompileString : undefined
      };
      /***/
    },
    /* 12 */

    /***/
    function (module, exports, __nested_webpack_require_172198__) {
      "use strict"; // rawAsap provides everything we need except exception management.

      var rawAsap = __nested_webpack_require_172198__(13); // RawTasks are recycled to reduce GC churn.


      var freeTasks = []; // We queue errors to ensure they are thrown in right order (FIFO).
      // Array-as-queue is good enough here, since we are just dealing with exceptions.

      var pendingErrors = [];
      var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

      function throwFirstError() {
        if (pendingErrors.length) {
          throw pendingErrors.shift();
        }
      }
      /**
       * Calls a task as soon as possible after returning, in its own event, with priority
       * over other events like animation, reflow, and repaint. An error thrown from an
       * event will not interrupt, nor even substantially slow down the processing of
       * other events, but will be rather postponed to a lower priority event.
       * @param {{call}} task A callable object, typically a function that takes no
       * arguments.
       */


      module.exports = asap;

      function asap(task) {
        var rawTask;

        if (freeTasks.length) {
          rawTask = freeTasks.pop();
        } else {
          rawTask = new RawTask();
        }

        rawTask.task = task;
        rawAsap(rawTask);
      } // We wrap tasks with recyclable task objects.  A task object implements
      // `call`, just like a function.


      function RawTask() {
        this.task = null;
      } // The sole purpose of wrapping the task is to catch the exception and recycle
      // the task object after its single use.


      RawTask.prototype.call = function () {
        try {
          this.task.call();
        } catch (error) {
          if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
          } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
          }
        } finally {
          this.task = null;
          freeTasks[freeTasks.length] = this;
        }
      };
      /***/

    },
    /* 13 */

    /***/
    function (module, exports, __nested_webpack_require_174716__) {
      "use strict";
      /* WEBPACK VAR INJECTION */

      (function (global) {
        // Use the fastest means possible to execute a task in its own turn, with
        // priority over other events including IO, animation, reflow, and redraw
        // events in browsers.
        //
        // An exception thrown by a task will permanently interrupt the processing of
        // subsequent tasks. The higher level `asap` function ensures that if an
        // exception is thrown by a task, that the task queue will continue flushing as
        // soon as possible, but if you use `rawAsap` directly, you are responsible to
        // either ensure that no exceptions are thrown from your task, or to manually
        // call `rawAsap.requestFlush` if an exception is thrown.
        module.exports = rawAsap;

        function rawAsap(task) {
          if (!queue.length) {
            requestFlush();
            flushing = true;
          } // Equivalent to push, but avoids a function call.


          queue[queue.length] = task;
        }

        var queue = []; // Once a flush has been requested, no further calls to `requestFlush` are
        // necessary until the next `flush` completes.

        var flushing = false; // `requestFlush` is an implementation-specific method that attempts to kick
        // off a `flush` event as quickly as possible. `flush` will attempt to exhaust
        // the event queue before yielding to the browser's own event loop.

        var requestFlush; // The position of the next task to execute in the task queue. This is
        // preserved between calls to `flush` so that it can be resumed if
        // a task throws an exception.

        var index = 0; // If a task schedules additional tasks recursively, the task queue can grow
        // unbounded. To prevent memory exhaustion, the task queue will periodically
        // truncate already-completed tasks.

        var capacity = 1024; // The flush function processes all tasks that have been scheduled with
        // `rawAsap` unless and until one of those tasks throws an exception.
        // If a task throws an exception, `flush` ensures that its state will remain
        // consistent and will resume where it left off when called again.
        // However, `flush` does not make any arrangements to be called again if an
        // exception is thrown.

        function flush() {
          while (index < queue.length) {
            var currentIndex = index; // Advance the index before calling the task. This ensures that we will
            // begin flushing on the next task the task throws an error.

            index = index + 1;
            queue[currentIndex].call(); // Prevent leaking memory for long chains of recursive calls to `asap`.
            // If we call `asap` within tasks scheduled by `asap`, the queue will
            // grow, but to avoid an O(n) walk for every task we execute, we don't
            // shift tasks off the queue after they have been executed.
            // Instead, we periodically shift 1024 tasks off the queue.

            if (index > capacity) {
              // Manually shift all values starting at the index back to the
              // beginning of the queue.
              for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
              }

              queue.length -= index;
              index = 0;
            }
          }

          queue.length = 0;
          index = 0;
          flushing = false;
        } // `requestFlush` is implemented using a strategy based on data collected from
        // every available SauceLabs Selenium web driver worker at time of writing.
        // https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593
        // Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
        // have WebKitMutationObserver but not un-prefixed MutationObserver.
        // Must use `global` or `self` instead of `window` to work in both frames and web
        // workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.

        /* globals self */


        var scope = typeof global !== "undefined" ? global : self;
        var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver; // MutationObservers are desirable because they have high priority and work
        // reliably everywhere they are implemented.
        // They are implemented in all modern browsers.
        //
        // - Android 4-4.3
        // - Chrome 26-34
        // - Firefox 14-29
        // - Internet Explorer 11
        // - iPad Safari 6-7.1
        // - iPhone Safari 7-7.1
        // - Safari 6-7

        if (typeof BrowserMutationObserver === "function") {
          requestFlush = makeRequestCallFromMutationObserver(flush); // MessageChannels are desirable because they give direct access to the HTML
          // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
          // 11-12, and in web workers in many engines.
          // Although message channels yield to any queued rendering and IO tasks, they
          // would be better than imposing the 4ms delay of timers.
          // However, they do not work reliably in Internet Explorer or Safari.
          // Internet Explorer 10 is the only browser that has setImmediate but does
          // not have MutationObservers.
          // Although setImmediate yields to the browser's renderer, it would be
          // preferrable to falling back to setTimeout since it does not have
          // the minimum 4ms penalty.
          // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
          // Desktop to a lesser extent) that renders both setImmediate and
          // MessageChannel useless for the purposes of ASAP.
          // https://github.com/kriskowal/q/issues/396
          // Timers are implemented universally.
          // We fall back to timers in workers in most engines, and in foreground
          // contexts in the following browsers.
          // However, note that even this simple case requires nuances to operate in a
          // broad spectrum of browsers.
          //
          // - Firefox 3-13
          // - Internet Explorer 6-9
          // - iPad Safari 4.3
          // - Lynx 2.8.7
        } else {
          requestFlush = makeRequestCallFromTimer(flush);
        } // `requestFlush` requests that the high priority event queue be flushed as
        // soon as possible.
        // This is useful to prevent an error thrown in a task from stalling the event
        // queue if the exception handled by Node.jss
        // `process.on("uncaughtException")` or by a domain.


        rawAsap.requestFlush = requestFlush; // To request a high priority event, we induce a mutation observer by toggling
        // the text of a text node between "1" and "-1".

        function makeRequestCallFromMutationObserver(callback) {
          var toggle = 1;
          var observer = new BrowserMutationObserver(callback);
          var node = document.createTextNode("");
          observer.observe(node, {
            characterData: true
          });
          return function requestCall() {
            toggle = -toggle;
            node.data = toggle;
          };
        } // The message channel technique was discovered by Malte Ubl and was the
        // original foundation for this library.
        // http://www.nonblocking.io/2011/06/windownexttick.html
        // Safari 6.0.5 (at least) intermittently fails to create message ports on a
        // page's first load. Thankfully, this version of Safari supports
        // MutationObservers, so we don't need to fall back in that case.
        // function makeRequestCallFromMessageChannel(callback) {
        //     var channel = new MessageChannel();
        //     channel.port1.onmessage = callback;
        //     return function requestCall() {
        //         channel.port2.postMessage(0);
        //     };
        // }
        // For reasons explained above, we are also unable to use `setImmediate`
        // under any circumstances.
        // Even if we were, there is another bug in Internet Explorer 10.
        // It is not sufficient to assign `setImmediate` to `requestFlush` because
        // `setImmediate` must be called *by name* and therefore must be wrapped in a
        // closure.
        // Never forget.
        // function makeRequestCallFromSetImmediate(callback) {
        //     return function requestCall() {
        //         setImmediate(callback);
        //     };
        // }
        // Safari 6.0 has a problem where timers will get lost while the user is
        // scrolling. This problem does not impact ASAP because Safari 6.0 supports
        // mutation observers, so that implementation is used instead.
        // However, if we ever elect to use timers in Safari, the prevalent work-around
        // is to add a scroll event listener that calls for a flush.
        // `setTimeout` does not call the passed callback if the delay is less than
        // approximately 7 in web workers in Firefox 8 through 18, and sometimes not
        // even then.


        function makeRequestCallFromTimer(callback) {
          return function requestCall() {
            // We dispatch a timeout with a specified delay of 0 for engines that
            // can reliably accommodate that request. This will usually be snapped
            // to a 4 milisecond delay, but once we're flushing, there's no delay
            // between events.
            var timeoutHandle = setTimeout(handleTimer, 0); // However, since this timer gets frequently dropped in Firefox
            // workers, we enlist an interval handle that will try to fire
            // an event 20 times per second until it succeeds.

            var intervalHandle = setInterval(handleTimer, 50);

            function handleTimer() {
              // Whichever timer succeeds will cancel both timers and
              // execute the callback.
              clearTimeout(timeoutHandle);
              clearInterval(intervalHandle);
              callback();
            }
          };
        } // This is for `asap.js` only.
        // Its name will be periodically randomized to break any code that depends on
        // its existence.


        rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer; // ASAP was originally a nextTick shim included in Q. This was factored out
        // into this ASAP package. It was later adapted to RSVP which made further
        // amendments. These decisions, particularly to marginalize MessageChannel and
        // to capture the MutationObserver implementation in a closure, were integrated
        // back into ASAP proper.
        // https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

        /* WEBPACK VAR INJECTION */
      }).call(exports, __nested_webpack_require_174716__(14));
      /***/
    },
    /* 14 */

    /***/
    function (module, exports) {
      var g; // This works in non-strict mode

      g = function () {
        return this;
      }();

      try {
        // This works if eval is allowed (see CSP)
        g = g || Function("return this")() || (1, eval)("this");
      } catch (e) {
        // This works if the window reference is available
        if (typeof window === "object") g = window;
      } // g can still be undefined, but nothing to do about it...
      // We return undefined, instead of nothing here, so it's
      // easier to handle this case. if(!global) { ...}


      module.exports = g;
      /***/
    },
    /* 15 */

    /***/
    function (module, exports, __nested_webpack_require_186529__) {
      var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // MIT license (by Elan Shanker).


      (function (globals) {
        'use strict';

        var executeSync = function () {
          var args = Array.prototype.slice.call(arguments);

          if (typeof args[0] === 'function') {
            args[0].apply(null, args.splice(1));
          }
        };

        var executeAsync = function (fn) {
          if (typeof setImmediate === 'function') {
            setImmediate(fn);
          } else if (typeof process !== 'undefined' && process.nextTick) {
            process.nextTick(fn);
          } else {
            setTimeout(fn, 0);
          }
        };

        var makeIterator = function (tasks) {
          var makeCallback = function (index) {
            var fn = function () {
              if (tasks.length) {
                tasks[index].apply(null, arguments);
              }

              return fn.next();
            };

            fn.next = function () {
              return index < tasks.length - 1 ? makeCallback(index + 1) : null;
            };

            return fn;
          };

          return makeCallback(0);
        };

        var _isArray = Array.isArray || function (maybeArray) {
          return Object.prototype.toString.call(maybeArray) === '[object Array]';
        };

        var waterfall = function (tasks, callback, forceAsync) {
          var nextTick = forceAsync ? executeAsync : executeSync;

          callback = callback || function () {};

          if (!_isArray(tasks)) {
            var err = new Error('First argument to waterfall must be an array of functions');
            return callback(err);
          }

          if (!tasks.length) {
            return callback();
          }

          var wrapIterator = function (iterator) {
            return function (err) {
              if (err) {
                callback.apply(null, arguments);

                callback = function () {};
              } else {
                var args = Array.prototype.slice.call(arguments, 1);
                var next = iterator.next();

                if (next) {
                  args.push(wrapIterator(next));
                } else {
                  args.push(callback);
                }

                nextTick(function () {
                  iterator.apply(null, args);
                });
              }
            };
          };

          wrapIterator(makeIterator(tasks))();
        };

        if (true) {
          !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return waterfall;
          }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // RequireJS
        } else {}
      })(this);
      /***/

    },
    /* 16 */

    /***/
    function (module, exports, __nested_webpack_require_189639__) {
      "use strict"; // Copyright Joyent, Inc. and other Node contributors.
      //
      // Permission is hereby granted, free of charge, to any person obtaining a
      // copy of this software and associated documentation files (the
      // "Software"), to deal in the Software without restriction, including
      // without limitation the rights to use, copy, modify, merge, publish,
      // distribute, sublicense, and/or sell copies of the Software, and to permit
      // persons to whom the Software is furnished to do so, subject to the
      // following conditions:
      //
      // The above copyright notice and this permission notice shall be included
      // in all copies or substantial portions of the Software.
      //
      // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
      // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
      // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
      // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
      // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
      // USE OR OTHER DEALINGS IN THE SOFTWARE.

      var R = typeof Reflect === 'object' ? Reflect : null;
      var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;

      if (R && typeof R.ownKeys === 'function') {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys(target) {
          return Object.getOwnPropertyNames(target);
        };
      }

      function ProcessEmitWarning(warning) {
        if (console && console.warn) console.warn(warning);
      }

      var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
        return value !== value;
      };

      function EventEmitter() {
        EventEmitter.init.call(this);
      }

      module.exports = EventEmitter; // Backwards-compat with node 0.10.x

      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = undefined;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
      // added to it. This is a useful default which helps finding memory leaks.

      var defaultMaxListeners = 10;

      function checkListener(listener) {
        if (typeof listener !== 'function') {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }

      Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
        enumerable: true,
        get: function () {
          return defaultMaxListeners;
        },
        set: function (arg) {
          if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
          }

          defaultMaxListeners = arg;
        }
      });

      EventEmitter.init = function () {
        if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        }

        this._maxListeners = this._maxListeners || undefined;
      }; // Obviously not all Emitters should be limited to 10. This function allows
      // that to be increased. Set to zero for unlimited.


      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
        }

        this._maxListeners = n;
        return this;
      };

      function _getMaxListeners(that) {
        if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }

      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };

      EventEmitter.prototype.emit = function emit(type) {
        var args = [];

        for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);

        var doError = type === 'error';
        var events = this._events;
        if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

        if (doError) {
          var er;
          if (args.length > 0) er = args[0];

          if (er instanceof Error) {
            // Note: The comments on the `throw` lines are intentional, they show
            // up in Node's output if this results in an unhandled exception.
            throw er; // Unhandled 'error' event
          } // At least give some kind of context to the user


          var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
          err.context = er;
          throw err; // Unhandled 'error' event
        }

        var handler = events[type];
        if (handler === undefined) return false;

        if (typeof handler === 'function') {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);

          for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
        }

        return true;
      };

      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;

        if (events === undefined) {
          events = target._events = Object.create(null);
          target._eventsCount = 0;
        } else {
          // To avoid recursion in the case that type === "newListener"! Before
          // adding it to the listeners, first emit "newListener".
          if (events.newListener !== undefined) {
            target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object

            events = target._events;
          }

          existing = events[type];
        }

        if (existing === undefined) {
          // Optimize the case of one listener. Don't need the extra array object.
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === 'function') {
            // Adding the second element, need to change to array.
            existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          } // Check for listener leak


          m = _getMaxListeners(target);

          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true; // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax

            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }

        return target;
      }

      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };

      EventEmitter.prototype.on = EventEmitter.prototype.addListener;

      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };

      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0) return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }

      function _onceWrap(target, type, listener) {
        var state = {
          fired: false,
          wrapFn: undefined,
          target: target,
          type: type,
          listener: listener
        };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }

      EventEmitter.prototype.once = function once(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };

      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      }; // Emits a 'removeListener' event if and only if the listener was removed.


      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === undefined) return this;
        list = events[type];
        if (list === undefined) return this;

        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0) this._events = Object.create(null);else {
            delete events[type];
            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
          }
        } else if (typeof list !== 'function') {
          position = -1;

          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }

          if (position < 0) return this;
          if (position === 0) list.shift();else {
            spliceOne(list, position);
          }
          if (list.length === 1) events[type] = list[0];
          if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
        }

        return this;
      };

      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === undefined) return this; // not listening for removeListener, no need to emit

        if (events.removeListener === undefined) {
          if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
          }

          return this;
        } // emit removeListener for all listeners on all events


        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;

          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }

          this.removeAllListeners('removeListener');
          this._events = Object.create(null);
          this._eventsCount = 0;
          return this;
        }

        listeners = events[type];

        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners !== undefined) {
          // LIFO order
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }

        return this;
      };

      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === undefined) return [];
        var evlistener = events[type];
        if (evlistener === undefined) return [];
        if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }

      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };

      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };

      EventEmitter.listenerCount = function (emitter, type) {
        if (typeof emitter.listenerCount === 'function') {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };

      EventEmitter.prototype.listenerCount = listenerCount;

      function listenerCount(type) {
        var events = this._events;

        if (events !== undefined) {
          var evlistener = events[type];

          if (typeof evlistener === 'function') {
            return 1;
          } else if (evlistener !== undefined) {
            return evlistener.length;
          }
        }

        return 0;
      }

      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };

      function arrayClone(arr, n) {
        var copy = new Array(n);

        for (var i = 0; i < n; ++i) copy[i] = arr[i];

        return copy;
      }

      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++) list[index] = list[index + 1];

        list.pop();
      }

      function unwrapListeners(arr) {
        var ret = new Array(arr.length);

        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }

        return ret;
      }
      /***/

    },
    /* 17 */

    /***/
    function (module, exports, __nested_webpack_require_204321__) {
      "use strict";

      var nodes = __nested_webpack_require_204321__(3);

      var lib = __nested_webpack_require_204321__(0);

      var sym = 0;

      function gensym() {
        return 'hole_' + sym++;
      } // copy-on-write version of map


      function mapCOW(arr, func) {
        var res = null;

        for (var i = 0; i < arr.length; i++) {
          var item = func(arr[i]);

          if (item !== arr[i]) {
            if (!res) {
              res = arr.slice();
            }

            res[i] = item;
          }
        }

        return res || arr;
      }

      function walk(ast, func, depthFirst) {
        if (!(ast instanceof nodes.Node)) {
          return ast;
        }

        if (!depthFirst) {
          var astT = func(ast);

          if (astT && astT !== ast) {
            return astT;
          }
        }

        if (ast instanceof nodes.NodeList) {
          var children = mapCOW(ast.children, function (node) {
            return walk(node, func, depthFirst);
          });

          if (children !== ast.children) {
            ast = new nodes[ast.typename](ast.lineno, ast.colno, children);
          }
        } else if (ast instanceof nodes.CallExtension) {
          var args = walk(ast.args, func, depthFirst);
          var contentArgs = mapCOW(ast.contentArgs, function (node) {
            return walk(node, func, depthFirst);
          });

          if (args !== ast.args || contentArgs !== ast.contentArgs) {
            ast = new nodes[ast.typename](ast.extName, ast.prop, args, contentArgs);
          }
        } else {
          var props = ast.fields.map(function (field) {
            return ast[field];
          });
          var propsT = mapCOW(props, function (prop) {
            return walk(prop, func, depthFirst);
          });

          if (propsT !== props) {
            ast = new nodes[ast.typename](ast.lineno, ast.colno);
            propsT.forEach(function (prop, i) {
              ast[ast.fields[i]] = prop;
            });
          }
        }

        return depthFirst ? func(ast) || ast : ast;
      }

      function depthWalk(ast, func) {
        return walk(ast, func, true);
      }

      function _liftFilters(node, asyncFilters, prop) {
        var children = [];
        var walked = depthWalk(prop ? node[prop] : node, function (descNode) {
          var symbol;

          if (descNode instanceof nodes.Block) {
            return descNode;
          } else if (descNode instanceof nodes.Filter && lib.indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof nodes.CallExtensionAsync) {
            symbol = new nodes.Symbol(descNode.lineno, descNode.colno, gensym());
            children.push(new nodes.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
          }

          return symbol;
        });

        if (prop) {
          node[prop] = walked;
        } else {
          node = walked;
        }

        if (children.length) {
          children.push(node);
          return new nodes.NodeList(node.lineno, node.colno, children);
        } else {
          return node;
        }
      }

      function liftFilters(ast, asyncFilters) {
        return depthWalk(ast, function (node) {
          if (node instanceof nodes.Output) {
            return _liftFilters(node, asyncFilters);
          } else if (node instanceof nodes.Set) {
            return _liftFilters(node, asyncFilters, 'value');
          } else if (node instanceof nodes.For) {
            return _liftFilters(node, asyncFilters, 'arr');
          } else if (node instanceof nodes.If) {
            return _liftFilters(node, asyncFilters, 'cond');
          } else if (node instanceof nodes.CallExtension) {
            return _liftFilters(node, asyncFilters, 'args');
          } else {
            return undefined;
          }
        });
      }

      function liftSuper(ast) {
        return walk(ast, function (blockNode) {
          if (!(blockNode instanceof nodes.Block)) {
            return;
          }

          var hasSuper = false;
          var symbol = gensym();
          blockNode.body = walk(blockNode.body, function (node) {
            // eslint-disable-line consistent-return
            if (node instanceof nodes.FunCall && node.name.value === 'super') {
              hasSuper = true;
              return new nodes.Symbol(node.lineno, node.colno, symbol);
            }
          });

          if (hasSuper) {
            blockNode.body.children.unshift(new nodes.Super(0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)));
          }
        });
      }

      function convertStatements(ast) {
        return depthWalk(ast, function (node) {
          if (!(node instanceof nodes.If) && !(node instanceof nodes.For)) {
            return undefined;
          }

          var async = false;
          walk(node, function (child) {
            if (child instanceof nodes.FilterAsync || child instanceof nodes.IfAsync || child instanceof nodes.AsyncEach || child instanceof nodes.AsyncAll || child instanceof nodes.CallExtensionAsync) {
              async = true; // Stop iterating by returning the node

              return child;
            }

            return undefined;
          });

          if (async) {
            if (node instanceof nodes.If) {
              return new nodes.IfAsync(node.lineno, node.colno, node.cond, node.body, node.else_);
            } else if (node instanceof nodes.For && !(node instanceof nodes.AsyncAll)) {
              return new nodes.AsyncEach(node.lineno, node.colno, node.arr, node.name, node.body, node.else_);
            }
          }

          return undefined;
        });
      }

      function cps(ast, asyncFilters) {
        return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
      }

      function transform(ast, asyncFilters) {
        return cps(ast, asyncFilters || []);
      } // var parser = require('./parser');
      // var src = 'hello {% foo %}{% endfoo %} end';
      // var ast = transform(parser.parse(src, [new FooExtension()]), ['bar']);
      // nodes.printNodes(ast);


      module.exports = {
        transform: transform
      };
      /***/
    },
    /* 18 */

    /***/
    function (module, exports, __nested_webpack_require_210589__) {
      "use strict";

      var lib = __nested_webpack_require_210589__(0);

      var r = __nested_webpack_require_210589__(2);

      var exports = module.exports = {};

      function normalize(value, defaultValue) {
        if (value === null || value === undefined || value === false) {
          return defaultValue;
        }

        return value;
      }

      exports.abs = Math.abs;

      function isNaN(num) {
        return num !== num; // eslint-disable-line no-self-compare
      }

      function batch(arr, linecount, fillWith) {
        var i;
        var res = [];
        var tmp = [];

        for (i = 0; i < arr.length; i++) {
          if (i % linecount === 0 && tmp.length) {
            res.push(tmp);
            tmp = [];
          }

          tmp.push(arr[i]);
        }

        if (tmp.length) {
          if (fillWith) {
            for (i = tmp.length; i < linecount; i++) {
              tmp.push(fillWith);
            }
          }

          res.push(tmp);
        }

        return res;
      }

      exports.batch = batch;

      function capitalize(str) {
        str = normalize(str, '');
        var ret = str.toLowerCase();
        return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
      }

      exports.capitalize = capitalize;

      function center(str, width) {
        str = normalize(str, '');
        width = width || 80;

        if (str.length >= width) {
          return str;
        }

        var spaces = width - str.length;
        var pre = lib.repeat(' ', spaces / 2 - spaces % 2);
        var post = lib.repeat(' ', spaces / 2);
        return r.copySafeness(str, pre + str + post);
      }

      exports.center = center;

      function default_(val, def, bool) {
        if (bool) {
          return val || def;
        } else {
          return val !== undefined ? val : def;
        }
      } // TODO: it is confusing to export something called 'default'


      exports['default'] = default_; // eslint-disable-line dot-notation

      function dictsort(val, caseSensitive, by) {
        if (!lib.isObject(val)) {
          throw new lib.TemplateError('dictsort filter: val must be an object');
        }

        var array = []; // deliberately include properties from the object's prototype

        for (var k in val) {
          // eslint-disable-line guard-for-in, no-restricted-syntax
          array.push([k, val[k]]);
        }

        var si;

        if (by === undefined || by === 'key') {
          si = 0;
        } else if (by === 'value') {
          si = 1;
        } else {
          throw new lib.TemplateError('dictsort filter: You can only sort by either key or value');
        }

        array.sort(function (t1, t2) {
          var a = t1[si];
          var b = t2[si];

          if (!caseSensitive) {
            if (lib.isString(a)) {
              a = a.toUpperCase();
            }

            if (lib.isString(b)) {
              b = b.toUpperCase();
            }
          }

          return a > b ? 1 : a === b ? 0 : -1; // eslint-disable-line no-nested-ternary
        });
        return array;
      }

      exports.dictsort = dictsort;

      function dump(obj, spaces) {
        return JSON.stringify(obj, null, spaces);
      }

      exports.dump = dump;

      function escape(str) {
        if (str instanceof r.SafeString) {
          return str;
        }

        str = str === null || str === undefined ? '' : str;
        return r.markSafe(lib.escape(str.toString()));
      }

      exports.escape = escape;

      function safe(str) {
        if (str instanceof r.SafeString) {
          return str;
        }

        str = str === null || str === undefined ? '' : str;
        return r.markSafe(str.toString());
      }

      exports.safe = safe;

      function first(arr) {
        return arr[0];
      }

      exports.first = first;

      function forceescape(str) {
        str = str === null || str === undefined ? '' : str;
        return r.markSafe(lib.escape(str.toString()));
      }

      exports.forceescape = forceescape;

      function groupby(arr, attr) {
        return lib.groupBy(arr, attr, this.env.opts.throwOnUndefined);
      }

      exports.groupby = groupby;

      function indent(str, width, indentfirst) {
        str = normalize(str, '');

        if (str === '') {
          return '';
        }

        width = width || 4; // let res = '';

        var lines = str.split('\n');
        var sp = lib.repeat(' ', width);
        var res = lines.map(function (l, i) {
          return i === 0 && !indentfirst ? l : "" + sp + l;
        }).join('\n');
        return r.copySafeness(str, res);
      }

      exports.indent = indent;

      function join(arr, del, attr) {
        del = del || '';

        if (attr) {
          arr = lib.map(arr, function (v) {
            return v[attr];
          });
        }

        return arr.join(del);
      }

      exports.join = join;

      function last(arr) {
        return arr[arr.length - 1];
      }

      exports.last = last;

      function lengthFilter(val) {
        var value = normalize(val, '');

        if (value !== undefined) {
          if (typeof Map === 'function' && value instanceof Map || typeof Set === 'function' && value instanceof Set) {
            // ECMAScript 2015 Maps and Sets
            return value.size;
          }

          if (lib.isObject(value) && !(value instanceof r.SafeString)) {
            // Objects (besides SafeStrings), non-primative Arrays
            return lib.keys(value).length;
          }

          return value.length;
        }

        return 0;
      }

      exports.length = lengthFilter;

      function list(val) {
        if (lib.isString(val)) {
          return val.split('');
        } else if (lib.isObject(val)) {
          return lib._entries(val || {}).map(function (_ref) {
            var key = _ref[0],
                value = _ref[1];
            return {
              key: key,
              value: value
            };
          });
        } else if (lib.isArray(val)) {
          return val;
        } else {
          throw new lib.TemplateError('list filter: type not iterable');
        }
      }

      exports.list = list;

      function lower(str) {
        str = normalize(str, '');
        return str.toLowerCase();
      }

      exports.lower = lower;

      function nl2br(str) {
        if (str === null || str === undefined) {
          return '';
        }

        return r.copySafeness(str, str.replace(/\r\n|\n/g, '<br />\n'));
      }

      exports.nl2br = nl2br;

      function random(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
      }

      exports.random = random;
      /**
       * Construct select or reject filter
       *
       * @param {boolean} expectedTestResult
       * @returns {function(array, string, *): array}
       */

      function getSelectOrReject(expectedTestResult) {
        function filter(arr, testName, secondArg) {
          if (testName === void 0) {
            testName = 'truthy';
          }

          var context = this;
          var test = context.env.getTest(testName);
          return lib.toArray(arr).filter(function examineTestResult(item) {
            return test.call(context, item, secondArg) === expectedTestResult;
          });
        }

        return filter;
      }

      exports.reject = getSelectOrReject(false);

      function rejectattr(arr, attr) {
        return arr.filter(function (item) {
          return !item[attr];
        });
      }

      exports.rejectattr = rejectattr;
      exports.select = getSelectOrReject(true);

      function selectattr(arr, attr) {
        return arr.filter(function (item) {
          return !!item[attr];
        });
      }

      exports.selectattr = selectattr;

      function replace(str, old, new_, maxCount) {
        var originalStr = str;

        if (old instanceof RegExp) {
          return str.replace(old, new_);
        }

        if (typeof maxCount === 'undefined') {
          maxCount = -1;
        }

        var res = ''; // Output
        // Cast Numbers in the search term to string

        if (typeof old === 'number') {
          old = '' + old;
        } else if (typeof old !== 'string') {
          // If it is something other than number or string,
          // return the original string
          return str;
        } // Cast numbers in the replacement to string


        if (typeof str === 'number') {
          str = '' + str;
        } // If by now, we don't have a string, throw it back


        if (typeof str !== 'string' && !(str instanceof r.SafeString)) {
          return str;
        } // ShortCircuits


        if (old === '') {
          // Mimic the python behaviour: empty string is replaced
          // by replacement e.g. "abc"|replace("", ".") -> .a.b.c.
          res = new_ + str.split('').join(new_) + new_;
          return r.copySafeness(str, res);
        }

        var nextIndex = str.indexOf(old); // if # of replacements to perform is 0, or the string to does
        // not contain the old value, return the string

        if (maxCount === 0 || nextIndex === -1) {
          return str;
        }

        var pos = 0;
        var count = 0; // # of replacements made

        while (nextIndex > -1 && (maxCount === -1 || count < maxCount)) {
          // Grab the next chunk of src string and add it with the
          // replacement, to the result
          res += str.substring(pos, nextIndex) + new_; // Increment our pointer in the src string

          pos = nextIndex + old.length;
          count++; // See if there are any more replacements to be made

          nextIndex = str.indexOf(old, pos);
        } // We've either reached the end, or done the max # of
        // replacements, tack on any remaining string


        if (pos < str.length) {
          res += str.substring(pos);
        }

        return r.copySafeness(originalStr, res);
      }

      exports.replace = replace;

      function reverse(val) {
        var arr;

        if (lib.isString(val)) {
          arr = list(val);
        } else {
          // Copy it
          arr = lib.map(val, function (v) {
            return v;
          });
        }

        arr.reverse();

        if (lib.isString(val)) {
          return r.copySafeness(val, arr.join(''));
        }

        return arr;
      }

      exports.reverse = reverse;

      function round(val, precision, method) {
        precision = precision || 0;
        var factor = Math.pow(10, precision);
        var rounder;

        if (method === 'ceil') {
          rounder = Math.ceil;
        } else if (method === 'floor') {
          rounder = Math.floor;
        } else {
          rounder = Math.round;
        }

        return rounder(val * factor) / factor;
      }

      exports.round = round;

      function slice(arr, slices, fillWith) {
        var sliceLength = Math.floor(arr.length / slices);
        var extra = arr.length % slices;
        var res = [];
        var offset = 0;

        for (var i = 0; i < slices; i++) {
          var start = offset + i * sliceLength;

          if (i < extra) {
            offset++;
          }

          var end = offset + (i + 1) * sliceLength;
          var currSlice = arr.slice(start, end);

          if (fillWith && i >= extra) {
            currSlice.push(fillWith);
          }

          res.push(currSlice);
        }

        return res;
      }

      exports.slice = slice;

      function sum(arr, attr, start) {
        if (start === void 0) {
          start = 0;
        }

        if (attr) {
          arr = lib.map(arr, function (v) {
            return v[attr];
          });
        }

        return start + arr.reduce(function (a, b) {
          return a + b;
        }, 0);
      }

      exports.sum = sum;
      exports.sort = r.makeMacro(['value', 'reverse', 'case_sensitive', 'attribute'], [], function (arr, reversed, caseSens, attr) {
        // Copy it
        var array = lib.map(arr, function (v) {
          return v;
        });
        array.sort(function (a, b) {
          var x = attr ? a[attr] : a;
          var y = attr ? b[attr] : b;

          if (!caseSens && lib.isString(x) && lib.isString(y)) {
            x = x.toLowerCase();
            y = y.toLowerCase();
          }

          if (x < y) {
            return reversed ? 1 : -1;
          } else if (x > y) {
            return reversed ? -1 : 1;
          } else {
            return 0;
          }
        });
        return array;
      });

      function string(obj) {
        return r.copySafeness(obj, obj);
      }

      exports.string = string;

      function striptags(input, preserveLinebreaks) {
        input = normalize(input, '');
        var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
        var trimmedInput = trim(input.replace(tags, ''));
        var res = '';

        if (preserveLinebreaks) {
          res = trimmedInput.replace(/^ +| +$/gm, '') // remove leading and trailing spaces
          .replace(/ +/g, ' ') // squash adjacent spaces
          .replace(/(\r\n)/g, '\n') // normalize linebreaks (CRLF -> LF)
          .replace(/\n\n\n+/g, '\n\n'); // squash abnormal adjacent linebreaks
        } else {
          res = trimmedInput.replace(/\s+/gi, ' ');
        }

        return r.copySafeness(input, res);
      }

      exports.striptags = striptags;

      function title(str) {
        str = normalize(str, '');
        var words = str.split(' ').map(function (word) {
          return capitalize(word);
        });
        return r.copySafeness(str, words.join(' '));
      }

      exports.title = title;

      function trim(str) {
        return r.copySafeness(str, str.replace(/^\s*|\s*$/g, ''));
      }

      exports.trim = trim;

      function truncate(input, length, killwords, end) {
        var orig = input;
        input = normalize(input, '');
        length = length || 255;

        if (input.length <= length) {
          return input;
        }

        if (killwords) {
          input = input.substring(0, length);
        } else {
          var idx = input.lastIndexOf(' ', length);

          if (idx === -1) {
            idx = length;
          }

          input = input.substring(0, idx);
        }

        input += end !== undefined && end !== null ? end : '...';
        return r.copySafeness(orig, input);
      }

      exports.truncate = truncate;

      function upper(str) {
        str = normalize(str, '');
        return str.toUpperCase();
      }

      exports.upper = upper;

      function urlencode(obj) {
        var enc = encodeURIComponent;

        if (lib.isString(obj)) {
          return enc(obj);
        } else {
          var keyvals = lib.isArray(obj) ? obj : lib._entries(obj);
          return keyvals.map(function (_ref2) {
            var k = _ref2[0],
                v = _ref2[1];
            return enc(k) + "=" + enc(v);
          }).join('&');
        }
      }

      exports.urlencode = urlencode; // For the jinja regexp, see
      // https://github.com/mitsuhiko/jinja2/blob/f15b814dcba6aa12bc74d1f7d0c881d55f7126be/jinja2/utils.py#L20-L23

      var puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/; // from http://blog.gerv.net/2011/05/html5_email_address_regexp/

      var emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
      var httpHttpsRe = /^https?:\/\/.*$/;
      var wwwRe = /^www\./;
      var tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;

      function urlize(str, length, nofollow) {
        if (isNaN(length)) {
          length = Infinity;
        }

        var noFollowAttr = nofollow === true ? ' rel="nofollow"' : '';
        var words = str.split(/(\s+)/).filter(function (word) {
          // If the word has no length, bail. This can happen for str with
          // trailing whitespace.
          return word && word.length;
        }).map(function (word) {
          var matches = word.match(puncRe);
          var possibleUrl = matches ? matches[1] : word;
          var shortUrl = possibleUrl.substr(0, length); // url that starts with http or https

          if (httpHttpsRe.test(possibleUrl)) {
            return "<a href=\"" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
          } // url that starts with www.


          if (wwwRe.test(possibleUrl)) {
            return "<a href=\"http://" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
          } // an email address of the form username@domain.tld


          if (emailRe.test(possibleUrl)) {
            return "<a href=\"mailto:" + possibleUrl + "\">" + possibleUrl + "</a>";
          } // url that ends in .com, .org or .net that is not an email address


          if (tldRe.test(possibleUrl)) {
            return "<a href=\"http://" + possibleUrl + "\"" + noFollowAttr + ">" + shortUrl + "</a>";
          }

          return word;
        });
        return words.join('');
      }

      exports.urlize = urlize;

      function wordcount(str) {
        str = normalize(str, '');
        var words = str ? str.match(/\w+/g) : null;
        return words ? words.length : null;
      }

      exports.wordcount = wordcount;

      function float(val, def) {
        var res = parseFloat(val);
        return isNaN(res) ? def : res;
      }

      exports.float = float;

      function int(val, def) {
        var res = parseInt(val, 10);
        return isNaN(res) ? def : res;
      }

      exports.int = int; // Aliases

      exports.d = exports.default;
      exports.e = exports.escape;
      /***/
    },
    /* 19 */

    /***/
    function (module, exports, __nested_webpack_require_228264__) {
      "use strict";

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }

      var Loader = __nested_webpack_require_228264__(6);

      var PrecompiledLoader = /*#__PURE__*/function (_Loader) {
        _inheritsLoose(PrecompiledLoader, _Loader);

        function PrecompiledLoader(compiledTemplates) {
          var _this;

          _this = _Loader.call(this) || this;
          _this.precompiled = compiledTemplates || {};
          return _this;
        }

        var _proto = PrecompiledLoader.prototype;

        _proto.getSource = function getSource(name) {
          if (this.precompiled[name]) {
            return {
              src: {
                type: 'code',
                obj: this.precompiled[name]
              },
              path: name
            };
          }

          return null;
        };

        return PrecompiledLoader;
      }(Loader);

      module.exports = {
        PrecompiledLoader: PrecompiledLoader
      };
      /***/
    },
    /* 20 */

    /***/
    function (module, exports, __nested_webpack_require_229475__) {
      "use strict";

      var SafeString = __nested_webpack_require_229475__(2).SafeString;
      /**
       * Returns `true` if the object is a function, otherwise `false`.
       * @param { any } value
       * @returns { boolean }
       */


      function callable(value) {
        return typeof value === 'function';
      }

      exports.callable = callable;
      /**
       * Returns `true` if the object is strictly not `undefined`.
       * @param { any } value
       * @returns { boolean }
       */

      function defined(value) {
        return value !== undefined;
      }

      exports.defined = defined;
      /**
       * Returns `true` if the operand (one) is divisble by the test's argument
       * (two).
       * @param { number } one
       * @param { number } two
       * @returns { boolean }
       */

      function divisibleby(one, two) {
        return one % two === 0;
      }

      exports.divisibleby = divisibleby;
      /**
       * Returns true if the string has been escaped (i.e., is a SafeString).
       * @param { any } value
       * @returns { boolean }
       */

      function escaped(value) {
        return value instanceof SafeString;
      }

      exports.escaped = escaped;
      /**
       * Returns `true` if the arguments are strictly equal.
       * @param { any } one
       * @param { any } two
       */

      function equalto(one, two) {
        return one === two;
      }

      exports.equalto = equalto; // Aliases

      exports.eq = exports.equalto;
      exports.sameas = exports.equalto;
      /**
       * Returns `true` if the value is evenly divisible by 2.
       * @param { number } value
       * @returns { boolean }
       */

      function even(value) {
        return value % 2 === 0;
      }

      exports.even = even;
      /**
       * Returns `true` if the value is falsy - if I recall correctly, '', 0, false,
       * undefined, NaN or null. I don't know if we should stick to the default JS
       * behavior or attempt to replicate what Python believes should be falsy (i.e.,
       * empty arrays, empty dicts, not 0...).
       * @param { any } value
       * @returns { boolean }
       */

      function falsy(value) {
        return !value;
      }

      exports.falsy = falsy;
      /**
       * Returns `true` if the operand (one) is greater or equal to the test's
       * argument (two).
       * @param { number } one
       * @param { number } two
       * @returns { boolean }
       */

      function ge(one, two) {
        return one >= two;
      }

      exports.ge = ge;
      /**
       * Returns `true` if the operand (one) is greater than the test's argument
       * (two).
       * @param { number } one
       * @param { number } two
       * @returns { boolean }
       */

      function greaterthan(one, two) {
        return one > two;
      }

      exports.greaterthan = greaterthan; // alias

      exports.gt = exports.greaterthan;
      /**
       * Returns `true` if the operand (one) is less than or equal to the test's
       * argument (two).
       * @param { number } one
       * @param { number } two
       * @returns { boolean }
       */

      function le(one, two) {
        return one <= two;
      }

      exports.le = le;
      /**
       * Returns `true` if the operand (one) is less than the test's passed argument
       * (two).
       * @param { number } one
       * @param { number } two
       * @returns { boolean }
       */

      function lessthan(one, two) {
        return one < two;
      }

      exports.lessthan = lessthan; // alias

      exports.lt = exports.lessthan;
      /**
       * Returns `true` if the string is lowercased.
       * @param { string } value
       * @returns { boolean }
       */

      function lower(value) {
        return value.toLowerCase() === value;
      }

      exports.lower = lower;
      /**
       * Returns `true` if the operand (one) is less than or equal to the test's
       * argument (two).
       * @param { number } one
       * @param { number } two
       * @returns { boolean }
       */

      function ne(one, two) {
        return one !== two;
      }

      exports.ne = ne;
      /**
       * Returns true if the value is strictly equal to `null`.
       * @param { any }
       * @returns { boolean }
       */

      function nullTest(value) {
        return value === null;
      }

      exports.null = nullTest;
      /**
       * Returns true if value is a number.
       * @param { any }
       * @returns { boolean }
       */

      function number(value) {
        return typeof value === 'number';
      }

      exports.number = number;
      /**
       * Returns `true` if the value is *not* evenly divisible by 2.
       * @param { number } value
       * @returns { boolean }
       */

      function odd(value) {
        return value % 2 === 1;
      }

      exports.odd = odd;
      /**
       * Returns `true` if the value is a string, `false` if not.
       * @param { any } value
       * @returns { boolean }
       */

      function string(value) {
        return typeof value === 'string';
      }

      exports.string = string;
      /**
       * Returns `true` if the value is not in the list of things considered falsy:
       * '', null, undefined, 0, NaN and false.
       * @param { any } value
       * @returns { boolean }
       */

      function truthy(value) {
        return !!value;
      }

      exports.truthy = truthy;
      /**
       * Returns `true` if the value is undefined.
       * @param { any } value
       * @returns { boolean }
       */

      function undefinedTest(value) {
        return value === undefined;
      }

      exports.undefined = undefinedTest;
      /**
       * Returns `true` if the string is uppercased.
       * @param { string } value
       * @returns { boolean }
       */

      function upper(value) {
        return value.toUpperCase() === value;
      }

      exports.upper = upper;
      /**
       * If ES6 features are available, returns `true` if the value implements the
       * `Symbol.iterator` method. If not, it's a string or Array.
       *
       * Could potentially cause issues if a browser exists that has Set and Map but
       * not Symbol.
       *
       * @param { any } value
       * @returns { boolean }
       */

      function iterable(value) {
        if (typeof Symbol !== 'undefined') {
          return !!value[Symbol.iterator];
        } else {
          return Array.isArray(value) || typeof value === 'string';
        }
      }

      exports.iterable = iterable;
      /**
       * If ES6 features are available, returns `true` if the value is an object hash
       * or an ES6 Map. Otherwise just return if it's an object hash.
       * @param { any } value
       * @returns { boolean }
       */

      function mapping(value) {
        // only maps and object hashes
        var bool = value !== null && value !== undefined && typeof value === 'object' && !Array.isArray(value);

        if (Set) {
          return bool && !(value instanceof Set);
        } else {
          return bool;
        }
      }

      exports.mapping = mapping;
      /***/
    },
    /* 21 */

    /***/
    function (module, exports, __nested_webpack_require_236749__) {
      "use strict";

      function _cycler(items) {
        var index = -1;
        return {
          current: null,
          reset: function reset() {
            index = -1;
            this.current = null;
          },
          next: function next() {
            index++;

            if (index >= items.length) {
              index = 0;
            }

            this.current = items[index];
            return this.current;
          }
        };
      }

      function _joiner(sep) {
        sep = sep || ',';
        var first = true;
        return function () {
          var val = first ? '' : sep;
          first = false;
          return val;
        };
      } // Making this a function instead so it returns a new object
      // each time it's called. That way, if something like an environment
      // uses it, they will each have their own copy.


      function globals() {
        return {
          range: function range(start, stop, step) {
            if (typeof stop === 'undefined') {
              stop = start;
              start = 0;
              step = 1;
            } else if (!step) {
              step = 1;
            }

            var arr = [];

            if (step > 0) {
              for (var i = start; i < stop; i += step) {
                arr.push(i);
              }
            } else {
              for (var _i = start; _i > stop; _i += step) {
                // eslint-disable-line for-direction
                arr.push(_i);
              }
            }

            return arr;
          },
          cycler: function cycler() {
            return _cycler(Array.prototype.slice.call(arguments));
          },
          joiner: function joiner(sep) {
            return _joiner(sep);
          }
        };
      }

      module.exports = globals;
      /***/
    },
    /* 22 */

    /***/
    function (module, exports, __nested_webpack_require_238658__) {
      var path = __nested_webpack_require_238658__(4);

      module.exports = function express(env, app) {
        function NunjucksView(name, opts) {
          this.name = name;
          this.path = name;
          this.defaultEngine = opts.defaultEngine;
          this.ext = path.extname(name);

          if (!this.ext && !this.defaultEngine) {
            throw new Error('No default engine was specified and no extension was provided.');
          }

          if (!this.ext) {
            this.name += this.ext = (this.defaultEngine[0] !== '.' ? '.' : '') + this.defaultEngine;
          }
        }

        NunjucksView.prototype.render = function render(opts, cb) {
          env.render(this.name, opts, cb);
        };

        app.set('view', NunjucksView);
        app.set('nunjucksEnv', env);
        return env;
      };
      /***/

    },
    /* 23 */

    /***/
    function (module, exports, __nested_webpack_require_239580__) {
      "use strict";

      var fs = __nested_webpack_require_239580__(4);

      var path = __nested_webpack_require_239580__(4);

      var _require = __nested_webpack_require_239580__(0),
          _prettifyError = _require._prettifyError;

      var compiler = __nested_webpack_require_239580__(5);

      var _require2 = __nested_webpack_require_239580__(7),
          Environment = _require2.Environment;

      var precompileGlobal = __nested_webpack_require_239580__(24);

      function match(filename, patterns) {
        if (!Array.isArray(patterns)) {
          return false;
        }

        return patterns.some(function (pattern) {
          return filename.match(pattern);
        });
      }

      function precompileString(str, opts) {
        opts = opts || {};
        opts.isString = true;
        var env = opts.env || new Environment([]);
        var wrapper = opts.wrapper || precompileGlobal;

        if (!opts.name) {
          throw new Error('the "name" option is required when compiling a string');
        }

        return wrapper([_precompile(str, opts.name, env)], opts);
      }

      function precompile(input, opts) {
        // The following options are available:
        //
        // * name: name of the template (auto-generated when compiling a directory)
        // * isString: input is a string, not a file path
        // * asFunction: generate a callable function
        // * force: keep compiling on error
        // * env: the Environment to use (gets extensions and async filters from it)
        // * include: which file/folders to include (folders are auto-included, files are auto-excluded)
        // * exclude: which file/folders to exclude (folders are auto-included, files are auto-excluded)
        // * wrapper: function(templates, opts) {...}
        //       Customize the output format to store the compiled template.
        //       By default, templates are stored in a global variable used by the runtime.
        //       A custom loader will be necessary to load your custom wrapper.
        opts = opts || {};
        var env = opts.env || new Environment([]);
        var wrapper = opts.wrapper || precompileGlobal;

        if (opts.isString) {
          return precompileString(input, opts);
        }

        var pathStats = fs.existsSync(input) && fs.statSync(input);
        var precompiled = [];
        var templates = [];

        function addTemplates(dir) {
          fs.readdirSync(dir).forEach(function (file) {
            var filepath = path.join(dir, file);
            var subpath = filepath.substr(path.join(input, '/').length);
            var stat = fs.statSync(filepath);

            if (stat && stat.isDirectory()) {
              subpath += '/';

              if (!match(subpath, opts.exclude)) {
                addTemplates(filepath);
              }
            } else if (match(subpath, opts.include)) {
              templates.push(filepath);
            }
          });
        }

        if (pathStats.isFile()) {
          precompiled.push(_precompile(fs.readFileSync(input, 'utf-8'), opts.name || input, env));
        } else if (pathStats.isDirectory()) {
          addTemplates(input);

          for (var i = 0; i < templates.length; i++) {
            var name = templates[i].replace(path.join(input, '/'), '');

            try {
              precompiled.push(_precompile(fs.readFileSync(templates[i], 'utf-8'), name, env));
            } catch (e) {
              if (opts.force) {
                // Don't stop generating the output if we're
                // forcing compilation.
                console.error(e); // eslint-disable-line no-console
              } else {
                throw e;
              }
            }
          }
        }

        return wrapper(precompiled, opts);
      }

      function _precompile(str, name, env) {
        env = env || new Environment([]);
        var asyncFilters = env.asyncFilters;
        var extensions = env.extensionsList;
        var template;
        name = name.replace(/\\/g, '/');

        try {
          template = compiler.compile(str, asyncFilters, extensions, name, env.opts);
        } catch (err) {
          throw _prettifyError(name, false, err);
        }

        return {
          name: name,
          template: template
        };
      }

      module.exports = {
        precompile: precompile,
        precompileString: precompileString
      };
      /***/
    },
    /* 24 */

    /***/
    function (module, exports, __nested_webpack_require_244034__) {
      "use strict";

      function precompileGlobal(templates, opts) {
        var out = '';
        opts = opts || {};

        for (var i = 0; i < templates.length; i++) {
          var name = JSON.stringify(templates[i].name);
          var template = templates[i].template;
          out += '(function() {' + '(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})' + '[' + name + '] = (function() {\n' + template + '\n})();\n';

          if (opts.asFunction) {
            out += 'return function(ctx, cb) { return nunjucks.render(' + name + ', ctx, cb); }\n';
          }

          out += '})();\n';
        }

        return out;
      }

      module.exports = precompileGlobal;
      /***/
    },
    /* 25 */

    /***/
    function (module, exports, __nested_webpack_require_244830__) {
      function installCompat() {
        'use strict';
        /* eslint-disable camelcase */
        // This must be called like `nunjucks.installCompat` so that `this`
        // references the nunjucks instance

        var runtime = this.runtime;
        var lib = this.lib; // Handle slim case where these 'modules' are excluded from the built source

        var Compiler = this.compiler.Compiler;
        var Parser = this.parser.Parser;
        var nodes = this.nodes;
        var lexer = this.lexer;
        var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
        var orig_memberLookup = runtime.memberLookup;
        var orig_Compiler_assertType;
        var orig_Parser_parseAggregate;

        if (Compiler) {
          orig_Compiler_assertType = Compiler.prototype.assertType;
        }

        if (Parser) {
          orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
        }

        function uninstall() {
          runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
          runtime.memberLookup = orig_memberLookup;

          if (Compiler) {
            Compiler.prototype.assertType = orig_Compiler_assertType;
          }

          if (Parser) {
            Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
          }
        }

        runtime.contextOrFrameLookup = function contextOrFrameLookup(context, frame, key) {
          var val = orig_contextOrFrameLookup.apply(this, arguments);

          if (val !== undefined) {
            return val;
          }

          switch (key) {
            case 'True':
              return true;

            case 'False':
              return false;

            case 'None':
              return null;

            default:
              return undefined;
          }
        };

        function getTokensState(tokens) {
          return {
            index: tokens.index,
            lineno: tokens.lineno,
            colno: tokens.colno
          };
        }

        if ( true && nodes && Compiler && Parser) {
          // i.e., not slim mode
          var Slice = nodes.Node.extend('Slice', {
            fields: ['start', 'stop', 'step'],
            init: function init(lineno, colno, start, stop, step) {
              start = start || new nodes.Literal(lineno, colno, null);
              stop = stop || new nodes.Literal(lineno, colno, null);
              step = step || new nodes.Literal(lineno, colno, 1);
              this.parent(lineno, colno, start, stop, step);
            }
          });

          Compiler.prototype.assertType = function assertType(node) {
            if (node instanceof Slice) {
              return;
            }

            orig_Compiler_assertType.apply(this, arguments);
          };

          Compiler.prototype.compileSlice = function compileSlice(node, frame) {
            this._emit('(');

            this._compileExpression(node.start, frame);

            this._emit('),(');

            this._compileExpression(node.stop, frame);

            this._emit('),(');

            this._compileExpression(node.step, frame);

            this._emit(')');
          };

          Parser.prototype.parseAggregate = function parseAggregate() {
            var _this = this;

            var origState = getTokensState(this.tokens); // Set back one accounting for opening bracket/parens

            origState.colno--;
            origState.index--;

            try {
              return orig_Parser_parseAggregate.apply(this);
            } catch (e) {
              var errState = getTokensState(this.tokens);

              var rethrow = function rethrow() {
                lib._assign(_this.tokens, errState);

                return e;
              }; // Reset to state before original parseAggregate called


              lib._assign(this.tokens, origState);

              this.peeked = false;
              var tok = this.peekToken();

              if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
                throw rethrow();
              } else {
                this.nextToken();
              }

              var node = new Slice(tok.lineno, tok.colno); // If we don't encounter a colon while parsing, this is not a slice,
              // so re-raise the original exception.

              var isSlice = false;

              for (var i = 0; i <= node.fields.length; i++) {
                if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
                  break;
                }

                if (i === node.fields.length) {
                  if (isSlice) {
                    this.fail('parseSlice: too many slice components', tok.lineno, tok.colno);
                  } else {
                    break;
                  }
                }

                if (this.skip(lexer.TOKEN_COLON)) {
                  isSlice = true;
                } else {
                  var field = node.fields[i];
                  node[field] = this.parseExpression();
                  isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
                }
              }

              if (!isSlice) {
                throw rethrow();
              }

              return new nodes.Array(tok.lineno, tok.colno, [node]);
            }
          };
        }

        function sliceLookup(obj, start, stop, step) {
          obj = obj || [];

          if (start === null) {
            start = step < 0 ? obj.length - 1 : 0;
          }

          if (stop === null) {
            stop = step < 0 ? -1 : obj.length;
          } else if (stop < 0) {
            stop += obj.length;
          }

          if (start < 0) {
            start += obj.length;
          }

          var results = [];

          for (var i = start;; i += step) {
            if (i < 0 || i > obj.length) {
              break;
            }

            if (step > 0 && i >= stop) {
              break;
            }

            if (step < 0 && i <= stop) {
              break;
            }

            results.push(runtime.memberLookup(obj, i));
          }

          return results;
        }

        function hasOwnProp(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        }

        var ARRAY_MEMBERS = {
          pop: function pop(index) {
            if (index === undefined) {
              return this.pop();
            }

            if (index >= this.length || index < 0) {
              throw new Error('KeyError');
            }

            return this.splice(index, 1);
          },
          append: function append(element) {
            return this.push(element);
          },
          remove: function remove(element) {
            for (var i = 0; i < this.length; i++) {
              if (this[i] === element) {
                return this.splice(i, 1);
              }
            }

            throw new Error('ValueError');
          },
          count: function count(element) {
            var count = 0;

            for (var i = 0; i < this.length; i++) {
              if (this[i] === element) {
                count++;
              }
            }

            return count;
          },
          index: function index(element) {
            var i;

            if ((i = this.indexOf(element)) === -1) {
              throw new Error('ValueError');
            }

            return i;
          },
          find: function find(element) {
            return this.indexOf(element);
          },
          insert: function insert(index, elem) {
            return this.splice(index, 0, elem);
          }
        };
        var OBJECT_MEMBERS = {
          items: function items() {
            return lib._entries(this);
          },
          values: function values() {
            return lib._values(this);
          },
          keys: function keys() {
            return lib.keys(this);
          },
          get: function get(key, def) {
            var output = this[key];

            if (output === undefined) {
              output = def;
            }

            return output;
          },
          has_key: function has_key(key) {
            return hasOwnProp(this, key);
          },
          pop: function pop(key, def) {
            var output = this[key];

            if (output === undefined && def !== undefined) {
              output = def;
            } else if (output === undefined) {
              throw new Error('KeyError');
            } else {
              delete this[key];
            }

            return output;
          },
          popitem: function popitem() {
            var keys = lib.keys(this);

            if (!keys.length) {
              throw new Error('KeyError');
            }

            var k = keys[0];
            var val = this[k];
            delete this[k];
            return [k, val];
          },
          setdefault: function setdefault(key, def) {
            if (def === void 0) {
              def = null;
            }

            if (!(key in this)) {
              this[key] = def;
            }

            return this[key];
          },
          update: function update(kwargs) {
            lib._assign(this, kwargs);

            return null; // Always returns None
          }
        };
        OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
        OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
        OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;

        runtime.memberLookup = function memberLookup(obj, val, autoescape) {
          if (arguments.length === 4) {
            return sliceLookup.apply(this, arguments);
          }

          obj = obj || {}; // If the object is an object, return any of the methods that Python would
          // otherwise provide.

          if (lib.isArray(obj) && hasOwnProp(ARRAY_MEMBERS, val)) {
            return ARRAY_MEMBERS[val].bind(obj);
          }

          if (lib.isObject(obj) && hasOwnProp(OBJECT_MEMBERS, val)) {
            return OBJECT_MEMBERS[val].bind(obj);
          }

          return orig_memberLookup.apply(this, arguments);
        };

        return uninstall;
      }

      module.exports = installCompat;
      /***/
    }
    /******/
    ])
  );
});

/***/ }),

/***/ "./src/client/bridge.ts":
/*!******************************!*\
  !*** ./src/client/bridge.ts ***!
  \******************************/
/*! namespace exports */
/*! export Bridge [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bridge": () => /* binding */ Bridge
/* harmony export */ });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Bridge = function Bridge(name) {
  _classCallCheck(this, Bridge);

  _defineProperty(this, "name", void 0);

  _defineProperty(this, "methods", new Map());

  this.name = name;
};

/***/ }),

/***/ "./src/client/index.ts":
/*!*****************************!*\
  !*** ./src/client/index.ts ***!
  \*****************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.n, __webpack_exports__, __webpack_require__.r, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _bridge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bridge */ "./src/client/bridge.ts");
/* harmony import */ var _methods__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./methods */ "./src/client/methods.ts");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var Client = /*#__PURE__*/function () {
  function Client(props) {
    _classCallCheck(this, Client);

    _defineProperty(this, "props", void 0);

    _defineProperty(this, "bridgeMap", void 0);

    _defineProperty(this, "curBridgeName", void 0);

    _defineProperty(this, "curMethodsName", void 0);

    this.props = props;
    this.bridgeMap = new Map();
    this.init();
  }

  _createClass(Client, [{
    key: "init",
    value: function init() {
      var _this = this;

      var bridge = this.props.bridge;

      var handle = function handle(name) {
        _this.curBridgeName = name;

        _this.bridgeMap.set(name, new _bridge__WEBPACK_IMPORTED_MODULE_1__.Bridge(name));

        _this.handleSingleBridge(name);
      };

      if ((0,lodash__WEBPACK_IMPORTED_MODULE_0__.isArray)(bridge)) {
        bridge.forEach(function (b) {
          return handle(b);
        });
      }

      if ((0,lodash__WEBPACK_IMPORTED_MODULE_0__.isString)(bridge)) {
        handle(bridge);
      }
    }
  }, {
    key: "handleSingleBridge",
    value: function handleSingleBridge(bridge) {
      var _this2 = this;

      if (typeof bridge === 'string') {
        var bridgeMap = window[bridge];
        var keys = Object.keys(bridgeMap);
        keys.forEach(function (key) {
          if (!(0,lodash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(bridgeMap[key])) {
            return;
          }

          var curBridge = _this2.bridgeMap.get(_this2.curBridgeName);

          var method = new _methods__WEBPACK_IMPORTED_MODULE_2__.Method(key);
          curBridge.methods.set(key, method);
          var _fn = bridgeMap[key];

          var fn = function fn() {
            method.refresh(); // 

            for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
              params[_key] = arguments[_key];
            }

            _this2.interceptParams(params, method); // 


            var result = _fn.apply(_this2, params);

            method.result.set('return', result);
            return result;
          };

          method._fn = _fn;
          method.fn = fn;
          bridgeMap[key] = fn;
        });
      }
    }
  }, {
    key: "interceptParams",
    value: function interceptParams(params, method) {
      var _this3 = this;

      params.forEach(function (param, index) {
        method.props.push(param);

        if ((0,lodash__WEBPACK_IMPORTED_MODULE_0__.isFunction)(param)) {
          // 
          params[index] = function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            method.result.set("cb".concat(index), args);
            return param.apply(_this3, args);
          };
        }
      });
    }
  }]);

  return Client;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Client);

/***/ }),

/***/ "./src/client/methods.ts":
/*!*******************************!*\
  !*** ./src/client/methods.ts ***!
  \*******************************/
/*! namespace exports */
/*! export Method [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Method": () => /* binding */ Method
/* harmony export */ });
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Method = /*#__PURE__*/function () {
  function Method(name) {
    _classCallCheck(this, Method);

    _defineProperty(this, "name", void 0);

    _defineProperty(this, "_fn", void 0);

    _defineProperty(this, "fn", void 0);

    _defineProperty(this, "isCalled", false);

    _defineProperty(this, "props", []);

    _defineProperty(this, "result", new Map());

    this.name = name;
  }

  _createClass(Method, [{
    key: "refresh",
    value: function refresh() {
      this.isCalled = true;
      this.props = [];
      this.result = new Map();
    }
  }]);

  return Method;
}();

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_exports__, __webpack_require__.r, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _client_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client/index */ "./src/client/index.ts");
/* harmony import */ var _log_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log/index */ "./src/log/index.ts");
/* harmony import */ var _surface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./surface */ "./src/surface/index.ts");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var InterfaceLog = /*#__PURE__*/function () {
  function InterfaceLog(config) {
    _classCallCheck(this, InterfaceLog);

    _defineProperty(this, "_surface", void 0);

    _defineProperty(this, "_client", void 0);

    this._generateClient(config);

    this._initSurface();
  }

  _createClass(InterfaceLog, [{
    key: "printContent",
    value: function printContent() {
      var bridges = this._client.bridgeMap.values();

      return Array.from(bridges); // return this._client;
    }
  }, {
    key: "_initSurface",
    value: function _initSurface() {
      var _this = this;

      this._surface = new _surface__WEBPACK_IMPORTED_MODULE_2__.default();
      var $dom = new _log_index__WEBPACK_IMPORTED_MODULE_1__.default().getFoldedLine(this.printContent());

      this._surface.append($dom);

      this._surface.refresh(function () {
        $dom = new _log_index__WEBPACK_IMPORTED_MODULE_1__.default().getFoldedLine(_this.printContent());

        _this._surface.append($dom);
      });
    }
  }, {
    key: "_generateClient",
    value: function _generateClient(config) {
      if (this._client) return;
      this._client = new _client_index__WEBPACK_IMPORTED_MODULE_0__.default(config);
    }
  }]);

  return InterfaceLog;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InterfaceLog);

/***/ }),

/***/ "./src/log/index.ts":
/*!**************************!*\
  !*** ./src/log/index.ts ***!
  \**************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.n, __webpack_exports__, __webpack_require__.r, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var nunjucks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nunjucks */ "./node_modules/nunjucks/browser/nunjucks.js");
/* harmony import */ var nunjucks__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(nunjucks__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _flod_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./flod.html */ "./src/log/flod.html");
/* harmony import */ var _flod_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_flod_html__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _flod_code_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flod-code.html */ "./src/log/flod-code.html");
/* harmony import */ var _flod_code_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_flod_code_html__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _util_tool__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/tool */ "./src/util/tool.ts");
/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/dom */ "./src/util/dom.ts");
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index.less */ "./src/log/index.less");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }








var Log = /*#__PURE__*/function () {
  function Log() {
    _classCallCheck(this, Log);
  }

  _createClass(Log, [{
    key: "_getOuter",
    value: function _getOuter(obj) {
      var outer = '';
      var json = (0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.JSONStringify)(obj);
      var preview = json.substr(0, 36);
      outer = (0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.getObjName)(obj);

      if (json.length > 36) {
        preview += '...';
      }

      outer += ' ' + preview;
      return outer;
    }
  }, {
    key: "getFoldedLine",
    value: function getFoldedLine(obj, outer) {
      var _this = this;

      if (!outer) {
        outer = this._getOuter(obj);
      }

      var $line = (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.String2Dom)(nunjucks__WEBPACK_IMPORTED_MODULE_0__.renderString((_flod_html__WEBPACK_IMPORTED_MODULE_1___default()), {
        outer: outer,
        lineType: 'obj'
      }));
      $line.querySelector('.vc-fold-outer').addEventListener('click', function () {
        var $inner = $line.querySelector('.vc-fold-inner');
        var $outer = $line.querySelector('.vc-fold-outer');

        if ((0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.hasClass)($line, 'vc-toggle')) {
          (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.removeClass)($line, 'vc-toggle');
          (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.removeClass)($inner, 'vc-toggle');
          (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.removeClass)($outer, 'vc-toggle');
        } else {
          (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.addClass)($line, 'vc-toggle');
          (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.addClass)($inner, 'vc-toggle');
          (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.addClass)($outer, 'vc-toggle');
        }

        var $content = $inner;
        setTimeout(function () {
          if ($content.children.length > 0 || !obj) return;

          if ((0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.isMap)(obj) && (0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.isMap)(obj.__proto__)) {
            _this._renderMapKeys(obj, $content);
          } else {
            // render object's keys
            _this._renderObjectKeys(obj, $content);
          } // render object's prototype


          _this._renderPrototype(obj, $content);
        });
        return false;
      });
      return $line;
    }
  }, {
    key: "_renderObjectKeys",
    value: function _renderObjectKeys(obj, $content) {
      var _this2 = this;

      var keys = (0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.getObjAllKeys)(obj);
      keys.forEach(function (key) {
        var val;

        try {
          val = obj[key];
        } catch (e) {}

        _this2._renderFlow(obj, val, key, $content);
      });
    }
  }, {
    key: "_renderMapKeys",
    value: function _renderMapKeys(obj, $content) {
      var _this3 = this;

      obj.forEach(function (val, key) {
        _this3._renderFlow(obj, val, key, $content);
      });
    }
  }, {
    key: "_renderFlow",
    value: function _renderFlow(obj, val, key, $content) {
      var valueType = 'undefined',
          keyType = ''; // render

      var $sub;

      if ((0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.isMap)(val)) {
        $sub = this._generateMap(val, key, keyType);
      } else if ((0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.isArray)(val)) {
        $sub = this._generateArray(val, key, keyType);
      } else if ((0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.isObject)(val)) {
        $sub = this._generateObject(val, key, keyType);
      } else {
        if (obj.hasOwnProperty && !obj.hasOwnProperty(key)) {
          keyType = 'private';
        }

        $sub = this._generateNormal(val, key, valueType, keyType);
      }

      $content.insertAdjacentElement('beforeend', $sub);
    }
  }, {
    key: "_generateMap",
    value: function _generateMap(val, key, keyType) {
      var name = (0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.getObjName)(val) + '[' + val.size + ']';
      return this.getFoldedLine(val, nunjucks__WEBPACK_IMPORTED_MODULE_0__.renderString((_flod_code_html__WEBPACK_IMPORTED_MODULE_2___default()), {
        key: key,
        keyType: keyType,
        value: name,
        valueType: 'array'
      }));
    }
  }, {
    key: "_generateArray",
    value: function _generateArray(val, key, keyType) {
      var name = (0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.getObjName)(val) + '[' + val.length + ']';
      return this.getFoldedLine(val, nunjucks__WEBPACK_IMPORTED_MODULE_0__.renderString((_flod_code_html__WEBPACK_IMPORTED_MODULE_2___default()), {
        key: key,
        keyType: keyType,
        value: name,
        valueType: 'array'
      }));
    }
  }, {
    key: "_generateObject",
    value: function _generateObject(val, key, keyType) {
      var name = (0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.getObjName)(val);
      return this.getFoldedLine(val, nunjucks__WEBPACK_IMPORTED_MODULE_0__.renderString((_flod_code_html__WEBPACK_IMPORTED_MODULE_2___default()), {
        key: (0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.htmlEncode)(key),
        keyType: keyType,
        value: name,
        valueType: 'object'
      }));
    }
  }, {
    key: "_generateNormal",
    value: function _generateNormal(val, key, valueType, keyType) {
      // handle value
      if ((0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.isString)(val)) {
        valueType = 'string';
        val = '"' + val + '"';
      } else if ((0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.isNumber)(val)) {
        valueType = 'number';
      } else if ((0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.isBoolean)(val)) {
        valueType = 'boolean';
      } else if ((0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.isNull)(val)) {
        valueType = 'null';
        val = 'null';
      } else if ((0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.isUndefined)(val)) {
        valueType = 'undefined';
        val = 'undefined';
      } else if ((0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.isFunction)(val)) {
        valueType = 'function';
        val = 'function()';
      } else if ((0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.isSymbol)(val)) {
        valueType = 'symbol';
      }

      return (0,_util_dom__WEBPACK_IMPORTED_MODULE_4__.String2Dom)(nunjucks__WEBPACK_IMPORTED_MODULE_0__.renderString((_flod_html__WEBPACK_IMPORTED_MODULE_1___default()), {
        lineType: 'kv',
        key: (0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.htmlEncode)(key),
        keyType: keyType,
        value: (0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.htmlEncode)(val),
        valueType: valueType
      }));
    }
  }, {
    key: "_renderPrototype",
    value: function _renderPrototype(obj, $content) {
      // if (!isObject(obj)) return;
      var proto = obj.__proto__,
          $proto; // if (isObject(proto)) {

      $proto = this.getFoldedLine(proto, nunjucks__WEBPACK_IMPORTED_MODULE_0__.renderString((_flod_code_html__WEBPACK_IMPORTED_MODULE_2___default()), {
        key: '__proto__',
        keyType: 'private',
        value: (0,_util_tool__WEBPACK_IMPORTED_MODULE_3__.getObjName)(proto),
        valueType: 'object'
      })); // } else {
      //   // if proto is not an object, it should be `null`
      //   $proto = String2Dom(
      //     nunjucks.renderString(flodCodeTpl, {
      //       key: '__proto__',
      //       keyType: 'private',
      //       value: 'null',
      //       valueType: 'null',
      //     })
      //   );
      // }

      $content.insertAdjacentElement('beforeend', $proto);
    }
  }]);

  return Log;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Log);

/***/ }),

/***/ "./src/surface/index.ts":
/*!******************************!*\
  !*** ./src/surface/index.ts ***!
  \******************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.n, __webpack_exports__, __webpack_require__.r, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _pannel_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pannel.html */ "./src/surface/pannel.html");
/* harmony import */ var _pannel_html__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_pannel_html__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.less */ "./src/surface/index.less");
/* harmony import */ var _util_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/dom */ "./src/util/dom.ts");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var Surface = /*#__PURE__*/function () {
  function Surface() {
    _classCallCheck(this, Surface);

    _defineProperty(this, "$root", void 0);

    _defineProperty(this, "$content", void 0);

    this._render();

    this._initUnit();

    this._initEvent();
  }

  _createClass(Surface, [{
    key: "_initUnit",
    value: function _initUnit() {
      var dpr = window.devicePixelRatio || 1;
      var viewportEl = document.querySelector('[name="viewport"]');

      if (viewportEl && viewportEl.content) {
        var initialScale = viewportEl.content.match(/initial\-scale\=\d+(\.\d+)?/);
        var scale = initialScale ? parseFloat(initialScale[0].split('=')[1]) : 1;

        if (scale < 1) {
          this.$root.style.fontSize = 13 * dpr + 'px';
        }
      } else {
        (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.addDomString)(document.head, '<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">');
      }
    }
  }, {
    key: "_render",
    value: function _render() {
      this._renderGeneral();
    }
  }, {
    key: "_renderGeneral",
    value: function _renderGeneral() {
      this.$root = (0,_util_dom__WEBPACK_IMPORTED_MODULE_2__.addDomString)(document.documentElement, (_pannel_html__WEBPACK_IMPORTED_MODULE_0___default()));
      this.$content = this.$root.querySelector('.log_content');
    }
  }, {
    key: "_initEvent",
    value: function _initEvent() {
      var _this = this;

      var $root = this.$root;
      var $btn = $root.querySelector('.log_btn');
      var $panel = $root.querySelector('.log_panel');
      var $hide = $root.querySelector('.log_hide');
      var $mask = $root.querySelector('.log_mask');
      var $clear = $root.querySelector('.log_clear');
      $btn.addEventListener('click', function () {
        $panel.style.display = 'flex';
        $btn.style.display = 'none';
        $mask.style.display = 'block';
      });
      $hide.addEventListener('click', function () {
        $panel.style.display = 'none';
        $btn.style.display = 'block';
        $mask.style.display = 'none';
      });
      $clear.addEventListener('click', function () {
        _this.$content.innerHTML = '';
      });
    }
  }, {
    key: "append",
    value: function append(dom) {
      this.$content.append(dom);
    }
  }, {
    key: "refresh",
    value: function refresh(fun) {
      var _this2 = this;

      var $refresh = this.$root.querySelector('.log_refresh');
      $refresh.addEventListener('click', function () {
        _this2.$content.innerHTML = '';
        fun();
      });
    }
  }]);

  return Surface;
}();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Surface);

/***/ }),

/***/ "./src/util/dom.ts":
/*!*************************!*\
  !*** ./src/util/dom.ts ***!
  \*************************/
/*! namespace exports */
/*! export String2Dom [provided] [no usage info] [missing usage info prevents renaming] */
/*! export addClass [provided] [no usage info] [missing usage info prevents renaming] */
/*! export addDomString [provided] [no usage info] [missing usage info prevents renaming] */
/*! export hasClass [provided] [no usage info] [missing usage info prevents renaming] */
/*! export removeClass [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addDomString": () => /* binding */ addDomString,
/* harmony export */   "String2Dom": () => /* binding */ String2Dom,
/* harmony export */   "hasClass": () => /* binding */ hasClass,
/* harmony export */   "removeClass": () => /* binding */ removeClass,
/* harmony export */   "addClass": () => /* binding */ addClass
/* harmony export */ });
function addDomString(dist, tpl) {
  var dom = String2Dom(tpl);
  dist.insertAdjacentElement('beforeend', dom);
  return dom;
}
function String2Dom(tpl) {
  var e = document.createElement('div');
  e.innerHTML = tpl;
  var child = e.children;
  return child.length > 1 ? Array.from(child) : child[0];
}
function hasClass(el, className) {
  var reg = new RegExp('(^|\\s+)' + className + '($|\\s+)');
  return reg.test(el.className);
}
function removeClass(el, className) {
  return el.classList.remove(className);
}
function addClass(el, className) {
  return el.classList.add(className);
}

/***/ }),

/***/ "./src/util/tool.ts":
/*!**************************!*\
  !*** ./src/util/tool.ts ***!
  \**************************/
/*! namespace exports */
/*! export JSONStringify [provided] [no usage info] [missing usage info prevents renaming] */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getObjAllKeys [provided] [no usage info] [missing usage info prevents renaming] */
/*! export getObjName [provided] [no usage info] [missing usage info prevents renaming] */
/*! export htmlEncode [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isArray [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isBoolean [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isFunction [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isMap [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isNull [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isNumber [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isObject [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isSet [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isString [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isSymbol [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isUndefined [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isWeakMap [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isWeakSet [provided] [no usage info] [missing usage info prevents renaming] */
/*! export isWindow [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__.r, __webpack_exports__, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isNumber": () => /* binding */ isNumber,
/* harmony export */   "isString": () => /* binding */ isString,
/* harmony export */   "isArray": () => /* binding */ isArray,
/* harmony export */   "isBoolean": () => /* binding */ isBoolean,
/* harmony export */   "isUndefined": () => /* binding */ isUndefined,
/* harmony export */   "isNull": () => /* binding */ isNull,
/* harmony export */   "isSymbol": () => /* binding */ isSymbol,
/* harmony export */   "isMap": () => /* binding */ isMap,
/* harmony export */   "isWeakMap": () => /* binding */ isWeakMap,
/* harmony export */   "isSet": () => /* binding */ isSet,
/* harmony export */   "isWeakSet": () => /* binding */ isWeakSet,
/* harmony export */   "isObject": () => /* binding */ isObject,
/* harmony export */   "isFunction": () => /* binding */ isFunction,
/* harmony export */   "isWindow": () => /* binding */ isWindow,
/* harmony export */   "default": () => /* binding */ isPlainObject,
/* harmony export */   "JSONStringify": () => /* binding */ JSONStringify,
/* harmony export */   "getObjAllKeys": () => /* binding */ getObjAllKeys,
/* harmony export */   "getObjName": () => /* binding */ getObjName,
/* harmony export */   "htmlEncode": () => /* binding */ htmlEncode
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isNumber(value) {
  return Object.prototype.toString.call(value) == '[object Number]';
}
function isString(value) {
  return Object.prototype.toString.call(value) == '[object String]';
}
function isArray(value) {
  return Object.prototype.toString.call(value) == '[object Array]';
}
function isBoolean(value) {
  return Object.prototype.toString.call(value) == '[object Boolean]';
}
function isUndefined(value) {
  return value === undefined;
}
function isNull(value) {
  return value === null;
}
function isSymbol(value) {
  return Object.prototype.toString.call(value) == '[object Symbol]';
}
function isMap(value) {
  return Object.prototype.toString.call(value) == '[object Map]';
}
function isWeakMap(value) {
  return Object.prototype.toString.call(value) == '[object WeakMap]';
}
function isSet(value) {
  return Object.prototype.toString.call(value) == '[object Set]';
}
function isWeakSet(value) {
  return Object.prototype.toString.call(value) == '[object WeakSet]';
}
function isObject(value) {
  return Object.prototype.toString.call(value) == '[object Object]' || // if it isn't a primitive value, then it is a common object
  !isNumber(value) && !isString(value) && !isBoolean(value) && !isArray(value) && !isNull(value) && !isFunction(value) && !isUndefined(value) && !isSymbol(value) && !isMap(value) && !isWeakMap(value) && !isSet(value) && !isWeakSet(value);
}
function isFunction(value) {
  return Object.prototype.toString.call(value) == '[object Function]';
}
function isWindow(value) {
  var toString = Object.prototype.toString.call(value);
  return toString == '[object global]' || toString == '[object Window]' || toString == '[object DOMWindow]';
}
/**
 * Object.create
 * @param obj
 */

function isPlainObject(obj) {
  if (_typeof(obj) !== 'object' || obj === null) {
    return false;
  }

  if (Object.getPrototypeOf(obj) === null) {
    return true;
  }

  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}
/**
 * Simple JSON stringify, stringify top level key-value
 */

function JSONStringify(stringObject) {
  if (!isObject(stringObject) && !isArray(stringObject)) {
    return JSON.stringify(stringObject);
  }

  var prefix = '{',
      suffix = '}';

  if (isArray(stringObject)) {
    prefix = '[';
    suffix = ']';
  }

  var str = prefix;
  var keys = getObjAllKeys(stringObject);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = stringObject[key];

    try {
      // key
      if (!isArray(stringObject)) {
        if (isObject(key) || isArray(key) || isSymbol(key)) {
          str += Object.prototype.toString.call(key);
        } else {
          str += key;
        }

        str += ': ';
      } // value


      if (isArray(value)) {
        str += 'Array[' + value.length + ']';
      } else if (isObject(value) || isSymbol(value) || isFunction(value)) {
        str += Object.prototype.toString.call(value);
      } else {
        str += JSON.stringify(value);
      }

      if (i < keys.length - 1) {
        str += ', ';
      }
    } catch (e) {
      continue;
    }
  }

  str += suffix;
  return str;
}
/**
 * get an object's all keys ignore whether they are not enumerable
 */

function getObjAllKeys(obj) {
  // if (!isObject(obj) && !isArray(obj)) {
  //   return [];
  // }
  // if (isArray(obj)) {
  //   const m = [];
  //   obj.forEach((_, index) => {
  //     m.push(index);
  //   });
  //   return m;
  // }
  return Object.getOwnPropertyNames(obj).sort();
}
/**
 * get an object's prototype name
 */

function getObjName(obj) {
  return Object.prototype.toString.call(obj).replace('[object ', '').replace(']', '');
}
function htmlEncode(text) {
  return document.createElement('a').appendChild(document.createTextNode(text)).parentNode.innerHTML;
}

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/log/index.less":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/log/index.less ***!
  \*********************************************************************************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.n, __webpack_exports__, __webpack_require__.r, module.id, __webpack_require__.d, __webpack_require__.*, module */
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".vc-fold-outer {\n  display: block;\n  font-style: italic;\n  padding-left: 0.76923077em;\n  position: relative;\n}\n.vc-fold-outer:before {\n  content: '';\n  position: absolute;\n  top: 0.30769231em;\n  left: 0.15384615em;\n  width: 0;\n  height: 0;\n  border: transparent solid 0.30769231em;\n  border-left-color: var(--VC-FG-1);\n}\n.vc-fold-outer.vc-toggle:before {\n  top: 0.46153846em;\n  left: 0;\n  border-top-color: var(--VC-FG-1);\n  border-left-color: transparent;\n}\n.vc-fold-inner {\n  display: none;\n  margin-left: 0.76923077em;\n}\n.vc-fold-inner.vc-toggle {\n  display: block;\n}\n.vc-code-key {\n  color: #e36eec;\n  font-style: normal;\n  margin-left: 0.76923077em;\n}\n", "",{"version":3,"sources":["webpack://./src/log/index.less"],"names":[],"mappings":"AAAA;EACE,cAAA;EACA,kBAAA;EACA,0BAAA;EACA,kBAAA;AACF;AAAE;EACE,WAAA;EACA,kBAAA;EACA,iBAAA;EACA,kBAAA;EACA,QAAA;EACA,SAAA;EACA,sCAAA;EACA,iCAAA;AAEJ;AACI;EACE,iBAAA;EACA,OAAA;EACA,gCAAA;EACA,8BAAA;AACN;AAGA;EACE,aAAA;EAIA,yBAAA;AAJF;AACE;EACE,cAAA;AACJ;AAGA;EACE,cAAA;EACA,kBAAA;EACA,yBAAA;AADF","sourcesContent":[".vc-fold-outer {\n  display: block;\n  font-style: italic;\n  padding-left: 0.76923077em;\n  position: relative;\n  &:before {\n    content: '';\n    position: absolute;\n    top: 0.30769231em;\n    left: 0.15384615em;\n    width: 0;\n    height: 0;\n    border: transparent solid 0.30769231em;\n    border-left-color: var(--VC-FG-1);\n  }\n  &.vc-toggle {\n    &:before {\n      top: 0.46153846em;\n      left: 0;\n      border-top-color: var(--VC-FG-1);\n      border-left-color: transparent;\n    }\n  }\n}\n.vc-fold-inner {\n  display: none;\n  &.vc-toggle {\n    display: block;\n  }\n  margin-left: 0.76923077em;\n}\n.vc-code-key {\n  color: #e36eec;\n  font-style: normal;\n  margin-left: 0.76923077em;\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/surface/index.less":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/surface/index.less ***!
  \*************************************************************************************************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.n, __webpack_exports__, __webpack_require__.r, module.id, __webpack_require__.d, __webpack_require__.*, module */
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ "./node_modules/css-loader/dist/runtime/cssWithMappingToString.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".log {\n  font-size: 12px;\n}\n.log .log_btn {\n  position: fixed;\n  top: 50%;\n  right: 0;\n  line-height: 1;\n  z-index: 10000;\n  border-radius: 10%;\n  padding: 0.3em 0.5em;\n  box-shadow: 0 0 0.61538462em rgba(0, 0, 0, 0.4);\n  border: none;\n  font-size: 1.5em;\n  display: block;\n}\n.log .log_panel {\n  display: flex;\n  flex-flow: column nowrap;\n  position: fixed;\n  width: 100%;\n  height: 70%;\n  bottom: 0;\n  border: 1px solid #eee;\n  border-top-left-radius: 1%;\n  border-top-right-radius: 1%;\n  display: none;\n  background: #fff;\n  z-index: 2000;\n}\n.log .log_panel .log_content {\n  flex: 1;\n  overflow-y: auto;\n  padding: 0.3em;\n}\n.log .log_panel .log_tool {\n  display: flex;\n}\n.log .log_panel .log_tool .log_op {\n  flex: 1;\n  padding: 0.5em 0;\n  line-height: 1;\n  text-align: center;\n  font-size: 1.5em;\n}\n.log .log_panel .log_tool .log_hide {\n  background: rgba(139, 110, 110, 0.76);\n}\n.log .log_panel .log_tool .log_clear {\n  background: rgba(105, 87, 87, 0.301);\n}\n.log .log_panel .log_tool .log_refresh {\n  background: #eee;\n}\n.log .log_mask {\n  position: fixed;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  display: none;\n  z-index: 1000;\n  background: rgba(0, 0, 0, 0.1);\n}\n", "",{"version":3,"sources":["webpack://./src/surface/index.less"],"names":[],"mappings":"AAAA;EACE,eAAA;AACF;AAFA;EAII,eAAA;EACA,QAAA;EACA,QAAA;EACA,cAAA;EACA,cAAA;EACA,kBAAA;EACA,oBAAA;EACA,+CAAA;EACA,YAAA;EACA,gBAAA;EACA,cAAA;AACJ;AAfA;EAiBI,aAAA;EACA,wBAAA;EACA,eAAA;EACA,WAAA;EACA,WAAA;EACA,SAAA;EACA,sBAAA;EACA,0BAAA;EACA,2BAAA;EACA,aAAA;EACA,gBAAA;EACA,aAAA;AACJ;AA7BA;EA8BM,OAAA;EACA,gBAAA;EACA,cAAA;AAEN;AAlCA;EAmCM,aAAA;AAEN;AArCA;EAqCQ,OAAA;EACA,gBAAA;EACA,cAAA;EACA,kBAAA;EACA,gBAAA;AAGR;AA5CA;EA4CQ,qCAAA;AAGR;AA/CA;EA+CQ,oCAAA;AAGR;AAlDA;EAkDQ,gBAAA;AAGR;AArDA;EAuDI,eAAA;EACA,WAAA;EACA,YAAA;EACA,MAAA;EACA,OAAA;EACA,aAAA;EACA,aAAA;EACA,8BAAA;AACJ","sourcesContent":[".log {\n  font-size: 12px;\n  .log_btn {\n    display: block;\n    position: fixed;\n    top: 50%;\n    right: 0;\n    line-height: 1;\n    z-index: 10000;\n    border-radius: 10%;\n    padding: 0.3em 0.5em;\n    box-shadow: 0 0 0.61538462em rgba(0, 0, 0, 0.4);\n    border: none;\n    font-size: 1.5em;\n    display: block;\n  }\n  .log_panel {\n    display: flex;\n    flex-flow: column nowrap;\n    position: fixed;\n    width: 100%;\n    height: 70%;\n    bottom: 0;\n    border: 1px solid #eee;\n    border-top-left-radius: 1%;\n    border-top-right-radius: 1%;\n    display: none;\n    background: #fff;\n    z-index: 2000;\n    .log_content {\n      flex: 1;\n      overflow-y: auto;\n      padding: 0.3em;\n    }\n    .log_tool {\n      display: flex;\n      .log_op {\n        flex: 1;\n        padding: 0.5em 0;\n        line-height: 1;\n        text-align: center;\n        font-size: 1.5em;\n      }\n      .log_hide {\n        background: rgba(139, 110, 110, 0.76);\n      }\n      .log_clear {\n        background: rgba(105, 87, 87, 0.301);\n      }\n      .log_refresh {\n        background: #eee;\n      }\n    }\n  }\n  .log_mask {\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    display: none;\n    z-index: 1000;\n    background: rgba(0, 0, 0, 0.1);\n  }\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./src/log/flod-code.html":
/*!********************************!*\
  !*** ./src/log/flod-code.html ***!
  \********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 4:0-14 */
/***/ ((module) => {

// Module
var code = "<span>\n  <i class=\"vc-code-key{% if keyType %} vc-code-{{keyType}}-key{% endif %}\"\n    >{{key}}</i\n  >: <i class=\"vc-code-{{valueType}}\">{{value}}</i>\n</span>\n";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/log/flod.html":
/*!***************************!*\
  !*** ./src/log/flod.html ***!
  \***************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 4:0-14 */
/***/ ((module) => {

// Module
var code = "<div class=\"vc-fold\">\n  {% if lineType == 'obj' %}\n  <i class=\"vc-fold-outer\">{{outer|safe}}</i>\n  <div class=\"vc-fold-inner\"></div>\n  {% elif lineType == 'value' %}\n  <i class=\"vc-code-{{valueType}}\">{{value}}</i>\n  {% elif lineType == 'kv' %}\n  <i class=\"vc-code-key{% if keyType %} vc-code-{{keyType}}-key{% endif %}\"\n    >{{key}}</i\n  >: <i class=\"vc-code-{{valueType}}\">{{value}}</i>\n  {% endif %}\n</div>\n";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/surface/pannel.html":
/*!*********************************!*\
  !*** ./src/surface/pannel.html ***!
  \*********************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 4:0-14 */
/***/ ((module) => {

// Module
var code = "<div class=\"log\">\n  <button class=\"log_btn\">check</button>\n  <div class=\"log_panel\">\n    <div class=\"log_content\"></div>\n    <div class=\"log_tool\">\n      <div class=\"log_hide log_op\">hide</div>\n      <div class=\"log_clear log_op\">clear</div>\n      <div class=\"log_refresh log_op\">refresh</div>\n    </div>\n  </div>\n  <div class=\"log_mask\"></div>\n</div>\n";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/log/index.less":
/*!****************************!*\
  !*** ./src/log/index.less ***!
  \****************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.n, __webpack_exports__, __webpack_require__.r, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/log/index.less");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_index_less__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_index_less__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ }),

/***/ "./src/surface/index.less":
/*!********************************!*\
  !*** ./src/surface/index.less ***!
  \********************************/
/*! namespace exports */
/*! export default [provided] [no usage info] [missing usage info prevents renaming] */
/*! other exports [not provided] [no usage info] */
/*! runtime requirements: __webpack_require__, __webpack_require__.n, __webpack_exports__, __webpack_require__.r, __webpack_require__.d, __webpack_require__.* */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => __WEBPACK_DEFAULT_EXPORT__
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/surface/index.less");

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_index_less__WEBPACK_IMPORTED_MODULE_1__.default, options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_less_loader_dist_cjs_js_index_less__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module, __webpack_require__.nc, __webpack_require__.* */
/*! CommonJS bailout: module.exports is used directly at 230:0-14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./src/index.ts");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbG9kYXNoLmpzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi4vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi4vd2VicGFjay9ib290c3RyYXAgNWU4MDMxMmY4ZWZmMjIwMTRmNWEiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uLi9udW5qdWNrcy9zcmMvbGliLmpzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi4vbnVuanVja3Mvc3JjL29iamVjdC5qcyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4uL251bmp1Y2tzL3NyYy9ydW50aW1lLmpzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi4vbnVuanVja3Mvc3JjL25vZGVzLmpzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi4vbnVuanVja3Mvc3JjL2NvbXBpbGVyLmpzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi4vbnVuanVja3Mvc3JjL2xvYWRlci5qcyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4uL251bmp1Y2tzL3NyYy9lbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4uL251bmp1Y2tzL3NyYy9wYXJzZXIuanMiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uLi9udW5qdWNrcy9zcmMvbGV4ZXIuanMiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uLi9udW5qdWNrcy9zcmMvd2ViLWxvYWRlcnMuanMiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uLi9udW5qdWNrcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4uL25vZGVfbW9kdWxlcy9hc2FwL2Jyb3dzZXItYXNhcC5qcyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4uL25vZGVfbW9kdWxlcy9hc2FwL2Jyb3dzZXItcmF3LmpzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uLi9ub2RlX21vZHVsZXMvYS1zeW5jLXdhdGVyZmFsbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4uL25vZGVfbW9kdWxlcy93ZWJwYWNrL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi4vbnVuanVja3Mvc3JjL3RyYW5zZm9ybWVyLmpzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi4vbnVuanVja3Mvc3JjL2ZpbHRlcnMuanMiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uLi9udW5qdWNrcy9zcmMvcHJlY29tcGlsZWQtbG9hZGVyLmpzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi4vbnVuanVja3Mvc3JjL3Rlc3RzLmpzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi4vbnVuanVja3Mvc3JjL2dsb2JhbHMuanMiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uLi9udW5qdWNrcy9zcmMvZXhwcmVzcy1hcHAuanMiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uLi9udW5qdWNrcy9zcmMvcHJlY29tcGlsZS5qcyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4uL251bmp1Y2tzL3NyYy9wcmVjb21waWxlLWdsb2JhbC5qcyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4uL251bmp1Y2tzL3NyYy9qaW5qYS1jb21wYXQuanMiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uL3NyYy9jbGllbnQvYnJpZGdlLnRzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi9zcmMvY2xpZW50L2luZGV4LnRzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi9zcmMvY2xpZW50L21ldGhvZHMudHMiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4vc3JjL2xvZy9pbmRleC50cyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4vc3JjL3N1cmZhY2UvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uL3NyYy91dGlsL2RvbS50cyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4vc3JjL3V0aWwvdG9vbC50cyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4vc3JjL2xvZy9pbmRleC5sZXNzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi9zcmMvc3VyZmFjZS9pbmRleC5sZXNzIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi9zcmMvbG9nL2Zsb2QtY29kZS5odG1sIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi9zcmMvbG9nL2Zsb2QuaHRtbCIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nLy4vc3JjL3N1cmZhY2UvcGFubmVsLmh0bWwiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uL3NyYy9sb2cvaW5kZXgubGVzcz82NmZkIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvLi9zcmMvc3VyZmFjZS9pbmRleC5sZXNzP2QyM2EiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9pbnRlcmZhY2UtbG9nL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vaW50ZXJmYWNlLWxvZy93ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yIiwid2VicGFjazovL2ludGVyZmFjZS1sb2cvd2VicGFjay9zdGFydHVwIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwibGlzdCIsInRvU3RyaW5nIiwibWFwIiwiaXRlbSIsImNvbnRlbnQiLCJjb25jYXQiLCJqb2luIiwiaSIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiZGVkdXBlIiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImxlbmd0aCIsImlkIiwiX2kiLCJwdXNoIiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsIk9iamVjdCIsInByb3RvdHlwZSIsImNhbGwiLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsIkFycmF5IiwiZnJvbSIsInRlc3QiLCJsZW4iLCJhcnIyIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwidW5kZWZpbmVkIiwiX3MiLCJuZXh0IiwiZG9uZSIsInZhbHVlIiwiZXJyIiwiaXNBcnJheSIsIl9pdGVtIiwiY3NzTWFwcGluZyIsImJ0b2EiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIiwic291cmNlTWFwcGluZyIsInNvdXJjZVVSTHMiLCJzb3VyY2VzIiwic291cmNlIiwic291cmNlUm9vdCIsIlZFUlNJT04iLCJMQVJHRV9BUlJBWV9TSVpFIiwiQ09SRV9FUlJPUl9URVhUIiwiRlVOQ19FUlJPUl9URVhUIiwiSEFTSF9VTkRFRklORUQiLCJNQVhfTUVNT0laRV9TSVpFIiwiUExBQ0VIT0xERVIiLCJDTE9ORV9ERUVQX0ZMQUciLCJDTE9ORV9GTEFUX0ZMQUciLCJDTE9ORV9TWU1CT0xTX0ZMQUciLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJXUkFQX0JJTkRfRkxBRyIsIldSQVBfQklORF9LRVlfRkxBRyIsIldSQVBfQ1VSUllfQk9VTkRfRkxBRyIsIldSQVBfQ1VSUllfRkxBRyIsIldSQVBfQ1VSUllfUklHSFRfRkxBRyIsIldSQVBfUEFSVElBTF9GTEFHIiwiV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUciLCJXUkFQX0FSWV9GTEFHIiwiV1JBUF9SRUFSR19GTEFHIiwiV1JBUF9GTElQX0ZMQUciLCJERUZBVUxUX1RSVU5DX0xFTkdUSCIsIkRFRkFVTFRfVFJVTkNfT01JU1NJT04iLCJIT1RfQ09VTlQiLCJIT1RfU1BBTiIsIkxBWllfRklMVEVSX0ZMQUciLCJMQVpZX01BUF9GTEFHIiwiTEFaWV9XSElMRV9GTEFHIiwiSU5GSU5JVFkiLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUFYX0lOVEVHRVIiLCJOQU4iLCJNQVhfQVJSQVlfTEVOR1RIIiwiTUFYX0FSUkFZX0lOREVYIiwiSEFMRl9NQVhfQVJSQVlfTEVOR1RIIiwid3JhcEZsYWdzIiwiYXJnc1RhZyIsImFycmF5VGFnIiwiYXN5bmNUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImRvbUV4Y1RhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm51bGxUYWciLCJvYmplY3RUYWciLCJwcm9taXNlVGFnIiwicHJveHlUYWciLCJyZWdleHBUYWciLCJzZXRUYWciLCJzdHJpbmdUYWciLCJzeW1ib2xUYWciLCJ1bmRlZmluZWRUYWciLCJ3ZWFrTWFwVGFnIiwid2Vha1NldFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJyZUVtcHR5U3RyaW5nTGVhZGluZyIsInJlRW1wdHlTdHJpbmdNaWRkbGUiLCJyZUVtcHR5U3RyaW5nVHJhaWxpbmciLCJyZUVzY2FwZWRIdG1sIiwicmVVbmVzY2FwZWRIdG1sIiwicmVIYXNFc2NhcGVkSHRtbCIsIlJlZ0V4cCIsInJlSGFzVW5lc2NhcGVkSHRtbCIsInJlRXNjYXBlIiwicmVFdmFsdWF0ZSIsInJlSW50ZXJwb2xhdGUiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwicmVQcm9wTmFtZSIsInJlUmVnRXhwQ2hhciIsInJlSGFzUmVnRXhwQ2hhciIsInJlVHJpbSIsInJlVHJpbVN0YXJ0IiwicmVUcmltRW5kIiwicmVXcmFwQ29tbWVudCIsInJlV3JhcERldGFpbHMiLCJyZVNwbGl0RGV0YWlscyIsInJlQXNjaWlXb3JkIiwicmVFc2NhcGVDaGFyIiwicmVFc1RlbXBsYXRlIiwicmVGbGFncyIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc0hvc3RDdG9yIiwicmVJc09jdGFsIiwicmVJc1VpbnQiLCJyZUxhdGluIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJyc0FzdHJhbFJhbmdlIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNDb21ib1JhbmdlIiwicnNEaW5nYmF0UmFuZ2UiLCJyc0xvd2VyUmFuZ2UiLCJyc01hdGhPcFJhbmdlIiwicnNOb25DaGFyUmFuZ2UiLCJyc1B1bmN0dWF0aW9uUmFuZ2UiLCJyc1NwYWNlUmFuZ2UiLCJyc1VwcGVyUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNCcmVha1JhbmdlIiwicnNBcG9zIiwicnNBc3RyYWwiLCJyc0JyZWFrIiwicnNDb21ibyIsInJzRGlnaXRzIiwicnNEaW5nYmF0IiwicnNMb3dlciIsInJzTWlzYyIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicnNVcHBlciIsInJzWldKIiwicnNNaXNjTG93ZXIiLCJyc01pc2NVcHBlciIsInJzT3B0Q29udHJMb3dlciIsInJzT3B0Q29udHJVcHBlciIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc09yZExvd2VyIiwicnNPcmRVcHBlciIsInJzU2VxIiwicnNFbW9qaSIsInJzU3ltYm9sIiwicmVBcG9zIiwicmVDb21ib01hcmsiLCJyZVVuaWNvZGUiLCJyZVVuaWNvZGVXb3JkIiwicmVIYXNVbmljb2RlIiwicmVIYXNVbmljb2RlV29yZCIsImNvbnRleHRQcm9wcyIsInRlbXBsYXRlQ291bnRlciIsInR5cGVkQXJyYXlUYWdzIiwiY2xvbmVhYmxlVGFncyIsImRlYnVycmVkTGV0dGVycyIsImh0bWxFc2NhcGVzIiwiaHRtbFVuZXNjYXBlcyIsInN0cmluZ0VzY2FwZXMiLCJmcmVlUGFyc2VGbG9hdCIsInBhcnNlRmxvYXQiLCJmcmVlUGFyc2VJbnQiLCJwYXJzZUludCIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJmcmVlU2VsZiIsInNlbGYiLCJyb290IiwiRnVuY3Rpb24iLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJmcmVlUHJvY2VzcyIsInByb2Nlc3MiLCJub2RlVXRpbCIsInR5cGVzIiwicmVxdWlyZSIsImJpbmRpbmciLCJlIiwibm9kZUlzQXJyYXlCdWZmZXIiLCJpc0FycmF5QnVmZmVyIiwibm9kZUlzRGF0ZSIsImlzRGF0ZSIsIm5vZGVJc01hcCIsImlzTWFwIiwibm9kZUlzUmVnRXhwIiwiaXNSZWdFeHAiLCJub2RlSXNTZXQiLCJpc1NldCIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJhcHBseSIsImZ1bmMiLCJ0aGlzQXJnIiwiYXJncyIsImFycmF5QWdncmVnYXRvciIsImFycmF5Iiwic2V0dGVyIiwiaXRlcmF0ZWUiLCJhY2N1bXVsYXRvciIsImluZGV4IiwiYXJyYXlFYWNoIiwiYXJyYXlFYWNoUmlnaHQiLCJhcnJheUV2ZXJ5IiwicHJlZGljYXRlIiwiYXJyYXlGaWx0ZXIiLCJyZXNJbmRleCIsInJlc3VsdCIsImFycmF5SW5jbHVkZXMiLCJiYXNlSW5kZXhPZiIsImFycmF5SW5jbHVkZXNXaXRoIiwiY29tcGFyYXRvciIsImFycmF5TWFwIiwiYXJyYXlQdXNoIiwidmFsdWVzIiwib2Zmc2V0IiwiYXJyYXlSZWR1Y2UiLCJpbml0QWNjdW0iLCJhcnJheVJlZHVjZVJpZ2h0IiwiYXJyYXlTb21lIiwiYXNjaWlTaXplIiwiYmFzZVByb3BlcnR5IiwiYXNjaWlUb0FycmF5Iiwic3RyaW5nIiwic3BsaXQiLCJhc2NpaVdvcmRzIiwibWF0Y2giLCJiYXNlRmluZEtleSIsImNvbGxlY3Rpb24iLCJlYWNoRnVuYyIsImtleSIsImJhc2VGaW5kSW5kZXgiLCJmcm9tSW5kZXgiLCJmcm9tUmlnaHQiLCJzdHJpY3RJbmRleE9mIiwiYmFzZUlzTmFOIiwiYmFzZUluZGV4T2ZXaXRoIiwiYmFzZU1lYW4iLCJiYXNlU3VtIiwib2JqZWN0IiwiYmFzZVByb3BlcnR5T2YiLCJiYXNlUmVkdWNlIiwiYmFzZVNvcnRCeSIsImNvbXBhcmVyIiwic29ydCIsImN1cnJlbnQiLCJiYXNlVGltZXMiLCJiYXNlVG9QYWlycyIsInByb3BzIiwiYmFzZVVuYXJ5IiwiYmFzZVZhbHVlcyIsImNhY2hlSGFzIiwiY2FjaGUiLCJoYXMiLCJjaGFyc1N0YXJ0SW5kZXgiLCJzdHJTeW1ib2xzIiwiY2hyU3ltYm9scyIsImNoYXJzRW5kSW5kZXgiLCJjb3VudEhvbGRlcnMiLCJwbGFjZWhvbGRlciIsImRlYnVyckxldHRlciIsImVzY2FwZUh0bWxDaGFyIiwiZXNjYXBlU3RyaW5nQ2hhciIsImNociIsImdldFZhbHVlIiwiaGFzVW5pY29kZSIsImhhc1VuaWNvZGVXb3JkIiwiaXRlcmF0b3JUb0FycmF5IiwibWFwVG9BcnJheSIsInNpemUiLCJmb3JFYWNoIiwib3ZlckFyZyIsInRyYW5zZm9ybSIsImFyZyIsInJlcGxhY2VIb2xkZXJzIiwic2V0VG9BcnJheSIsInNldCIsInNldFRvUGFpcnMiLCJzdHJpY3RMYXN0SW5kZXhPZiIsInN0cmluZ1NpemUiLCJ1bmljb2RlU2l6ZSIsInN0cmluZ1RvQXJyYXkiLCJ1bmljb2RlVG9BcnJheSIsInVuZXNjYXBlSHRtbENoYXIiLCJsYXN0SW5kZXgiLCJ1bmljb2RlV29yZHMiLCJydW5JbkNvbnRleHQiLCJjb250ZXh0IiwiXyIsImRlZmF1bHRzIiwicGljayIsIkRhdGUiLCJFcnJvciIsIk1hdGgiLCJTdHJpbmciLCJhcnJheVByb3RvIiwiZnVuY1Byb3RvIiwib2JqZWN0UHJvdG8iLCJjb3JlSnNEYXRhIiwiZnVuY1RvU3RyaW5nIiwiaGFzT3duUHJvcGVydHkiLCJpZENvdW50ZXIiLCJtYXNrU3JjS2V5IiwidWlkIiwiZXhlYyIsImtleXMiLCJJRV9QUk9UTyIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwib2JqZWN0Q3RvclN0cmluZyIsIm9sZERhc2giLCJyZUlzTmF0aXZlIiwicmVwbGFjZSIsIkJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJhbGxvY1Vuc2FmZSIsImdldFByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwib2JqZWN0Q3JlYXRlIiwiY3JlYXRlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzcGxpY2UiLCJzcHJlYWRhYmxlU3ltYm9sIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwic3ltSXRlcmF0b3IiLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiZGVmaW5lUHJvcGVydHkiLCJnZXROYXRpdmUiLCJjdHhDbGVhclRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJjdHhOb3ciLCJub3ciLCJjdHhTZXRUaW1lb3V0Iiwic2V0VGltZW91dCIsIm5hdGl2ZUNlaWwiLCJjZWlsIiwibmF0aXZlRmxvb3IiLCJmbG9vciIsIm5hdGl2ZUdldFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwibmF0aXZlSXNGaW5pdGUiLCJpc0Zpbml0ZSIsIm5hdGl2ZUpvaW4iLCJuYXRpdmVLZXlzIiwibmF0aXZlTWF4IiwibWF4IiwibmF0aXZlTWluIiwibWluIiwibmF0aXZlTm93IiwibmF0aXZlUGFyc2VJbnQiLCJuYXRpdmVSYW5kb20iLCJyYW5kb20iLCJuYXRpdmVSZXZlcnNlIiwicmV2ZXJzZSIsIkRhdGFWaWV3IiwiTWFwIiwiUHJvbWlzZSIsIlNldCIsIldlYWtNYXAiLCJuYXRpdmVDcmVhdGUiLCJtZXRhTWFwIiwicmVhbE5hbWVzIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwidG9Tb3VyY2UiLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJzeW1ib2xQcm90byIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwic3ltYm9sVG9TdHJpbmciLCJsb2Rhc2giLCJpc09iamVjdExpa2UiLCJMYXp5V3JhcHBlciIsIkxvZGFzaFdyYXBwZXIiLCJ3cmFwcGVyQ2xvbmUiLCJiYXNlQ3JlYXRlIiwicHJvdG8iLCJpc09iamVjdCIsImJhc2VMb2Rhc2giLCJjaGFpbkFsbCIsIl9fd3JhcHBlZF9fIiwiX19hY3Rpb25zX18iLCJfX2NoYWluX18iLCJfX2luZGV4X18iLCJfX3ZhbHVlc19fIiwidGVtcGxhdGVTZXR0aW5ncyIsIl9fZGlyX18iLCJfX2ZpbHRlcmVkX18iLCJfX2l0ZXJhdGVlc19fIiwiX190YWtlQ291bnRfXyIsIl9fdmlld3NfXyIsImxhenlDbG9uZSIsImNvcHlBcnJheSIsImxhenlSZXZlcnNlIiwiY2xvbmUiLCJsYXp5VmFsdWUiLCJkaXIiLCJpc0FyciIsImlzUmlnaHQiLCJhcnJMZW5ndGgiLCJ2aWV3IiwiZ2V0VmlldyIsInN0YXJ0IiwiZW5kIiwiaXRlcmF0ZWVzIiwiaXRlckxlbmd0aCIsInRha2VDb3VudCIsImJhc2VXcmFwcGVyVmFsdWUiLCJvdXRlciIsIml0ZXJJbmRleCIsInR5cGUiLCJjb21wdXRlZCIsIkhhc2giLCJlbnRyaWVzIiwiY2xlYXIiLCJlbnRyeSIsImhhc2hDbGVhciIsIl9fZGF0YV9fIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsImdldCIsIkxpc3RDYWNoZSIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwiYXNzb2NJbmRleE9mIiwicG9wIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJnZXRNYXBEYXRhIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiU2V0Q2FjaGUiLCJhZGQiLCJzZXRDYWNoZUFkZCIsInNldENhY2hlSGFzIiwiU3RhY2siLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJwYWlycyIsImFycmF5TGlrZUtleXMiLCJpbmhlcml0ZWQiLCJpc0FyZyIsImlzQXJndW1lbnRzIiwiaXNCdWZmIiwiaXNUeXBlIiwic2tpcEluZGV4ZXMiLCJpc0luZGV4IiwiYXJyYXlTYW1wbGUiLCJiYXNlUmFuZG9tIiwiYXJyYXlTYW1wbGVTaXplIiwic2h1ZmZsZVNlbGYiLCJiYXNlQ2xhbXAiLCJhcnJheVNodWZmbGUiLCJhc3NpZ25NZXJnZVZhbHVlIiwiZXEiLCJiYXNlQXNzaWduVmFsdWUiLCJhc3NpZ25WYWx1ZSIsIm9ialZhbHVlIiwiYmFzZUFnZ3JlZ2F0b3IiLCJiYXNlRWFjaCIsImJhc2VBc3NpZ24iLCJjb3B5T2JqZWN0IiwiYmFzZUFzc2lnbkluIiwia2V5c0luIiwiYmFzZUF0IiwicGF0aHMiLCJza2lwIiwibnVtYmVyIiwibG93ZXIiLCJ1cHBlciIsImJhc2VDbG9uZSIsImJpdG1hc2siLCJjdXN0b21pemVyIiwic3RhY2siLCJpc0RlZXAiLCJpc0ZsYXQiLCJpc0Z1bGwiLCJpbml0Q2xvbmVBcnJheSIsInRhZyIsImdldFRhZyIsImlzRnVuYyIsImNsb25lQnVmZmVyIiwiaW5pdENsb25lT2JqZWN0IiwiY29weVN5bWJvbHNJbiIsImNvcHlTeW1ib2xzIiwiaW5pdENsb25lQnlUYWciLCJzdGFja2VkIiwic3ViVmFsdWUiLCJrZXlzRnVuYyIsImdldEFsbEtleXNJbiIsImdldEFsbEtleXMiLCJiYXNlQ29uZm9ybXMiLCJiYXNlQ29uZm9ybXNUbyIsImJhc2VEZWxheSIsIndhaXQiLCJiYXNlRGlmZmVyZW5jZSIsImluY2x1ZGVzIiwiaXNDb21tb24iLCJ2YWx1ZXNMZW5ndGgiLCJ2YWx1ZXNJbmRleCIsImNyZWF0ZUJhc2VFYWNoIiwiYmFzZUZvck93biIsImJhc2VFYWNoUmlnaHQiLCJiYXNlRm9yT3duUmlnaHQiLCJiYXNlRXZlcnkiLCJiYXNlRXh0cmVtdW0iLCJpc1N5bWJvbCIsImJhc2VGaWxsIiwidG9JbnRlZ2VyIiwidG9MZW5ndGgiLCJiYXNlRmlsdGVyIiwiYmFzZUZsYXR0ZW4iLCJkZXB0aCIsImlzU3RyaWN0IiwiaXNGbGF0dGVuYWJsZSIsImJhc2VGb3IiLCJjcmVhdGVCYXNlRm9yIiwiYmFzZUZvclJpZ2h0IiwiYmFzZUZ1bmN0aW9ucyIsImlzRnVuY3Rpb24iLCJiYXNlR2V0IiwicGF0aCIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0QWxsS2V5cyIsInN5bWJvbHNGdW5jIiwiYmFzZUdldFRhZyIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwiYmFzZUd0Iiwib3RoZXIiLCJiYXNlSGFzIiwiYmFzZUhhc0luIiwiYmFzZUluUmFuZ2UiLCJiYXNlSW50ZXJzZWN0aW9uIiwiYXJyYXlzIiwib3RoTGVuZ3RoIiwib3RoSW5kZXgiLCJjYWNoZXMiLCJtYXhMZW5ndGgiLCJJbmZpbml0eSIsInNlZW4iLCJiYXNlSW52ZXJ0ZXIiLCJiYXNlSW52b2tlIiwicGFyZW50IiwibGFzdCIsImJhc2VJc0FyZ3VtZW50cyIsImJhc2VJc0FycmF5QnVmZmVyIiwiYmFzZUlzRGF0ZSIsImJhc2VJc0VxdWFsIiwiYmFzZUlzRXF1YWxEZWVwIiwiZXF1YWxGdW5jIiwib2JqSXNBcnIiLCJvdGhJc0FyciIsIm9ialRhZyIsIm90aFRhZyIsIm9iaklzT2JqIiwib3RoSXNPYmoiLCJpc1NhbWVUYWciLCJlcXVhbEFycmF5cyIsImVxdWFsQnlUYWciLCJvYmpJc1dyYXBwZWQiLCJvdGhJc1dyYXBwZWQiLCJvYmpVbndyYXBwZWQiLCJvdGhVbndyYXBwZWQiLCJlcXVhbE9iamVjdHMiLCJiYXNlSXNNYXAiLCJiYXNlSXNNYXRjaCIsIm1hdGNoRGF0YSIsIm5vQ3VzdG9taXplciIsInNyY1ZhbHVlIiwiYmFzZUlzTmF0aXZlIiwiaXNNYXNrZWQiLCJwYXR0ZXJuIiwiYmFzZUlzUmVnRXhwIiwiYmFzZUlzU2V0IiwiYmFzZUlzVHlwZWRBcnJheSIsImlzTGVuZ3RoIiwiYmFzZUl0ZXJhdGVlIiwiaWRlbnRpdHkiLCJiYXNlTWF0Y2hlc1Byb3BlcnR5IiwiYmFzZU1hdGNoZXMiLCJwcm9wZXJ0eSIsImJhc2VLZXlzIiwiaXNQcm90b3R5cGUiLCJiYXNlS2V5c0luIiwibmF0aXZlS2V5c0luIiwiaXNQcm90byIsImJhc2VMdCIsImJhc2VNYXAiLCJpc0FycmF5TGlrZSIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiaXNLZXkiLCJpc1N0cmljdENvbXBhcmFibGUiLCJoYXNJbiIsImJhc2VNZXJnZSIsInNyY0luZGV4IiwiYmFzZU1lcmdlRGVlcCIsIm5ld1ZhbHVlIiwic2FmZUdldCIsIm1lcmdlRnVuYyIsImlzVHlwZWQiLCJpc0FycmF5TGlrZU9iamVjdCIsImNsb25lVHlwZWRBcnJheSIsImlzUGxhaW5PYmplY3QiLCJ0b1BsYWluT2JqZWN0IiwiYmFzZU50aCIsImJhc2VPcmRlckJ5Iiwib3JkZXJzIiwiZ2V0SXRlcmF0ZWUiLCJjcml0ZXJpYSIsImNvbXBhcmVNdWx0aXBsZSIsImJhc2VQaWNrIiwiYmFzZVBpY2tCeSIsImJhc2VTZXQiLCJiYXNlUHJvcGVydHlEZWVwIiwiYmFzZVB1bGxBbGwiLCJpbmRleE9mIiwiYmFzZVB1bGxBdCIsImluZGV4ZXMiLCJwcmV2aW91cyIsImJhc2VVbnNldCIsImJhc2VSYW5nZSIsInN0ZXAiLCJiYXNlUmVwZWF0IiwiYmFzZVJlc3QiLCJzZXRUb1N0cmluZyIsIm92ZXJSZXN0IiwiYmFzZVNhbXBsZSIsImJhc2VTYW1wbGVTaXplIiwibmVzdGVkIiwiYmFzZVNldERhdGEiLCJiYXNlU2V0VG9TdHJpbmciLCJjb25zdGFudCIsImJhc2VTaHVmZmxlIiwiYmFzZVNsaWNlIiwiYmFzZVNvbWUiLCJiYXNlU29ydGVkSW5kZXgiLCJyZXRIaWdoZXN0IiwibG93IiwiaGlnaCIsIm1pZCIsImJhc2VTb3J0ZWRJbmRleEJ5IiwidmFsSXNOYU4iLCJ2YWxJc051bGwiLCJ2YWxJc1N5bWJvbCIsInZhbElzVW5kZWZpbmVkIiwib3RoSXNEZWZpbmVkIiwib3RoSXNOdWxsIiwib3RoSXNSZWZsZXhpdmUiLCJvdGhJc1N5bWJvbCIsInNldExvdyIsImJhc2VTb3J0ZWRVbmlxIiwiYmFzZVRvTnVtYmVyIiwiYmFzZVRvU3RyaW5nIiwiYmFzZVVuaXEiLCJjcmVhdGVTZXQiLCJzZWVuSW5kZXgiLCJiYXNlVXBkYXRlIiwidXBkYXRlciIsImJhc2VXaGlsZSIsImlzRHJvcCIsImFjdGlvbnMiLCJhY3Rpb24iLCJiYXNlWG9yIiwiYmFzZVppcE9iamVjdCIsImFzc2lnbkZ1bmMiLCJ2YWxzTGVuZ3RoIiwiY2FzdEFycmF5TGlrZU9iamVjdCIsImNhc3RGdW5jdGlvbiIsInN0cmluZ1RvUGF0aCIsImNhc3RSZXN0IiwiY2FzdFNsaWNlIiwiYnVmZmVyIiwiY29weSIsImNsb25lQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJjbG9uZURhdGFWaWV3IiwiZGF0YVZpZXciLCJieXRlT2Zmc2V0IiwiY2xvbmVSZWdFeHAiLCJyZWdleHAiLCJjbG9uZVN5bWJvbCIsInN5bWJvbCIsInR5cGVkQXJyYXkiLCJjb21wYXJlQXNjZW5kaW5nIiwidmFsSXNEZWZpbmVkIiwidmFsSXNSZWZsZXhpdmUiLCJvYmpDcml0ZXJpYSIsIm90aENyaXRlcmlhIiwib3JkZXJzTGVuZ3RoIiwib3JkZXIiLCJjb21wb3NlQXJncyIsInBhcnRpYWxzIiwiaG9sZGVycyIsImlzQ3VycmllZCIsImFyZ3NJbmRleCIsImFyZ3NMZW5ndGgiLCJob2xkZXJzTGVuZ3RoIiwibGVmdEluZGV4IiwibGVmdExlbmd0aCIsInJhbmdlTGVuZ3RoIiwiaXNVbmN1cnJpZWQiLCJjb21wb3NlQXJnc1JpZ2h0IiwiaG9sZGVyc0luZGV4IiwicmlnaHRJbmRleCIsInJpZ2h0TGVuZ3RoIiwiaXNOZXciLCJnZXRTeW1ib2xzIiwiZ2V0U3ltYm9sc0luIiwiY3JlYXRlQWdncmVnYXRvciIsImluaXRpYWxpemVyIiwiY3JlYXRlQXNzaWduZXIiLCJhc3NpZ25lciIsImd1YXJkIiwiaXNJdGVyYXRlZUNhbGwiLCJpdGVyYWJsZSIsImNyZWF0ZUJpbmQiLCJpc0JpbmQiLCJDdG9yIiwiY3JlYXRlQ3RvciIsIndyYXBwZXIiLCJmbiIsImFyZ3VtZW50cyIsImNyZWF0ZUNhc2VGaXJzdCIsIm1ldGhvZE5hbWUiLCJjaGFyQXQiLCJ0cmFpbGluZyIsImNyZWF0ZUNvbXBvdW5kZXIiLCJjYWxsYmFjayIsIndvcmRzIiwiZGVidXJyIiwidGhpc0JpbmRpbmciLCJjcmVhdGVDdXJyeSIsImFyaXR5IiwiZ2V0SG9sZGVyIiwiY3JlYXRlUmVjdXJyeSIsImNyZWF0ZUh5YnJpZCIsImNyZWF0ZUZpbmQiLCJmaW5kSW5kZXhGdW5jIiwiY3JlYXRlRmxvdyIsImZsYXRSZXN0IiwiZnVuY3MiLCJwcmVyZXEiLCJ0aHJ1IiwiZ2V0RnVuY05hbWUiLCJmdW5jTmFtZSIsImdldERhdGEiLCJpc0xhemlhYmxlIiwicGxhbnQiLCJwYXJ0aWFsc1JpZ2h0IiwiaG9sZGVyc1JpZ2h0IiwiYXJnUG9zIiwiYXJ5IiwiaXNBcnkiLCJpc0JpbmRLZXkiLCJpc0ZsaXAiLCJob2xkZXJzQ291bnQiLCJuZXdIb2xkZXJzIiwicmVvcmRlciIsImNyZWF0ZUludmVydGVyIiwidG9JdGVyYXRlZSIsImNyZWF0ZU1hdGhPcGVyYXRpb24iLCJvcGVyYXRvciIsImRlZmF1bHRWYWx1ZSIsImNyZWF0ZU92ZXIiLCJhcnJheUZ1bmMiLCJjcmVhdGVQYWRkaW5nIiwiY2hhcnMiLCJjaGFyc0xlbmd0aCIsImNyZWF0ZVBhcnRpYWwiLCJjcmVhdGVSYW5nZSIsInRvRmluaXRlIiwiY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbiIsInRvTnVtYmVyIiwid3JhcEZ1bmMiLCJpc0N1cnJ5IiwibmV3SG9sZGVyc1JpZ2h0IiwibmV3UGFydGlhbHMiLCJuZXdQYXJ0aWFsc1JpZ2h0IiwibmV3RGF0YSIsInNldERhdGEiLCJzZXRXcmFwVG9TdHJpbmciLCJjcmVhdGVSb3VuZCIsInByZWNpc2lvbiIsInBhaXIiLCJub29wIiwiY3JlYXRlVG9QYWlycyIsImNyZWF0ZVdyYXAiLCJtZXJnZURhdGEiLCJjdXN0b21EZWZhdWx0c0Fzc2lnbkluIiwiY3VzdG9tRGVmYXVsdHNNZXJnZSIsImN1c3RvbU9taXRDbG9uZSIsImlzUGFydGlhbCIsImFyclN0YWNrZWQiLCJvdGhTdGFja2VkIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwibWVzc2FnZSIsImNvbnZlcnQiLCJvYmpQcm9wcyIsIm9iakxlbmd0aCIsIm90aFByb3BzIiwib2JqU3RhY2tlZCIsInNraXBDdG9yIiwib2JqQ3RvciIsIm90aEN0b3IiLCJmbGF0dGVuIiwib3RoZXJGdW5jIiwiaXNLZXlhYmxlIiwiaXNPd24iLCJ1bm1hc2tlZCIsInN0dWJBcnJheSIsIkFycmF5QnVmZmVyIiwicmVzb2x2ZSIsImN0b3JTdHJpbmciLCJ0cmFuc2Zvcm1zIiwiZ2V0V3JhcERldGFpbHMiLCJoYXNQYXRoIiwiaGFzRnVuYyIsImlucHV0IiwiaW5zZXJ0V3JhcERldGFpbHMiLCJkZXRhaWxzIiwiaXNNYXNrYWJsZSIsInN0dWJGYWxzZSIsIm1lbW9pemVDYXBwZWQiLCJtZW1vaXplIiwic3JjQml0bWFzayIsIm5ld0JpdG1hc2siLCJpc0NvbWJvIiwib3RoZXJBcmdzIiwib2xkQXJyYXkiLCJzaG9ydE91dCIsInJlZmVyZW5jZSIsInVwZGF0ZVdyYXBEZXRhaWxzIiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJyYW5kIiwiY2hhckNvZGVBdCIsInF1b3RlIiwic3ViU3RyaW5nIiwiY2h1bmsiLCJjb21wYWN0IiwiZGlmZmVyZW5jZSIsImRpZmZlcmVuY2VCeSIsImRpZmZlcmVuY2VXaXRoIiwiZHJvcCIsImRyb3BSaWdodCIsImRyb3BSaWdodFdoaWxlIiwiZHJvcFdoaWxlIiwiZmlsbCIsImZpbmRJbmRleCIsImZpbmRMYXN0SW5kZXgiLCJmbGF0dGVuRGVlcCIsImZsYXR0ZW5EZXB0aCIsImZyb21QYWlycyIsImhlYWQiLCJpbml0aWFsIiwiaW50ZXJzZWN0aW9uIiwibWFwcGVkIiwiaW50ZXJzZWN0aW9uQnkiLCJpbnRlcnNlY3Rpb25XaXRoIiwic2VwYXJhdG9yIiwibGFzdEluZGV4T2YiLCJudGgiLCJwdWxsIiwicHVsbEFsbCIsInB1bGxBbGxCeSIsInB1bGxBbGxXaXRoIiwicHVsbEF0IiwicmVtb3ZlIiwic29ydGVkSW5kZXgiLCJzb3J0ZWRJbmRleEJ5Iiwic29ydGVkSW5kZXhPZiIsInNvcnRlZExhc3RJbmRleCIsInNvcnRlZExhc3RJbmRleEJ5Iiwic29ydGVkTGFzdEluZGV4T2YiLCJzb3J0ZWRVbmlxIiwic29ydGVkVW5pcUJ5IiwidGFpbCIsInRha2UiLCJ0YWtlUmlnaHQiLCJ0YWtlUmlnaHRXaGlsZSIsInRha2VXaGlsZSIsInVuaW9uIiwidW5pb25CeSIsInVuaW9uV2l0aCIsInVuaXEiLCJ1bmlxQnkiLCJ1bmlxV2l0aCIsInVuemlwIiwiZ3JvdXAiLCJ1bnppcFdpdGgiLCJ3aXRob3V0IiwieG9yIiwieG9yQnkiLCJ4b3JXaXRoIiwiemlwIiwiemlwT2JqZWN0IiwiemlwT2JqZWN0RGVlcCIsInppcFdpdGgiLCJjaGFpbiIsInRhcCIsImludGVyY2VwdG9yIiwid3JhcHBlckF0Iiwid3JhcHBlckNoYWluIiwid3JhcHBlckNvbW1pdCIsIndyYXBwZXJOZXh0IiwidG9BcnJheSIsIndyYXBwZXJUb0l0ZXJhdG9yIiwid3JhcHBlclBsYW50Iiwid3JhcHBlclJldmVyc2UiLCJ3cmFwcGVkIiwid3JhcHBlclZhbHVlIiwiY291bnRCeSIsImV2ZXJ5IiwiZmlsdGVyIiwiZmluZCIsImZpbmRMYXN0IiwiZmxhdE1hcCIsImZsYXRNYXBEZWVwIiwiZmxhdE1hcERlcHRoIiwiZm9yRWFjaFJpZ2h0IiwiZ3JvdXBCeSIsImlzU3RyaW5nIiwiaW52b2tlTWFwIiwia2V5QnkiLCJvcmRlckJ5IiwicGFydGl0aW9uIiwicmVkdWNlIiwicmVkdWNlUmlnaHQiLCJyZWplY3QiLCJuZWdhdGUiLCJzYW1wbGUiLCJzYW1wbGVTaXplIiwic2h1ZmZsZSIsInNvbWUiLCJzb3J0QnkiLCJhZnRlciIsImJlZm9yZSIsImJpbmQiLCJiaW5kS2V5IiwiY3VycnkiLCJjdXJyeVJpZ2h0IiwiZGVib3VuY2UiLCJvcHRpb25zIiwibGFzdEFyZ3MiLCJsYXN0VGhpcyIsIm1heFdhaXQiLCJ0aW1lcklkIiwibGFzdENhbGxUaW1lIiwibGFzdEludm9rZVRpbWUiLCJsZWFkaW5nIiwibWF4aW5nIiwiaW52b2tlRnVuYyIsInRpbWUiLCJsZWFkaW5nRWRnZSIsInRpbWVyRXhwaXJlZCIsInJlbWFpbmluZ1dhaXQiLCJ0aW1lU2luY2VMYXN0Q2FsbCIsInRpbWVTaW5jZUxhc3RJbnZva2UiLCJ0aW1lV2FpdGluZyIsInNob3VsZEludm9rZSIsInRyYWlsaW5nRWRnZSIsImNhbmNlbCIsImZsdXNoIiwiZGVib3VuY2VkIiwiaXNJbnZva2luZyIsImRlZmVyIiwiZGVsYXkiLCJmbGlwIiwicmVzb2x2ZXIiLCJtZW1vaXplZCIsIkNhY2hlIiwib25jZSIsIm92ZXJBcmdzIiwiZnVuY3NMZW5ndGgiLCJwYXJ0aWFsIiwicGFydGlhbFJpZ2h0IiwicmVhcmciLCJyZXN0Iiwic3ByZWFkIiwidGhyb3R0bGUiLCJ1bmFyeSIsIndyYXAiLCJjYXN0QXJyYXkiLCJjbG9uZVdpdGgiLCJjbG9uZURlZXAiLCJjbG9uZURlZXBXaXRoIiwiY29uZm9ybXNUbyIsImd0IiwiZ3RlIiwiaXNCb29sZWFuIiwiaXNFbGVtZW50IiwiaXNFbXB0eSIsImlzRXF1YWwiLCJpc0VxdWFsV2l0aCIsImlzRXJyb3IiLCJpc0ludGVnZXIiLCJpc01hdGNoIiwiaXNNYXRjaFdpdGgiLCJpc05hTiIsImlzTnVtYmVyIiwiaXNOYXRpdmUiLCJpc051bGwiLCJpc05pbCIsImlzU2FmZUludGVnZXIiLCJpc1VuZGVmaW5lZCIsImlzV2Vha01hcCIsImlzV2Vha1NldCIsImx0IiwibHRlIiwic2lnbiIsInJlbWFpbmRlciIsImlzQmluYXJ5IiwidG9TYWZlSW50ZWdlciIsImFzc2lnbiIsImFzc2lnbkluIiwiYXNzaWduSW5XaXRoIiwiYXNzaWduV2l0aCIsImF0IiwicHJvcGVydGllcyIsInByb3BzSW5kZXgiLCJwcm9wc0xlbmd0aCIsImRlZmF1bHRzRGVlcCIsIm1lcmdlV2l0aCIsImZpbmRLZXkiLCJmaW5kTGFzdEtleSIsImZvckluIiwiZm9ySW5SaWdodCIsImZvck93biIsImZvck93blJpZ2h0IiwiZnVuY3Rpb25zIiwiZnVuY3Rpb25zSW4iLCJpbnZlcnQiLCJpbnZlcnRCeSIsImludm9rZSIsIm1hcEtleXMiLCJtYXBWYWx1ZXMiLCJtZXJnZSIsIm9taXQiLCJvbWl0QnkiLCJwaWNrQnkiLCJwcm9wIiwic2V0V2l0aCIsInRvUGFpcnMiLCJ0b1BhaXJzSW4iLCJpc0Fyckxpa2UiLCJ1bnNldCIsInVwZGF0ZSIsInVwZGF0ZVdpdGgiLCJ2YWx1ZXNJbiIsImNsYW1wIiwiaW5SYW5nZSIsImZsb2F0aW5nIiwidGVtcCIsImNhbWVsQ2FzZSIsIndvcmQiLCJ0b0xvd2VyQ2FzZSIsImNhcGl0YWxpemUiLCJ1cHBlckZpcnN0IiwiZW5kc1dpdGgiLCJ0YXJnZXQiLCJwb3NpdGlvbiIsImVzY2FwZSIsImVzY2FwZVJlZ0V4cCIsImtlYmFiQ2FzZSIsImxvd2VyQ2FzZSIsImxvd2VyRmlyc3QiLCJwYWQiLCJzdHJMZW5ndGgiLCJwYWRFbmQiLCJwYWRTdGFydCIsInJhZGl4IiwicmVwZWF0Iiwic25ha2VDYXNlIiwibGltaXQiLCJzdGFydENhc2UiLCJzdGFydHNXaXRoIiwidGVtcGxhdGUiLCJzZXR0aW5ncyIsImltcG9ydHMiLCJpbXBvcnRzS2V5cyIsImltcG9ydHNWYWx1ZXMiLCJpc0VzY2FwaW5nIiwiaXNFdmFsdWF0aW5nIiwiaW50ZXJwb2xhdGUiLCJyZURlbGltaXRlcnMiLCJldmFsdWF0ZSIsInNvdXJjZVVSTCIsImVzY2FwZVZhbHVlIiwiaW50ZXJwb2xhdGVWYWx1ZSIsImVzVGVtcGxhdGVWYWx1ZSIsImV2YWx1YXRlVmFsdWUiLCJ2YXJpYWJsZSIsImF0dGVtcHQiLCJ0b0xvd2VyIiwidG9VcHBlciIsInRvVXBwZXJDYXNlIiwidHJpbSIsInRyaW1FbmQiLCJ0cmltU3RhcnQiLCJ0cnVuY2F0ZSIsIm9taXNzaW9uIiwic2VhcmNoIiwic3Vic3RyaW5nIiwibmV3RW5kIiwidXBwZXJDYXNlIiwiYmluZEFsbCIsIm1ldGhvZE5hbWVzIiwiY29uZCIsImNvbmZvcm1zIiwiZGVmYXVsdFRvIiwiZmxvdyIsImZsb3dSaWdodCIsIm1hdGNoZXMiLCJtYXRjaGVzUHJvcGVydHkiLCJtZXRob2QiLCJtZXRob2RPZiIsIm1peGluIiwibm9Db25mbGljdCIsIm50aEFyZyIsIm92ZXIiLCJvdmVyRXZlcnkiLCJvdmVyU29tZSIsInByb3BlcnR5T2YiLCJyYW5nZSIsInJhbmdlUmlnaHQiLCJzdHViT2JqZWN0Iiwic3R1YlN0cmluZyIsInN0dWJUcnVlIiwidGltZXMiLCJ0b1BhdGgiLCJ1bmlxdWVJZCIsInByZWZpeCIsImF1Z2VuZCIsImFkZGVuZCIsImRpdmlkZSIsImRpdmlkZW5kIiwiZGl2aXNvciIsIm1heEJ5IiwibWVhbiIsIm1lYW5CeSIsIm1pbkJ5IiwibXVsdGlwbHkiLCJtdWx0aXBsaWVyIiwibXVsdGlwbGljYW5kIiwicm91bmQiLCJzdWJ0cmFjdCIsIm1pbnVlbmQiLCJzdWJ0cmFoZW5kIiwic3VtIiwic3VtQnkiLCJlbnRyaWVzSW4iLCJleHRlbmQiLCJleHRlbmRXaXRoIiwiZWFjaCIsImVhY2hSaWdodCIsImZpcnN0IiwiaXNGaWx0ZXIiLCJ0YWtlTmFtZSIsImRyb3BOYW1lIiwiY2hlY2tJdGVyYXRlZSIsImlzVGFrZXIiLCJsb2Rhc2hGdW5jIiwicmV0VW53cmFwcGVkIiwiaXNMYXp5IiwidXNlTGF6eSIsImlzSHlicmlkIiwiaXNVbndyYXBwZWQiLCJvbmx5TGF6eSIsImNoYWluTmFtZSIsImNvbW1pdCIsInRvSlNPTiIsImRlZmluZSIsIkFycmF5UHJvdG8iLCJPYmpQcm90byIsImVzY2FwZU1hcCIsImVzY2FwZVJlZ2V4Iiwib2xkIiwiY2F1c2UiLCJUZW1wbGF0ZUVycm9yIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwic3RhY2tEZXNjcmlwdG9yIiwiZ2V0U3RhY2siLCJtc2ciLCJ2YWwiLCJhdHRyIiwicGFydHMiLCJfcHJlcGFyZUF0dHJpYnV0ZVBhcnRzIiwicGFydCIsImhhc093blByb3AiLCJnZXRBdHRyR2V0dGVyIiwib2JqIiwidGhyb3dPblVuZGVmaW5lZCIsImNvbnRhaW5zIiwic3RyIiwibCIsInJlc3VsdHMiLCJpdGVyIiwiY2IiLCJrZXlzXyIsImsiLCJvYmoxIiwib2JqMiIsIkV2ZW50RW1pdHRlciIsImxpYiIsInRtcCIsInJlcyIsInBhcmVudFdyYXAiLCJjbHMiLCJzdWJjbGFzcyIsIk9iaiIsImluaXQiLCJleHRlbmRDbGFzcyIsIkVtaXR0ZXJPYmoiLCJhcnJheUZyb20iLCJzdXBwb3J0c0l0ZXJhdG9ycyIsIkZyYW1lIiwiZnJhbWUiLCJsb29rdXAiLCJwIiwiZm9yV3JpdGUiLCJtYWNyb0FyZ3MiLCJhcmdDb3VudCIsIm51bUFyZ3MiLCJrd2FyZ3MiLCJnZXRLZXl3b3JkQXJncyIsImFyZ05hbWVzIiwia3dhcmdOYW1lcyIsImxhc3RBcmciLCJpc0tleXdvcmRBcmdzIiwiU2FmZVN0cmluZyIsImNvbmZpZ3VyYWJsZSIsImRlc3QiLCJyZXQiLCJhdXRvZXNjYXBlIiwibGluZW5vIiwiY29sbm8iLCJlcnJvciIsImZpbmlzaGVkIiwib3V0cHV0QXJyIiwibWFrZU1hY3JvIiwibWFrZUtleXdvcmRBcmdzIiwic3VwcHJlc3NWYWx1ZSIsImVuc3VyZURlZmluZWQiLCJtZW1iZXJMb29rdXAiLCJjb250ZXh0T3JGcmFtZUxvb2t1cCIsImNhbGxXcmFwIiwiaGFuZGxlRXJyb3IiLCJjb3B5U2FmZW5lc3MiLCJtYXJrU2FmZSIsImFzeW5jRWFjaCIsImFzeW5jQWxsIiwiaW5PcGVyYXRvciIsImZyb21JdGVyYXRvciIsIk5vZGUiLCJmaW5kQWxsIiwidHJhdmVyc2VBbmRDaGVjayIsIml0ZXJGaWVsZHMiLCJWYWx1ZSIsIk5vZGVMaXN0Iiwibm9kZXMiLCJhZGRDaGlsZCIsIlJvb3QiLCJMaXRlcmFsIiwiR3JvdXAiLCJBcnJheU5vZGUiLCJQYWlyIiwiZmllbGRzIiwiRGljdCIsIkxvb2t1cFZhbCIsIklmIiwiSWZBc3luYyIsIklubGluZUlmIiwiRm9yIiwiQXN5bmNFYWNoIiwiQXN5bmNBbGwiLCJNYWNybyIsIkNhbGxlciIsIkltcG9ydCIsIkZyb21JbXBvcnQiLCJuYW1lcyIsIkZ1bkNhbGwiLCJGaWx0ZXIiLCJGaWx0ZXJBc3luYyIsIktleXdvcmRBcmdzIiwiQmxvY2siLCJTdXBlciIsIlRlbXBsYXRlUmVmIiwiRXh0ZW5kcyIsIkluY2x1ZGUiLCJTd2l0Y2giLCJDYXNlIiwiT3V0cHV0IiwiQ2FwdHVyZSIsIlRlbXBsYXRlRGF0YSIsIlVuYXJ5T3AiLCJCaW5PcCIsIkluIiwiSXMiLCJPciIsIkFuZCIsIk5vdCIsIkFkZCIsIkNvbmNhdCIsIlN1YiIsIk11bCIsIkRpdiIsIkZsb29yRGl2IiwiTW9kIiwiUG93IiwiTmVnIiwiUG9zIiwiQ29tcGFyZSIsIkNvbXBhcmVPcGVyYW5kIiwiQ2FsbEV4dGVuc2lvbiIsImV4dCIsImNvbnRlbnRBcmdzIiwiQ2FsbEV4dGVuc2lvbkFzeW5jIiwibGluZXMiLCJsaW5lIiwiaW5saW5lIiwibmwiLCJpbmRlbnQiLCJwcmludCIsIm5vZGUiLCJwcmludE5vZGVzIiwiZmllbGROYW1lIiwicGFyc2VyIiwidHJhbnNmb3JtZXIiLCJjb21wYXJlT3BzIiwiQ29tcGlsZXIiLCJmYWlsIiwiX3B1c2hCdWZmZXIiLCJfcG9wQnVmZmVyIiwiX2VtaXQiLCJfZW1pdExpbmUiLCJjb2RlIiwiX2VtaXRMaW5lcyIsIl9lbWl0RnVuY0JlZ2luIiwiX2VtaXRGdW5jRW5kIiwiX2FkZFNjb3BlTGV2ZWwiLCJfY2xvc2VTY29wZUxldmVscyIsIl93aXRoU2NvcGVkU3ludGF4IiwiX3Njb3BlQ2xvc2VycyIsIl9tYWtlQ2FsbGJhY2siLCJfdG1waWQiLCJfdGVtcGxhdGVOYW1lIiwiX2NvbXBpbGVDaGlsZHJlbiIsIl9jb21waWxlQWdncmVnYXRlIiwiX2NvbXBpbGVFeHByZXNzaW9uIiwiYXNzZXJ0VHlwZSIsImNvbXBpbGVDYWxsRXh0ZW5zaW9uIiwiY29tcGlsZUNhbGxFeHRlbnNpb25Bc3luYyIsImNvbXBpbGVOb2RlTGlzdCIsImNvbXBpbGVMaXRlcmFsIiwiY29tcGlsZVN5bWJvbCIsInYiLCJjb21waWxlR3JvdXAiLCJjb21waWxlQXJyYXkiLCJjb21waWxlRGljdCIsImNvbXBpbGVQYWlyIiwiY29tcGlsZUlubGluZUlmIiwiY29tcGlsZUluIiwiY29tcGlsZUlzIiwicmlnaHQiLCJfYmluT3BFbWl0dGVyIiwiY29tcGlsZU9yIiwiY29tcGlsZUFuZCIsImNvbXBpbGVBZGQiLCJjb21waWxlQ29uY2F0IiwiY29tcGlsZVN1YiIsImNvbXBpbGVNdWwiLCJjb21waWxlRGl2IiwiY29tcGlsZU1vZCIsImNvbXBpbGVOb3QiLCJjb21waWxlRmxvb3JEaXYiLCJjb21waWxlUG93IiwiY29tcGlsZU5lZyIsImNvbXBpbGVQb3MiLCJjb21waWxlQ29tcGFyZSIsIm9wIiwiY29tcGlsZUxvb2t1cFZhbCIsIl9nZXROb2RlTmFtZSIsImNvbXBpbGVGdW5DYWxsIiwiY29tcGlsZUZpbHRlciIsImNvbXBpbGVGaWx0ZXJBc3luYyIsImNvbXBpbGVLZXl3b3JkQXJncyIsImNvbXBpbGVTZXQiLCJpZHMiLCJjb21waWxlU3dpdGNoIiwiYyIsImNvbXBpbGVJZiIsImNvbXBpbGVJZkFzeW5jIiwiX2VtaXRMb29wQmluZGluZ3MiLCJiaW5kaW5ncyIsImIiLCJjb21waWxlRm9yIiwidGlkIiwiX2NvbXBpbGVBc3luY0xvb3AiLCJhc3luY01ldGhvZCIsInBhcmFsbGVsIiwiYXJyYXlMZW4iLCJidWYiLCJvdXRwdXQiLCJjb21waWxlQXN5bmNFYWNoIiwiY29tcGlsZUFzeW5jQWxsIiwiX2NvbXBpbGVNYWNybyIsImZ1bmNJZCIsImtlZXBGcmFtZSIsImN1cnJGcmFtZSIsImJ1ZmZlcklkIiwiY29tcGlsZU1hY3JvIiwiY29tcGlsZUNhbGxlciIsIl9jb21waWxlR2V0VGVtcGxhdGUiLCJwYXJlbnRUZW1wbGF0ZUlkIiwicGFyZW50TmFtZSIsImVhZ2VyQ29tcGlsZUFyZyIsImVhZ2VyQ29tcGlsZSIsImlnbm9yZU1pc3NpbmdBcmciLCJpZ25vcmVNaXNzaW5nIiwiY29tcGlsZUltcG9ydCIsImNvbXBpbGVGcm9tSW1wb3J0IiwiaW1wb3J0ZWRJZCIsIm5hbWVOb2RlIiwiYWxpYXMiLCJjb21waWxlQmxvY2siLCJjb21waWxlU3VwZXIiLCJjb21waWxlRXh0ZW5kcyIsImNvbXBpbGVJbmNsdWRlIiwiaWQyIiwiY29tcGlsZVRlbXBsYXRlRGF0YSIsImNvbXBpbGVDYXB0dXJlIiwiY29tcGlsZU91dHB1dCIsImNoaWxkcmVuIiwiY2hpbGQiLCJjb21waWxlUm9vdCIsImJsb2NrTmFtZXMiLCJibG9ja3MiLCJibG9jayIsInRtcEZyYW1lIiwiYmxvY2tOYW1lIiwiY29tcGlsZSIsIl9jb21waWxlIiwiZ2V0Q29kZSIsIm9wdHMiLCJwcmVwcm9jZXNzb3JzIiwiZXh0ZW5zaW9ucyIsInByb2Nlc3NlZFNyYyIsInByb2Nlc3NvciIsImlzUmVsYXRpdmUiLCJmaWxlbmFtZSIsImFzYXAiLCJ3YXRlcmZhbGwiLCJjb21waWxlciIsImZpbHRlcnMiLCJGaWxlU3lzdGVtTG9hZGVyIiwiV2ViTG9hZGVyIiwiUHJlY29tcGlsZWRMb2FkZXIiLCJ0ZXN0cyIsImdsb2JhbHMiLCJnbG9iYWxSdW50aW1lIiwiZXhwcmVzc0FwcCIsIm5vb3BUbXBsU3JjIiwiRW52aXJvbm1lbnQiLCJ3aW5kb3ciLCJfaW5pdExvYWRlcnMiLCJsb2FkZXIiLCJpbnZhbGlkYXRlQ2FjaGUiLCJhZGRFeHRlbnNpb24iLCJleHRlbnNpb24iLCJyZW1vdmVFeHRlbnNpb24iLCJnZXRFeHRlbnNpb24iLCJoYXNFeHRlbnNpb24iLCJhZGRHbG9iYWwiLCJnZXRHbG9iYWwiLCJhZGRGaWx0ZXIiLCJnZXRGaWx0ZXIiLCJhZGRUZXN0IiwiZ2V0VGVzdCIsInJlc29sdmVUZW1wbGF0ZSIsImdldFRlbXBsYXRlIiwidGhhdCIsInRtcGwiLCJjcmVhdGVUZW1wbGF0ZSIsIm5ld1RtcGwiLCJpbmZvIiwic3luY1Jlc3VsdCIsInNyYyIsImhhbmRsZSIsImV4cHJlc3MiLCJyZW5kZXIiLCJjdHgiLCJjYWxsYmFja0FzYXAiLCJyZW5kZXJTdHJpbmciLCJDb250ZXh0IiwiZW52Iiwic2V0VmFyaWFibGUiLCJnZXRWYXJpYWJsZXMiLCJhZGRCbG9jayIsImdldEJsb2NrIiwiZ2V0U3VwZXIiLCJpZHgiLCJibGsiLCJhZGRFeHBvcnQiLCJnZXRFeHBvcnRlZCIsImV4cG9ydGVkIiwiVGVtcGxhdGUiLCJwYXJlbnRGcmFtZSIsImZvcmNlQXN5bmMiLCJkaWRFcnJvciIsIl9nZXRCbG9ja3MiLCJsZXhlciIsIlBhcnNlciIsIm5leHRUb2tlbiIsInRvayIsInBlZWtUb2tlbiIsInB1c2hUb2tlbiIsImV4cGVjdCIsInNraXBWYWx1ZSIsInNraXBTeW1ib2wiLCJhZHZhbmNlQWZ0ZXJCbG9ja0VuZCIsImFkdmFuY2VBZnRlclZhcmlhYmxlRW5kIiwicGFyc2VGb3IiLCJmb3JUb2siLCJlbmRCbG9jayIsInByaW0iLCJwYXJzZU1hY3JvIiwibWFjcm9Ub2siLCJwYXJzZUNhbGwiLCJjYWxsVG9rIiwiY2FsbGVyQXJncyIsIm1hY3JvQ2FsbCIsImJvZHkiLCJjYWxsZXJOYW1lIiwiY2FsbGVyTm9kZSIsInBhcnNlV2l0aENvbnRleHQiLCJ3aXRoQ29udGV4dCIsInBhcnNlSW1wb3J0IiwiaW1wb3J0VG9rIiwicGFyc2VGcm9tIiwiZnJvbVRvayIsIm5leHRUb2siLCJwYXJzZUJsb2NrIiwicGFyc2VFeHRlbmRzIiwidGFnTmFtZSIsInBhcnNlSW5jbHVkZSIsInBhcnNlSWYiLCJwYXJzZVNldCIsInBhcnNlU3dpdGNoIiwic3dpdGNoU3RhcnQiLCJzd2l0Y2hFbmQiLCJjYXNlU3RhcnQiLCJjYXNlRGVmYXVsdCIsImV4cHIiLCJjYXNlcyIsImRlZmF1bHRDYXNlIiwicGFyc2VTdGF0ZW1lbnQiLCJwYXJzZVJhdyIsImVuZFRhZ05hbWUiLCJyYXdCbG9ja1JlZ2V4IiwicmF3TGV2ZWwiLCJiZWd1biIsImFsbCIsInByZSIsInBhcnNlUG9zdGZpeCIsInBhcnNlRXhwcmVzc2lvbiIsInBhcnNlSW5saW5lSWYiLCJjb25kTm9kZSIsImJvZHlOb2RlIiwicGFyc2VPciIsIm5vZGUyIiwicGFyc2VBbmQiLCJwYXJzZU5vdCIsInBhcnNlSW4iLCJwYXJzZUlzIiwibm90IiwicGFyc2VDb21wYXJlIiwib3BzIiwicGFyc2VDb25jYXQiLCJwYXJzZUFkZCIsInBhcnNlU3ViIiwicGFyc2VNdWwiLCJwYXJzZURpdiIsInBhcnNlRmxvb3JEaXYiLCJwYXJzZU1vZCIsInBhcnNlUG93IiwicGFyc2VVbmFyeSIsInBhcnNlUHJpbWFyeSIsInBhcnNlRmlsdGVyTmFtZSIsInBhcnNlRmlsdGVyQXJncyIsInBhcnNlRmlsdGVyIiwicGFyc2VGaWx0ZXJTdGF0ZW1lbnQiLCJmaWx0ZXJUb2siLCJwYXJzZUFnZ3JlZ2F0ZSIsInBhcnNlU2lnbmF0dXJlIiwiY2hlY2tDb21tYSIsIm5vUGFyZW5zIiwicGFyc2VVbnRpbEJsb2NrcyIsInByZXYiLCJwYXJzZU5vZGVzIiwibmV4dFZhbCIsInBhcnNlIiwicGFyc2VBc1Jvb3QiLCJ3aGl0ZXNwYWNlQ2hhcnMiLCJkZWxpbUNoYXJzIiwiaW50Q2hhcnMiLCJCTE9DS19TVEFSVCIsIkJMT0NLX0VORCIsIlZBUklBQkxFX1NUQVJUIiwiVkFSSUFCTEVfRU5EIiwiQ09NTUVOVF9TVEFSVCIsIkNPTU1FTlRfRU5EIiwiVE9LRU5fU1RSSU5HIiwiVE9LRU5fV0hJVEVTUEFDRSIsIlRPS0VOX0RBVEEiLCJUT0tFTl9CTE9DS19TVEFSVCIsIlRPS0VOX0JMT0NLX0VORCIsIlRPS0VOX1ZBUklBQkxFX1NUQVJUIiwiVE9LRU5fVkFSSUFCTEVfRU5EIiwiVE9LRU5fQ09NTUVOVCIsIlRPS0VOX0xFRlRfUEFSRU4iLCJUT0tFTl9SSUdIVF9QQVJFTiIsIlRPS0VOX0xFRlRfQlJBQ0tFVCIsIlRPS0VOX1JJR0hUX0JSQUNLRVQiLCJUT0tFTl9MRUZUX0NVUkxZIiwiVE9LRU5fUklHSFRfQ1VSTFkiLCJUT0tFTl9PUEVSQVRPUiIsIlRPS0VOX0NPTU1BIiwiVE9LRU5fQ09MT04iLCJUT0tFTl9USUxERSIsIlRPS0VOX1BJUEUiLCJUT0tFTl9JTlQiLCJUT0tFTl9GTE9BVCIsIlRPS0VOX0JPT0xFQU4iLCJUT0tFTl9OT05FIiwiVE9LRU5fU1lNQk9MIiwiVE9LRU5fU1BFQ0lBTCIsIlRPS0VOX1JFR0VYIiwiVG9rZW5pemVyIiwidGFncyIsImN1ciIsInRva2VuIiwicmVnZXhCb2R5IiwiUE9TU0lCTEVfRkxBR1MiLCJyZWdleEZsYWdzIiwiaXNDdXJyZW50QUZsYWciLCJmbGFncyIsImNvbXBsZXhPcHMiLCJjdXJDb21wbGV4IiwiZGVjIiwiYmVnaW5DaGFycyIsImluQ29tbWVudCIsImxhc3RMaW5lIiwiX3BhcnNlU3RyaW5nIiwiX21hdGNoZXMiLCJtIiwiX2V4dHJhY3RTdHJpbmciLCJfZXh0cmFjdFVudGlsIiwiY2hhclN0cmluZyIsIl9leHRyYWN0IiwiX2V4dHJhY3RNYXRjaGluZyIsImJyZWFrT25NYXRjaCIsInQiLCJfZXh0cmFjdFJlZ2V4IiwiaXNGaW5pc2hlZCIsImZvcndhcmROIiwiZm9yd2FyZCIsImJhY2tOIiwiYmFjayIsImN1cnJlbnRTdHIiLCJsZXgiLCJMb2FkZXIiLCJiYXNlVVJMIiwiZ2V0U291cmNlIiwidXNlQ2FjaGUiLCJub0NhY2hlIiwiZmV0Y2giLCJhamF4IiwibG9hZGluZyIsInN0YXR1cyIsInJlc3BvbnNlVGV4dCIsInVybCIsImxvYWRlcnMiLCJwcmVjb21waWxlIiwicnVudGltZSIsImluc3RhbGxKaW5qYUNvbXBhdCIsInRlbXBsYXRlc1BhdGgiLCJUZW1wbGF0ZUxvYWRlciIsIndhdGNoIiwiYXN5bmMiLCJOb2RlUmVzb2x2ZUxvYWRlciIsImNvbmZpZ3VyZSIsInJlc2V0IiwicHJlY29tcGlsZVN0cmluZyIsInN5bSIsImFzdCIsImFzdFQiLCJtYXBDT1ciLCJ3YWxrIiwicHJvcHNUIiwiZGVwdGhGaXJzdCIsIndhbGtlZCIsImRlcHRoV2FsayIsImRlc2NOb2RlIiwiZ2Vuc3ltIiwiX2xpZnRGaWx0ZXJzIiwiYmxvY2tOb2RlIiwiaGFzU3VwZXIiLCJjb252ZXJ0U3RhdGVtZW50cyIsImxpZnRTdXBlciIsImxpZnRGaWx0ZXJzIiwiY3BzIiwiYXN5bmNGaWx0ZXJzIiwiciIsIm51bSIsIm5vcm1hbGl6ZSIsIndpZHRoIiwic3BhY2VzIiwicG9zdCIsImJ5Iiwic2kiLCJhIiwidDEiLCJ0MiIsInNwIiwiZGVsIiwidGVzdE5hbWUiLCJnZXRTZWxlY3RPclJlamVjdCIsIm9yaWdpbmFsU3RyIiwibWF4Q291bnQiLCJuZXdfIiwibmV4dEluZGV4IiwicG9zIiwiZmFjdG9yIiwicm91bmRlciIsInNsaWNlTGVuZ3RoIiwiZXh0cmEiLCJjdXJyU2xpY2UiLCJmaWxsV2l0aCIsIngiLCJ5IiwicmV2ZXJzZWQiLCJ0cmltbWVkSW5wdXQiLCJvcmlnIiwiZW5jIiwia2V5dmFscyIsInB1bmNSZSIsImVtYWlsUmUiLCJodHRwSHR0cHNSZSIsInd3d1JlIiwidGxkUmUiLCJub0ZvbGxvd0F0dHIiLCJub2ZvbGxvdyIsInBvc3NpYmxlVXJsIiwic2hvcnRVcmwiLCJjb21waWxlZFRlbXBsYXRlcyIsIm9uZSIsImJvb2wiLCJpdGVtcyIsInNlcCIsInN0b3AiLCJjeWNsZXIiLCJqb2luZXIiLCJOdW5qdWNrc1ZpZXciLCJhcHAiLCJmcyIsIl9wcmV0dGlmeUVycm9yIiwicHJlY29tcGlsZUdsb2JhbCIsIl9wcmVjb21waWxlIiwicGF0aFN0YXRzIiwicHJlY29tcGlsZWQiLCJ0ZW1wbGF0ZXMiLCJmaWxlcGF0aCIsInN1YnBhdGgiLCJzdGF0IiwiYWRkVGVtcGxhdGVzIiwiY29uc29sZSIsIm91dCIsIm9yaWdfY29udGV4dE9yRnJhbWVMb29rdXAiLCJvcmlnX21lbWJlckxvb2t1cCIsIm9yaWdfQ29tcGlsZXJfYXNzZXJ0VHlwZSIsIm9yaWdfUGFyc2VyX3BhcnNlQWdncmVnYXRlIiwidG9rZW5zIiwiU2xpY2UiLCJvcmlnU3RhdGUiLCJnZXRUb2tlbnNTdGF0ZSIsImVyclN0YXRlIiwicmV0aHJvdyIsImlzU2xpY2UiLCJmaWVsZCIsIkFSUkFZX01FTUJFUlMiLCJhcHBlbmQiLCJpbnNlcnQiLCJPQkpFQ1RfTUVNQkVSUyIsImhhc19rZXkiLCJkZWYiLCJwb3BpdGVtIiwic2V0ZGVmYXVsdCIsInNsaWNlTG9va3VwIiwiQnJpZGdlIiwiQ2xpZW50IiwiYnJpZGdlTWFwIiwiYnJpZGdlIiwiY3VyQnJpZGdlTmFtZSIsImhhbmRsZVNpbmdsZUJyaWRnZSIsImN1ckJyaWRnZSIsIk1ldGhvZCIsIm1ldGhvZHMiLCJfZm4iLCJyZWZyZXNoIiwicGFyYW1zIiwiaW50ZXJjZXB0UGFyYW1zIiwicGFyYW0iLCJpc0NhbGxlZCIsIkludGVyZmFjZUxvZyIsImNvbmZpZyIsIl9nZW5lcmF0ZUNsaWVudCIsIl9pbml0U3VyZmFjZSIsImJyaWRnZXMiLCJfY2xpZW50IiwiX3N1cmZhY2UiLCJTdXJmYWNlIiwiJGRvbSIsIkxvZyIsImdldEZvbGRlZExpbmUiLCJwcmludENvbnRlbnQiLCJqc29uIiwiSlNPTlN0cmluZ2lmeSIsInByZXZpZXciLCJzdWJzdHIiLCJnZXRPYmpOYW1lIiwiX2dldE91dGVyIiwiJGxpbmUiLCJTdHJpbmcyRG9tIiwibnVuanVja3MiLCJmbG9kVHBsIiwibGluZVR5cGUiLCJxdWVyeVNlbGVjdG9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsIiRpbm5lciIsIiRvdXRlciIsImhhc0NsYXNzIiwicmVtb3ZlQ2xhc3MiLCJhZGRDbGFzcyIsIiRjb250ZW50IiwiX19wcm90b19fIiwiX3JlbmRlck1hcEtleXMiLCJfcmVuZGVyT2JqZWN0S2V5cyIsIl9yZW5kZXJQcm90b3R5cGUiLCJnZXRPYmpBbGxLZXlzIiwiX3JlbmRlckZsb3ciLCJ2YWx1ZVR5cGUiLCJrZXlUeXBlIiwiJHN1YiIsIl9nZW5lcmF0ZU1hcCIsIl9nZW5lcmF0ZUFycmF5IiwiX2dlbmVyYXRlT2JqZWN0IiwiX2dlbmVyYXRlTm9ybWFsIiwiaW5zZXJ0QWRqYWNlbnRFbGVtZW50IiwiZmxvZENvZGVUcGwiLCJodG1sRW5jb2RlIiwiJHByb3RvIiwiX3JlbmRlciIsIl9pbml0VW5pdCIsIl9pbml0RXZlbnQiLCJkcHIiLCJkZXZpY2VQaXhlbFJhdGlvIiwidmlld3BvcnRFbCIsImRvY3VtZW50IiwiaW5pdGlhbFNjYWxlIiwic2NhbGUiLCIkcm9vdCIsInN0eWxlIiwiZm9udFNpemUiLCJhZGREb21TdHJpbmciLCJfcmVuZGVyR2VuZXJhbCIsImRvY3VtZW50RWxlbWVudCIsImluZGV4VHBsIiwiJGJ0biIsIiRwYW5lbCIsIiRoaWRlIiwiJG1hc2siLCIkY2xlYXIiLCJkaXNwbGF5IiwiaW5uZXJIVE1MIiwiZG9tIiwiZnVuIiwiJHJlZnJlc2giLCJkaXN0IiwidHBsIiwiY3JlYXRlRWxlbWVudCIsImVsIiwiY2xhc3NOYW1lIiwicmVnIiwiY2xhc3NMaXN0IiwiaXNXaW5kb3ciLCJzdHJpbmdPYmplY3QiLCJzdWZmaXgiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGV4dCIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJwYXJlbnROb2RlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWE7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0FBLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQixVQUFVQyxzQkFBVixFQUFrQztBQUNqRCxNQUFJQyxJQUFJLEdBQUcsRUFBWCxDQURpRCxDQUNsQzs7QUFFZkEsTUFBSSxDQUFDQyxRQUFMLEdBQWdCLFNBQVNBLFFBQVQsR0FBb0I7QUFDbEMsV0FBTyxLQUFLQyxHQUFMLENBQVMsVUFBVUMsSUFBVixFQUFnQjtBQUM5QixVQUFJQyxPQUFPLEdBQUdMLHNCQUFzQixDQUFDSSxJQUFELENBQXBDOztBQUVBLFVBQUlBLElBQUksQ0FBQyxDQUFELENBQVIsRUFBYTtBQUNYLGVBQU8sVUFBVUUsTUFBVixDQUFpQkYsSUFBSSxDQUFDLENBQUQsQ0FBckIsRUFBMEIsSUFBMUIsRUFBZ0NFLE1BQWhDLENBQXVDRCxPQUF2QyxFQUFnRCxHQUFoRCxDQUFQO0FBQ0Q7O0FBRUQsYUFBT0EsT0FBUDtBQUNELEtBUk0sRUFRSkUsSUFSSSxDQVFDLEVBUkQsQ0FBUDtBQVNELEdBVkQsQ0FIaUQsQ0FhOUM7QUFDSDs7O0FBR0FOLE1BQUksQ0FBQ08sQ0FB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LypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSkge1xuICB2YXIgX2l0ZW0gPSBfc2xpY2VkVG9BcnJheShpdGVtLCA0KSxcbiAgICAgIGNvbnRlbnQgPSBfaXRlbVsxXSxcbiAgICAgIGNzc01hcHBpbmcgPSBfaXRlbVszXTtcblxuICBpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgJycpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn07IiwiLyoqXG4gKiBAbGljZW5zZVxuICogTG9kYXNoIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZS1FUzUgZW52aXJvbm1lbnRzLiAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci4gKi9cbiAgdmFyIFZFUlNJT04gPSAnNC4xNy4yMCc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG4gIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4gIC8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbiAgdmFyIENPUkVfRVJST1JfVEVYVCA9ICdVbnN1cHBvcnRlZCBjb3JlLWpzIHVzZS4gVHJ5IGh0dHBzOi8vbnBtcy5pby9zZWFyY2g/cT1wb255ZmlsbC4nLFxuICAgICAgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4gIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbiAgdmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbiAgdmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbiAgdmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbiAgdmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICB2YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIFdSQVBfQ1VSUllfQk9VTkRfRkxBRyA9IDQsXG4gICAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcbiAgICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsXG4gICAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcblxuICAvKiogVXNlZCBhcyBkZWZhdWx0IG9wdGlvbnMgZm9yIGBfLnRydW5jYXRlYC4gKi9cbiAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsXG4gICAgICBERUZBVUxUX1RSVU5DX09NSVNTSU9OID0gJy4uLic7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xuICB2YXIgSE9UX0NPVU5UID0gODAwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cbiAgdmFyIExBWllfRklMVEVSX0ZMQUcgPSAxLFxuICAgICAgTEFaWV9NQVBfRkxBRyA9IDIsXG4gICAgICBMQVpZX1dISUxFX0ZMQUcgPSAzO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICB2YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxuICAgICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICAgIE5BTiA9IDAgLyAwO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG4gIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcbiAgICAgIE1BWF9BUlJBWV9JTkRFWCA9IE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgSEFMRl9NQVhfQVJSQVlfTEVOR1RIID0gTUFYX0FSUkFZX0xFTkdUSCA+Pj4gMTtcblxuICAvKiogVXNlZCB0byBhc3NvY2lhdGUgd3JhcCBtZXRob2RzIHdpdGggdGhlaXIgYml0IGZsYWdzLiAqL1xuICB2YXIgd3JhcEZsYWdzID0gW1xuICAgIFsnYXJ5JywgV1JBUF9BUllfRkxBR10sXG4gICAgWydiaW5kJywgV1JBUF9CSU5EX0ZMQUddLFxuICAgIFsnYmluZEtleScsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gICAgWydjdXJyeScsIFdSQVBfQ1VSUllfRkxBR10sXG4gICAgWydjdXJyeVJpZ2h0JywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxcbiAgICBbJ2ZsaXAnLCBXUkFQX0ZMSVBfRkxBR10sXG4gICAgWydwYXJ0aWFsJywgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICAgIFsncGFydGlhbFJpZ2h0JywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFxuICAgIFsncmVhcmcnLCBXUkFQX1JFQVJHX0ZMQUddXG4gIF07XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJyxcbiAgICAgIHdlYWtTZXRUYWcgPSAnW29iamVjdCBXZWFrU2V0XSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOSk7L2csXG4gICAgICByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLFxuICAgICAgcmVIYXNSZWdFeHBDaGFyID0gUmVnRXhwKHJlUmVnRXhwQ2hhci5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG4gIHZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZyxcbiAgICAgIHJlVHJpbVN0YXJ0ID0gL15cXHMrLyxcbiAgICAgIHJlVHJpbUVuZCA9IC9cXHMrJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG4gIHZhciByZVdyYXBDb21tZW50ID0gL1xceyg/OlxcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggLitcXF0gXFwqXFwvKT9cXG4/LyxcbiAgICAgIHJlV3JhcERldGFpbHMgPSAvXFx7XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAoLispXFxdIFxcKi8sXG4gICAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoXG4gICAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gICAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbiAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbiAgdmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xuICB2YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICAgIHJzRGluZ2JhdFJhbmdlID0gJ1xcXFx1MjcwMC1cXFxcdTI3YmYnLFxuICAgICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgICAgcnNOb25DaGFyUmFuZ2UgPSAnXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmJyxcbiAgICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgICByc1VwcGVyUmFuZ2UgPSAnQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlJyxcbiAgICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG4gIHZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICAgIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzQnJlYWsgPSAnWycgKyByc0JyZWFrUmFuZ2UgKyAnXScsXG4gICAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG4gIHZhciByc01pc2NMb3dlciA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzTWlzY1VwcGVyID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNPcHRDb250ckxvd2VyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycsXG4gICAgICByc09wdENvbnRyVXBwZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgICAgcnNPcmRMb3dlciA9ICdcXFxcZCooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXFxcZHRoKSg/PVxcXFxifFtBLVpfXSknLFxuICAgICAgcnNPcmRVcHBlciA9ICdcXFxcZCooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXFxcZFRIKSg/PVxcXFxifFthLXpfXSknLFxuICAgICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXEsXG4gICAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbiAgdmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAgICovXG4gIHZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG4gIHZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xuICB2YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gICAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc01pc2NVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNVcHBlciArICc/JyArIHJzTWlzY0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyLFxuICAgIHJzVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIsXG4gICAgcnNPcmRVcHBlcixcbiAgICByc09yZExvd2VyLFxuICAgIHJzRGlnaXRzLFxuICAgIHJzRW1vamlcbiAgXS5qb2luKCd8JyksICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG4gIHZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMuICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0J1ZmZlcicsICdEYXRhVmlldycsICdEYXRlJywgJ0Vycm9yJywgJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hcCcsICdNYXRoJywgJ09iamVjdCcsXG4gICAgJ1Byb21pc2UnLCAnUmVnRXhwJywgJ1NldCcsICdTdHJpbmcnLCAnU3ltYm9sJywgJ1R5cGVFcnJvcicsICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCcsXG4gICAgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IC0xO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbiAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xuICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICBjbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAgICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAgICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAgICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICAgJ1xceGRmJzogJ3NzJyxcbiAgICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAgICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAgICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAgICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAgICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAgICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAgICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAgICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAgICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAgICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAgICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAgICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAgICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAgICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbiAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXG4gIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJiMzOTsnOiBcIidcIlxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuICB2YXIgZnJlZVBhcnNlRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuICAvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbiAgdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgICBpZiAodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0oKSk7XG5cbiAgLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlcixcbiAgICAgIG5vZGVJc0RhdGUgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0RhdGUsXG4gICAgICBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcCxcbiAgICAgIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLFxuICAgICAgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQsXG4gICAgICBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaFJpZ2h0KGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5ldmVyeWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZVJpZ2h0KGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVstLWxlbmd0aF07XG4gICAgfVxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgdmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZmluZEtleWAgYW5kIGBfLmZpbmRMYXN0S2V5YCxcbiAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICAgKiB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEtleShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZldpdGgoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZWFuYCBhbmQgYF8ubWVhbkJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlTWVhbihhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IChiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkgLyBsZW5ndGgpIDogTkFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXG4gICAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gICAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAgICogdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zdW1gIGFuZCBgXy5zdW1CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSk7XG4gICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gY3VycmVudCA6IChyZXN1bHQgKyBjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gICAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9QYWlyc2AgYW5kIGBfLnRvUGFpcnNJbmAgd2hpY2ggY3JlYXRlcyBhbiBhcnJheVxuICAgKiBvZiBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVG9QYWlycyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAgICogb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltU3RhcnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBgcGxhY2Vob2xkZXJgIG9jY3VycmVuY2VzIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvdW50SG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgKytyZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYGl0ZXJhdG9yYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZXJhdG9yIFRoZSBpdGVyYXRvciB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgIHZhciBkYXRhLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGRhdGEudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAodmFsdWUgPT09IHBsYWNlaG9sZGVyIHx8IHZhbHVlID09PSBQTEFDRUhPTERFUikge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBbdmFsdWUsIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5sYXN0SW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggKyAxO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDEuMS4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7ICdmb28nOiBfLmNvbnN0YW50KCdmb28nKSB9KTtcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG4gICAqIGxvZGFzaC5taXhpbih7ICdiYXInOiBsb2Rhc2guY29uc3RhbnQoJ2JhcicpIH0pO1xuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqIF8uaXNGdW5jdGlvbihfLmJhcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5mb28pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guYmFyKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiAvLyBDcmVhdGUgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanMuXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG4gICAqL1xuICB2YXIgcnVuSW5Db250ZXh0ID0gKGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IGNvbnRleHQgPT0gbnVsbCA/IHJvb3QgOiBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKTtcblxuICAgIC8qKiBCdWlsdC1pbiBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG4gICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbiAgICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gICAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG4gICAgdmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cbiAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyBjb250ZXh0LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgU3ltYm9sID0gY29udGV4dC5TeW1ib2wsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBjb250ZXh0LlVpbnQ4QXJyYXksXG4gICAgICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkLFxuICAgICAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICAgICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1JdGVyYXRvciA9IFN5bWJvbCA/IFN5bWJvbC5pdGVyYXRvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgICAgICBmdW5jKHt9LCAnJywge30pO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSgpKTtcblxuICAgIC8qKiBNb2NrZWQgYnVpbHQtaW5zLiAqL1xuICAgIHZhciBjdHhDbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCAhPT0gcm9vdC5jbGVhclRpbWVvdXQgJiYgY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGN0eE5vdyA9IERhdGUgJiYgRGF0ZS5ub3cgIT09IHJvb3QuRGF0ZS5ub3cgJiYgRGF0ZS5ub3csXG4gICAgICAgIGN0eFNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQgIT09IHJvb3Quc2V0VGltZW91dCAmJiBjb250ZXh0LnNldFRpbWVvdXQ7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IERhdGUubm93LFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tLFxuICAgICAgICBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgIHZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShjb250ZXh0LCAnRGF0YVZpZXcnKSxcbiAgICAgICAgTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdNYXAnKSxcbiAgICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShjb250ZXh0LCAnUHJvbWlzZScpLFxuICAgICAgICBTZXQgPSBnZXROYXRpdmUoY29udGV4dCwgJ1NldCcpLFxuICAgICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdXZWFrTWFwJyksXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG4gICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICAgICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgICAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG4gICAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBpbXBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcbiAgICAgKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAgICAgKiBvciBtYXkgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHNlcXVlbmNlXG4gICAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXG4gICAgICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gICAgICpcbiAgICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXG4gICAgICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cbiAgICAgKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICAgICAqIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgYXJyYXlzIGFuZCBjYW4gZ3JlYXRseSByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gICAgICogb25lIGFyZ3VtZW50LiBUaGUgaGV1cmlzdGljIGZvciB3aGV0aGVyIGEgc2VjdGlvbiBxdWFsaWZpZXMgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYF8jdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gbG9kYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGhhdmUgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gICAgICogYGNvbmNhdGAsIGBqb2luYCwgYHBvcGAsIGBwdXNoYCwgYHNoaWZ0YCwgYHNvcnRgLCBgc3BsaWNlYCwgYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gICAgICogYHJlcGxhY2VgIGFuZCBgc3BsaXRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICAgICAqIGBhdGAsIGBjb21wYWN0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BXaGlsZWAsIGBmaWx0ZXJgLCBgZmluZGAsXG4gICAgICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXG4gICAgICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAgICAgKiBgYmVmb3JlYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNhc3RBcnJheWAsIGBjaGFpbmAsIGBjaHVua2AsXG4gICAgICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXG4gICAgICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gICAgICogYGRpZmZlcmVuY2VgLCBgZGlmZmVyZW5jZUJ5YCwgYGRpZmZlcmVuY2VXaXRoYCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCxcbiAgICAgKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcbiAgICAgKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gICAgICogYGZsYXR0ZW5EZXB0aGAsIGBmbGlwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCwgYGZyb21QYWlyc2AsIGBmdW5jdGlvbnNgLFxuICAgICAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcbiAgICAgKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAgICAgKiBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCwgYG1hcEtleXNgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLCBgbWF0Y2hlc1Byb3BlcnR5YCxcbiAgICAgKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXG4gICAgICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gICAgICogYG92ZXJFdmVyeWAsIGBvdmVyU29tZWAsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwYXJ0aXRpb25gLCBgcGlja2AsXG4gICAgICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxuICAgICAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gICAgICogYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2FtcGxlU2l6ZWAsIGBzZXRgLCBgc2V0V2l0aGAsIGBzaHVmZmxlYCxcbiAgICAgKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICAgICAqIGB0b1BhaXJzYCwgYHRvUGFpcnNJbmAsIGB0b1BhdGhgLCBgdG9QbGFpbk9iamVjdGAsIGB0cmFuc2Zvcm1gLCBgdW5hcnlgLFxuICAgICAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXG4gICAgICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gICAgICogYHZhbHVlc0luYCwgYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgeG9yQnlgLCBgeG9yV2l0aGAsIGB6aXBgLFxuICAgICAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBhcmUgKipub3QqKiBjaGFpbmFibGUgYnkgZGVmYXVsdCBhcmU6XG4gICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxuICAgICAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICAgICAqIGBkZWZhdWx0VG9gLCBgZGl2aWRlYCwgYGVhY2hgLCBgZWFjaFJpZ2h0YCwgYGVuZHNXaXRoYCwgYGVxYCwgYGVzY2FwZWAsXG4gICAgICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcbiAgICAgKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gICAgICogYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCwgYGdldGAsIGBndGAsIGBndGVgLCBgaGFzYCxcbiAgICAgKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcbiAgICAgKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAgICAgKiBgaXNCb29sZWFuYCwgYGlzQnVmZmVyYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLCBgaXNFbXB0eWAsIGBpc0VxdWFsYCxcbiAgICAgKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXG4gICAgICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAgICAgKiBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLCBgaXNPYmplY3RMaWtlYCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLFxuICAgICAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXG4gICAgICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gICAgICogYGxvd2VyQ2FzZWAsIGBsb3dlckZpcnN0YCwgYGx0YCwgYGx0ZWAsIGBtYXhgLCBgbWF4QnlgLCBgbWVhbmAsIGBtZWFuQnlgLFxuICAgICAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcbiAgICAgKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAgICAgKiBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2FtcGxlYCwgYHNoaWZ0YCwgYHNpemVgLFxuICAgICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXG4gICAgICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICAgICAqIGBzdHViT2JqZWN0YCwgYHN0dWJTdHJpbmdgLCBgc3R1YlRydWVgLCBgc3VidHJhY3RgLCBgc3VtYCwgYHN1bUJ5YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXG4gICAgICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICAgICAqIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGB0cnVuY2F0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGB1cHBlckNhc2VgLFxuICAgICAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoc3F1YXJlKTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgY2hhaW4gc2VxdWVuY2Ugd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAwO1xuICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gICAgICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB3cmFwcGVycyBhcmUgaW5zdGFuY2VzIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gTUFYX0FSUkFZX0xFTkdUSDtcbiAgICAgIHRoaXMuX192aWV3c19fID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICByZXN1bHQuX19pdGVyYXRlZXNfXyA9IGNvcHlBcnJheSh0aGlzLl9faXRlcmF0ZWVzX18pO1xuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICByZXN1bHQuX192aWV3c19fID0gY29weUFycmF5KHRoaXMuX192aWV3c19fKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5UmV2ZXJzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyA9IC0xO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLFxuICAgICAgICAgIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxuICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGlzQXJyID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcbiAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXG4gICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuXG4gICAgICBpZiAoIWlzQXJyIHx8ICghaXNSaWdodCAmJiBhcnJMZW5ndGggPT0gbGVuZ3RoICYmIHRha2VDb3VudCA9PSBsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGBMYXp5V3JhcHBlcmAgaXMgYW4gaW5zdGFuY2Ugb2YgYGJhc2VMb2Rhc2hgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG4gICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuICAgIEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG4gICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgLS10aGlzLnNpemU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgYWRkXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQGFsaWFzIHB1c2hcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICAgICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gICAgICB9XG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICBTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG4gICAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuICAgIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcbiAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICAgICAgKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVTaXplYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycmF5KSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAgICAgKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFnZ3JlZ2F0ZXMgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIG9uIGBhY2N1bXVsYXRvcmAgd2l0aCBrZXlzIHRyYW5zZm9ybWVkXG4gICAgICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICAgICAqIHZhbHVlIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBza2lwID0gb2JqZWN0ID09IG51bGw7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBza2lwID8gdW5kZWZpbmVkIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xhbXBgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7XG4gICAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gICAgICogdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIERlZXAgY2xvbmVcbiAgICAgKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgKiAgNCAtIENsb25lIHN5bWJvbHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZDtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICAgICAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gICAgICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zVG9gIHdoaWNoIGFjY2VwdHMgYHByb3BzYCB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSxcbiAgICAgICAgICAgIHByZWRpY2F0ZSA9IHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAoKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkgfHwgIXByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXG4gICAgICogdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2hSaWdodCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd25SaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gICAgICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxuICAgICAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVuZCA9IHN0YXJ0ID4gZW5kID8gMCA6IHRvTGVuZ3RoKGVuZCk7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gICAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICAgICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBgb2JqZWN0YCBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmaWx0ZXJlZCBmcm9tIGBwcm9wc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmaWx0ZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gICAgICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgICAgIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICAgICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmd0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pblJhbmdlYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBudW1iZXIgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIG51bWJlciA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5jbHVkZXMgPSBjb21wYXJhdG9yID8gYXJyYXlJbmNsdWRlc1dpdGggOiBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBBcnJheShvdGhMZW5ndGgpLFxuICAgICAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuICAgICAgICBpZiAob3RoSW5kZXggJiYgaXRlcmF0ZWUpIHtcbiAgICAgICAgICBhcnJheSA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhMZW5ndGggPSBuYXRpdmVNaW4oYXJyYXkubGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgICBjYWNoZXNbb3RoSW5kZXhdID0gIWNvbXBhcmF0b3IgJiYgKGl0ZXJhdGVlIHx8IChsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjApKVxuICAgICAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmICghKHNlZW5cbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgOiBpbmNsdWRlcyhyZXN1bHQsIGNvbXB1dGVkLCBjb21wYXJhdG9yKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgICAgID8gY2FjaGVIYXMoY2FjaGUsIGNvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCwgY29tcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludmVydGAgYW5kIGBfLmludmVydEJ5YCB3aGljaCBpbnZlcnRzXG4gICAgICogYG9iamVjdGAgd2l0aCB2YWx1ZXMgdHJhbnNmb3JtZWQgYnkgYGl0ZXJhdGVlYCBhbmQgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCBpdGVyYXRlZSh2YWx1ZSksIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludm9rZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogbWV0aG9kIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgdmFyIGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXBwbHkoZnVuYywgb2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcnJheUJ1ZmZlcmAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcnJheUJ1ZmZlclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0RhdGVgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gZGF0ZVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gICAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gICAgICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICAgICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAgICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICAgICAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5udGhgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU50aChhcnJheSwgbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG4gKz0gbiA8IDAgPyBsZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGlzSW5kZXgobiwgbGVuZ3RoKSA/IGFycmF5W25dIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICBpZiAoaXRlcmF0ZWVzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoaXRlcmF0ZWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2VHZXQodmFsdWUsIGl0ZXJhdGVlLmxlbmd0aCA9PT0gMSA/IGl0ZXJhdGVlWzBdIDogaXRlcmF0ZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBbGxCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgICAqIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleE9mID0gY29tcGFyYXRvciA/IGJhc2VJbmRleE9mV2l0aCA6IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICBzZWVuID0gYXJyYXk7XG5cbiAgICAgIGlmIChhcnJheSA9PT0gdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IGNvcHlBcnJheSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4gPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gYXJyYXkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKHNlZW4sIGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBsYXN0SW5kZXggfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgaWYgKGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgICAgIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gICAgICogY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKCFzdHJpbmcgfHwgbiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cbiAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHBvbmVudGlhdGlvbl9ieV9zcXVhcmluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgZG8ge1xuICAgICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBhcnJheVNhbXBsZSh2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZVNpemVgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZVNpemUoY29sbGVjdGlvbiwgbikge1xuICAgICAgdmFyIGFycmF5ID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGFycmF5LCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleGAgYW5kIGBfLnNvcnRlZExhc3RJbmRleGAgd2hpY2hcbiAgICAgKiBwZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJlxuICAgICAgICAgICAgICAocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleEJ5YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4QnlgXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXG4gICAgICogdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgdmFyIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLFxuICAgICAgICAgIHZhbElzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IG5hdGl2ZUZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgICAgIG90aElzRGVmaW5lZCA9IGNvbXB1dGVkICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBjb21wdXRlZCA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChjb21wdXRlZCk7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IHJldEhpZ2hlc3QgfHwgb3RoSXNSZWZsZXhpdmU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZmluZWQpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBvdGhJc0RlZmluZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzTnVsbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNOdWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc1N5bWJvbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZFVuaXFgIGFuZCBgXy5zb3J0ZWRVbmlxQnlgIHdpdGhvdXRcbiAgICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIGlmICghaW5kZXggfHwgIWVxKGNvbXB1dGVkLCBzZWVuKSkge1xuICAgICAgICAgIHZhciBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9OdW1iZXJgIHdoaWNoIGRvZXNuJ3QgZW5zdXJlIGNvcnJlY3RcbiAgICAgKiBjb252ZXJzaW9ucyBvZiBiaW5hcnksIGhleGFkZWNpbWFsLCBvciBvY3RhbCBzdHJpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICAgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51cGRhdGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHJldHVybiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdXBkYXRlcihiYXNlR2V0KG9iamVjdCwgcGF0aCkpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZHJvcFdoaWxlYCBhbmQgYF8udGFrZVdoaWxlYFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRHJvcF0gU3BlY2lmeSBkcm9wcGluZyBlbGVtZW50cyBpbnN0ZWFkIG9mIHRha2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgaXNEcm9wLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkgJiZcbiAgICAgICAgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cblxuICAgICAgcmV0dXJuIGlzRHJvcFxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxuICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZXJmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdyYXBwZXJWYWx1ZSh2YWx1ZSwgYWN0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC52YWx1ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGFjdGlvbnMsIGZ1bmN0aW9uKHJlc3VsdCwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHRdLCBhY3Rpb24uYXJncykpO1xuICAgICAgfSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ueG9yYCwgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWG9yKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VVbmlxKGFycmF5c1swXSkgOiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpbmRleF0sXG4gICAgICAgICAgICBvdGhJbmRleCA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK290aEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG90aEluZGV4ICE9IGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gYmFzZURpZmZlcmVuY2UocmVzdWx0W2luZGV4XSB8fCBhcnJheSwgYXJyYXlzW290aEluZGV4XSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKHJlc3VsdCwgMSksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uemlwT2JqZWN0YCB3aGljaCBhc3NpZ25zIHZhbHVlcyB1c2luZyBgYXNzaWduRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25GdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVppcE9iamVjdChwcm9wcywgdmFsdWVzLCBhc3NpZ25GdW5jKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgdmFsc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0LCBwcm9wc1tpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgYGJhc2VSZXN0YCBhbGlhcyB3aGljaCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgaWRlbnRpdHlgIGJ5IG1vZHVsZVxuICAgICAqIHJlcGxhY2VtZW50IHBsdWdpbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciBjYXN0UmVzdCA9IGJhc2VSZXN0O1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gICAgICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgY2xlYXJUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vY2xlYXJUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBpZCBUaGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3Qgb2YgdGhlIHRpbWVyIHRvIGNsZWFyLlxuICAgICAqL1xuICAgIHZhciBjbGVhclRpbWVvdXQgPSBjdHhDbGVhclRpbWVvdXQgfHwgZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiByb290LmNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICBidWZmZXIuY29weShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gICAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAgICpcbiAgICAgKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgICAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZWZ0TGVuZ3RoICsgcmFuZ2VMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShyYW5nZUxlbmd0aCArIHJpZ2h0TGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcblxuICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYWNjdW11bGF0b3IpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcbiAgICAgICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob2xkZXJzID0gKGxlbmd0aCA8IDMgJiYgYXJnc1swXSAhPT0gcGxhY2Vob2xkZXIgJiYgYXJnc1tsZW5ndGggLSAxXSAhPT0gcGxhY2Vob2xkZXIpXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyZ3MsIGhvbGRlcnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSAtIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihmdW5jcykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZnVuY3MubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuXG4gICAgICAgIGlmIChmcm9tUmlnaHQpIHtcbiAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlcmVxICYmICF3cmFwcGVyICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IGluZGV4IDogbGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG5cbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pICYmXG4gICAgICAgICAgICAgICAgZGF0YVsxXSA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSAmJlxuICAgICAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSAoZnVuYy5sZW5ndGggPT0gMSAmJiBpc0xhemlhYmxlKGZ1bmMpKVxuICAgICAgICAgICAgICA/IHdyYXBwZXJbZnVuY05hbWVdKClcbiAgICAgICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuXG4gICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIucGxhbnQodmFsdWUpLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxlbmd0aCA/IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkXG4gICAgICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUh5YnJpZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLFxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSxcbiAgICAgICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyaWVkKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxuICAgICAgICAgICAgICBob2xkZXJzQ291bnQgPSBjb3VudEhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xuICAgICAgICBpZiAoaXNDdXJyaWVkICYmIGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHRoaXNBcmcsXG4gICAgICAgICAgICBhcmdzLCBuZXdIb2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkgLSBsZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmludmVydEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRvSXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludmVydGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmVydGVyKHNldHRlciwgdG9JdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgdG9JdGVyYXRlZShpdGVyYXRlZSksIHt9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSB1c2VkIGZvciBgdW5kZWZpbmVkYCBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXRoT3BlcmF0aW9uKG9wZXJhdG9yLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9TdHJpbmcob3RoZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb051bWJlcihvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ub3ZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBvdmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU92ZXIoYXJyYXlGdW5jKSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oaXRlcmF0ZWVzKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICB2YXIgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIGBsZW5ndGhgLiBUaGUgYGNoYXJzYCBzdHJpbmdcbiAgICAgKiBpcyB0cnVuY2F0ZWQgaWYgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VlZHMgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZCA/ICcgJyA6IGJhc2VUb1N0cmluZyhjaGFycyk7XG5cbiAgICAgIHZhciBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJzTGVuZ3RoID8gYmFzZVJlcGVhdChjaGFycywgbGVuZ3RoKSA6IGNoYXJzO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VSZXBlYXQoY2hhcnMsIG5hdGl2ZUNlaWwobGVuZ3RoIC8gc3RyaW5nU2l6ZShjaGFycykpKTtcbiAgICAgIHJldHVybiBoYXNVbmljb2RlKGNoYXJzKVxuICAgICAgICA/IGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHJlc3VsdCksIDAsIGxlbmd0aCkuam9pbignJylcbiAgICAgICAgOiByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gICAgICogb2YgYHRoaXNBcmdgIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXG4gICAgICAgICAgICBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogdG9GaW5pdGUoc3RlcCk7XG4gICAgICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSByZWxhdGlvbmFsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlbGF0aW9uYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24ob3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBvdGhlciA9IHRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgYGZ1bmNgIHdyYXBwZXIuXG4gICAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNDdXJyeSA9IGJpdG1hc2sgJiBXUkFQX0NVUlJZX0ZMQUcsXG4gICAgICAgICAgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IHBhcnRpYWxzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogcGFydGlhbHM7XG5cbiAgICAgIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgOiBXUkFQX1BBUlRJQUxfRkxBRyk7XG5cbiAgICAgIGlmICghKGJpdG1hc2sgJiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgICAgIG5ld0hvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLnJvdW5kYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBNYXRoW21ldGhvZE5hbWVdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gMCA6IG5hdGl2ZU1pbih0b0ludGVnZXIocHJlY2lzaW9uKSwgMjkyKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiAmJiBuYXRpdmVJc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgLy8gU2hpZnQgd2l0aCBleHBvbmVudGlhbCBub3RhdGlvbiB0byBhdm9pZCBmbG9hdGluZy1wb2ludCBpc3N1ZXMuXG4gICAgICAgICAgLy8gU2VlIFtNRE5dKGh0dHBzOi8vbWRuLmlvL3JvdW5kI0V4YW1wbGVzKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHZhciBwYWlyID0gKHRvU3RyaW5nKG51bWJlcikgKyAnZScpLnNwbGl0KCdlJyksXG4gICAgICAgICAgICAgIHZhbHVlID0gZnVuYyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdICsgcHJlY2lzaW9uKSk7XG5cbiAgICAgICAgICBwYWlyID0gKHRvU3RyaW5nKHZhbHVlKSArICdlJykuc3BsaXQoJ2UnKTtcbiAgICAgICAgICByZXR1cm4gKyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdIC0gcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy50b1BhaXJzYCBvciBgXy50b1BhaXJzSW5gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhaXJzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRvUGFpcnMoa2V5c0Z1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgICAgICBpZiAodGFnID09IG1hcFRhZykge1xuICAgICAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9QYWlycyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlVG9QYWlycyhvYmplY3QsIGtleXNGdW5jKG9iamVjdCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogICAgMSAtIGBfLmJpbmRgXG4gICAgICogICAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICogICAgOCAtIGBfLmN1cnJ5YFxuICAgICAqICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICAgICAqICAgMzIgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAgNjQgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gICAgICogIDEyOCAtIGBfLnJlYXJnYFxuICAgICAqICAyNTYgLSBgXy5hcnlgXG4gICAgICogIDUxMiAtIGBfLmZsaXBgXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJ5ID0gYXJ5ID09PSB1bmRlZmluZWQgPyBhcnkgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKGFyeSksIDApO1xuICAgICAgYXJpdHkgPSBhcml0eSA9PT0gdW5kZWZpbmVkID8gYXJpdHkgOiB0b0ludGVnZXIoYXJpdHkpO1xuICAgICAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmIChiaXRtYXNrICYgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnNSaWdodCA9IGhvbGRlcnM7XG5cbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpO1xuXG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCxcbiAgICAgICAgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgICBmdW5jID0gbmV3RGF0YVswXTtcbiAgICAgIGJpdG1hc2sgPSBuZXdEYXRhWzFdO1xuICAgICAgdGhpc0FyZyA9IG5ld0RhdGFbMl07XG4gICAgICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gICAgICBob2xkZXJzID0gbmV3RGF0YVs0XTtcbiAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XSA9IG5ld0RhdGFbOV0gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgICAgIDogbmF0aXZlTWF4KG5ld0RhdGFbOV0gLSBsZW5ndGgsIDApO1xuXG4gICAgICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKTtcbiAgICAgIH1cbiAgICAgIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpO1xuICAgICAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSk7XG4gICAgICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWQuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0LCBuZXdEYXRhKSwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gICAgICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAgICAgKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzRGVlcGAgdG8gY3VzdG9taXplIGl0cyBgXy5tZXJnZWAgdXNlIHRvIG1lcmdlIHNvdXJjZVxuICAgICAqIG9iamVjdHMgaW50byBkZXN0aW5hdGlvbiBvYmplY3RzIHRoYXQgYXJlIHBhc3NlZCB0aHJ1LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgcGFyZW50IG9iamVjdCBvZiBgc3JjVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykge1xuICAgICAgaWYgKGlzT2JqZWN0KG9ialZhbHVlKSAmJiBpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xuICAgICAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9taXRgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uY2xvbmVEZWVwYCB1c2UgdG8gb25seSBjbG9uZSBwbGFpblxuICAgICAqIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bmNsb25lZCB2YWx1ZSBvciBgdW5kZWZpbmVkYCB0byBkZWZlciBjbG9uaW5nIHRvIGBfLmNsb25lRGVlcGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tT21pdENsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gICAgICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gICAgICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gICAgICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgaWYgKG9ialN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICAgICAgbGVuZ3RoID0gaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIHJlc3VsdCkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFyZ3VtZW50IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcihmdW5jKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gsICdwbGFjZWhvbGRlcicpID8gbG9kYXNoIDogZnVuYztcbiAgICAgIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpdGVyYXRlZVwiIGZ1bmN0aW9uLiBJZiBgXy5pdGVyYXRlZWAgaXMgY3VzdG9taXplZCxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBiYXNlSXRlcmF0ZWVgLlxuICAgICAqIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjaG9zZW4gZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiB0aGUgY3JlYXRlZCBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGVlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJlc3VsdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgICA6IGRhdGEubWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHVubWFza2VkKSB7XG4gICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIHZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4gICAgLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuICAgIGlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAgICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgICAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAgICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICAgICAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgICAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd3JhcHBlciBkZXRhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gaW5zZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIGRldGFpbHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGRldGFpbHNbbGFzdEluZGV4XSA9IChsZW5ndGggPiAxID8gJyYgJyA6ICcnKSArIGRldGFpbHNbbGFzdEluZGV4XTtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgY2FwYWJsZSBvZiBiZWluZyBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2FibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICB2YXIgaXNNYXNrYWJsZSA9IGNvcmVKc0RhdGEgPyBpc0Z1bmN0aW9uIDogc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gICAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gICAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kXG4gICAgICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAgICAgKiBhbiBleGNlcHRpb24gZm9yIGEgc2FmZSBjb21iaW5lZCBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YFxuICAgICAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgKFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHIHwgV1JBUF9BUllfRkxBRyk7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcpICYmIChkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0FSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAgICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gICAgICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYHNldFRpbWVvdXRgXShodHRwczovL21kbi5pby9zZXRUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgIHJldHVybiByb290LnNldFRpbWVvdXQoZnVuYywgd2FpdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGB3cmFwcGVyYCB0byBtaW1pYyB0aGUgc291cmNlIG9mIGByZWZlcmVuY2VgXG4gICAgICogd2l0aCB3cmFwcGVyIGRldGFpbHMgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIHNvdXJjZSBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYHdyYXBwZXJgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdyYXBUb1N0cmluZyh3cmFwcGVyLCByZWZlcmVuY2UsIGJpdG1hc2spIHtcbiAgICAgIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAgICAgKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAgICAgKiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBhcnJheS5sZW5ndGggPSBzaXplO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gICAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHdyYXBwZXIgYGRldGFpbHNgIGJhc2VkIG9uIGBiaXRtYXNrYCBmbGFncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xuICAgICAgYXJyYXlFYWNoKHdyYXBGbGFncywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICB2YXIgdmFsdWUgPSAnXy4nICsgcGFpclswXTtcbiAgICAgICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XG4gICAgICAgICAgZGV0YWlscy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGV0YWlscy5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19pbmRleF9fICA9IHdyYXBwZXIuX19pbmRleF9fO1xuICAgICAgcmVzdWx0Ll9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGFycmF5YCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmtcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBuYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUpLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHNpemUgPCAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgY29uY2F0ZW5hdGluZyBgYXJyYXlgIHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXG4gICAgICogYW5kL29yIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAgICogdmFyIG90aGVyID0gXy5jb25jYXQoYXJyYXksIDIsIFszXSwgW1s0XV0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob3RoZXIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCAtIDEpLFxuICAgICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBhcmdzW2luZGV4IC0gMV0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbEJ5YCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kaWZmZXJlbmNlQnkoW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCBbeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBvcmRlciBhbmRcbiAgICAgKiByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsV2l0aGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VXaXRoKG9iamVjdHMsIFt7ICd4JzogMSwgJ3knOiAyIH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoY29tcGFyYXRvcikpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOCwgMTBdLCAnKicsIDEsIDMpO1xuICAgICAqIC8vID0+IFs0LCAnKicsICcqJywgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ3BlYmJsZXMnOyB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMFxuICAgICAgICAgID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKVxuICAgICAgICAgIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNCwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBJTkZJTklUWSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVuIGBhcnJheWAgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIFsyLCBbMywgWzRdXSwgNV1dO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZXB0aChhcnJheSwgZGVwdGgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8udG9QYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogZnJvbSBrZXktdmFsdWUgYHBhaXJzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZmlyc3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oZWFkKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5oZWFkKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoZWFkKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDAsIC0xKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMl1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZClcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgaWYgKGl0ZXJhdGVlID09PSBsYXN0KG1hcHBlZCkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzXG4gICAgICogb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCBlbGVtZW50cyBpbiBgYXJyYXlgIGludG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9JywnXSBUaGUgZWxlbWVudCBzZXBhcmF0b3IuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgam9pbmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5qb2luKFsnYScsICdiJywgJ2MnXSwgJ34nKTtcbiAgICAgKiAvLyA9PiAnYX5ifmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/ICcnIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgICA/IHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCBhdCBpbmRleCBgbmAgb2YgYGFycmF5YC4gSWYgYG5gIGlzIG5lZ2F0aXZlLCB0aGUgbnRoXG4gICAgICogZWxlbWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAtMik7XG4gICAgICogLy8gPT4gJ2MnO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aChhcnJheSwgbikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZU50aChhcnJheSwgdG9JbnRlZ2VyKG4pKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBnaXZlbiB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5yZW1vdmVgXG4gICAgICogdG8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGwoYXJyYXksICdhJywgJ2MnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIHZhciBwdWxsID0gYmFzZVJlc3QocHVsbEFsbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGwoYXJyYXksIFsnYScsICdjJ10pO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbChhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZUJ5YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDMgfSwgeyAneCc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxCeShhcnJheSwgW3sgJ3gnOiAxIH0sIHsgJ3gnOiAzIH1dLCAneCcpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsQnkoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VXaXRoYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAzLCAneSc6IDQgfSwgeyAneCc6IDUsICd5JzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbFdpdGgoYXJyYXksIFt7ICd4JzogMywgJ3knOiA0IH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogNSwgJ3knOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbFdpdGgoYXJyYXksIHZhbHVlcywgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gYGluZGV4ZXNgIGFuZCByZXR1cm5zIGFuXG4gICAgICogYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uYXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICogdmFyIHB1bGxlZCA9IF8ucHVsbEF0KGFycmF5LCBbMSwgM10pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdjJ11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHB1bGxlZCk7XG4gICAgICogLy8gPT4gWydiJywgJ2QnXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG5cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGFycmF5TWFwKGluZGV4ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XG4gICAgICB9KS5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5wdWxsYFxuICAgICAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIGBhcnJheWAgc28gdGhhdCB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YCBhbmQgaXMgYmFzZWQgb25cbiAgICAgKiBbYEFycmF5I3JldmVyc2VgXShodHRwczovL21kbi5pby9BcnJheS9yZXZlcnNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucmV2ZXJzZShhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV2ZXJzZShhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBhcnJheSA6IG5hdGl2ZVJldmVyc2UuY2FsbChhcnJheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mXG4gICAgICogW2BBcnJheSNzbGljZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3NsaWNlKSB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIGxvd2VzdCBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleChbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRMYXN0SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmxhc3RJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxKFsxLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXkpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxQnlgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxQnkoWzEuMSwgMS4yLCAyLjMsIDIuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjEsIDIuM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWlsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFpbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuIEVsZW1lbnRzIGFyZVxuICAgICAqIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tIHRoZSBmaXJzdFxuICAgICAqIGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbkJ5KFsyLjFdLCBbMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb21cbiAgICAgKiB0aGUgZmlyc3QgYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIGlzIGtlcHQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXJcbiAgICAgKiBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICAgKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxQnkoWzIuMSwgMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pcVdpdGgob2JqZWN0cywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcVdpdGgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuICAgICAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS16aXBcbiAgICAgKiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoZ3JvdXApKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IHJlZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHVuemlwKGFycmF5KTtcbiAgICAgIGlmIChpdGVyYXRlZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHVuZGVmaW5lZCwgZ3JvdXApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsyLCAxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGlzIHRoZVxuICAgICAqIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXG4gICAgICogb2YgdGhlIGdpdmVuIGFycmF5cy4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXJcbiAgICAgKiB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLndpdGhvdXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqL1xuICAgIHZhciB4b3IgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZFxuICAgICAqIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lXG4gICAgICogYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3JCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yLCAzLjRdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnhvckJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB4b3JCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ueG9yV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IGJhc2VSZXN0KHVuemlwKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZnJvbVBhaXJzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIHR3byBhcnJheXMsXG4gICAgICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnYScsICdiJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGFzc2lnblZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcE9iamVjdGAgZXhjZXB0IHRoYXQgaXQgc3VwcG9ydHMgcHJvcGVydHkgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0RGVlcChbJ2EuYlswXS5jJywgJ2EuYlsxXS5kJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiBbeyAnYyc6IDEgfSwgeyAnZCc6IDIgfV0gfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBiYXNlU2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIGdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwV2l0aChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdLCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gYSArIGIgKyBjO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxMTEsIDIyMl1cbiAgICAgKi9cbiAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgaXRlcmF0ZWUgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpdGVyYXRlZSA9IHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nID8gKGFycmF5cy5wb3AoKSwgaXRlcmF0ZWUpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHVuemlwV2l0aChhcnJheXMsIGl0ZXJhdGVlKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHRoYXQgd3JhcHMgYHZhbHVlYCB3aXRoIGV4cGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLiBUaGUgcmVzdWx0IG9mIHN1Y2ggc2VxdWVuY2VzIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gX1xuICAgICAqICAgLmNoYWluKHVzZXJzKVxuICAgICAqICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAqICAgICByZXR1cm4gby51c2VyICsgJyBpcyAnICsgby5hZ2U7XG4gICAgICogICB9KVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvXG4gICAgICogXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlIGluIG9yZGVyIHRvIG1vZGlmeSBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgIC8vIE11dGF0ZSBpbnB1dCBhcnJheS5cbiAgICAgKiAgICBhcnJheS5wb3AoKTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwicGFzcyB0aHJ1XCIgdmFsdWVzIHJlcGxhY2luZyBpbnRlcm1lZGlhdGVcbiAgICAgKiByZXN1bHRzIGluIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXygnICBhYmMgICcpXG4gICAgICogIC5jaGFpbigpXG4gICAgICogIC50cmltKClcbiAgICAgKiAgLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8uYXRgLlxuICAgICAqXG4gICAgICogQG5hbWUgYXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXyhvYmplY3QpLmF0KFsnYVswXS5iLmMnLCAnYVsxXSddKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciB3cmFwcGVyQXQgPSBmbGF0UmVzdChmdW5jdGlvbihwYXRocykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbihvYmplY3QpIHsgcmV0dXJuIGJhc2VBdChvYmplY3QsIHBhdGhzKTsgfTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEgfHwgdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGggfHxcbiAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHx8ICFpc0luZGV4KHN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2Uoc3RhcnQsICtzdGFydCArIChsZW5ndGggPyAxIDogMCkpO1xuICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLFxuICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUsIHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGlmIChsZW5ndGggJiYgIWFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIGFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHdpdGggZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpLmhlYWQoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGggZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycylcbiAgICAgKiAgIC5jaGFpbigpXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAucGljaygndXNlcicpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHJldHVybiBjaGFpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oYXJyYXkpLnB1c2goMyk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkID0gd3JhcHBlZC5jb21taXQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLmxhc3QoKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih0aGlzLnZhbHVlKCksIHRoaXMuX19jaGFpbl9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIG9uIGEgd3JhcHBlZCBvYmplY3QgZm9sbG93aW5nIHRoZVxuICAgICAqIFtpdGVyYXRvciBwcm90b2NvbF0oaHR0cHM6Ly9tZG4uaW8vaXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAbmFtZSBuZXh0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV4dCBpdGVyYXRvciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDEgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAyIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiB0cnVlLCAndmFsdWUnOiB1bmRlZmluZWQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJOZXh0KCkge1xuICAgICAgaWYgKHRoaXMuX192YWx1ZXNfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHRvQXJyYXkodGhpcy52YWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciBkb25lID0gdGhpcy5fX2luZGV4X18gPj0gdGhpcy5fX3ZhbHVlc19fLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSA9IGRvbmUgPyB1bmRlZmluZWQgOiB0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107XG5cbiAgICAgIHJldHVybiB7ICdkb25lJzogZG9uZSwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSB3cmFwcGVyIHRvIGJlIGl0ZXJhYmxlLlxuICAgICAqXG4gICAgICogQG5hbWUgU3ltYm9sLml0ZXJhdG9yXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZFtTeW1ib2wuaXRlcmF0b3JdKCkgPT09IHdyYXBwZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogQXJyYXkuZnJvbSh3cmFwcGVkKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9JdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW4gc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGxhbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSkubWFwKHNxdWFyZSk7XG4gICAgICogdmFyIG90aGVyID0gd3JhcHBlZC5wbGFudChbMywgNF0pO1xuICAgICAqXG4gICAgICogb3RoZXIudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbOSwgMTZdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclBsYW50KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHdyYXBwZXJDbG9uZShwYXJlbnQpO1xuICAgICAgICBjbG9uZS5fX2luZGV4X18gPSAwO1xuICAgICAgICBjbG9uZS5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSBjbG9uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9fd3JhcHBlZF9fO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5yZXZlcnNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQucmV2ZXJzZSgpO1xuICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgICAnYXJncyc6IFtyZXZlcnNlXSxcbiAgICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRocnUocmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgKytyZXN1bHRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICAgICAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8ucmVqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gQ29tYmluaW5nIHNldmVyYWwgcHJlZGljYXRlcyB1c2luZyBgXy5vdmVyRXZlcnlgIG9yIGBfLm92ZXJTb21lYC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5vdmVyU29tZShbeyAnYWdlJzogMzYgfSwgWydhZ2UnLCA0MF1dKSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9Y29sbGVjdGlvbi5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChmaW5kTGFzdEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmbGF0dGVuZWQgYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYFxuICAgICAqIHRocnUgYGl0ZXJhdGVlYCBhbmQgZmxhdHRlbmluZyB0aGUgbWFwcGVkIHJlc3VsdHMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbbiwgbl07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlZXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZWVwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgSU5GSU5JVFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlcHRoKFsxLCAyXSwgZHVwbGljYXRlLCAyKTtcbiAgICAgKiAvLyA9PiBbWzEsIDFdLCBbMiwgMl1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlcHRoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBkZXB0aCkge1xuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAgICAgKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaFJpZ2h0KFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAyYCB0aGVuIGAxYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaFJpZ2h0IDogYmFzZUVhY2hSaWdodDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBvcmRlciBvZiBncm91cGVkIHZhbHVlc1xuICAgICAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZVxuICAgICAqIGtleS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjNdIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICAgICAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAgICAgKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XG5cbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBwYXRoYCBpcyBhIGZ1bmN0aW9uLCBpdCdzIGludm9rZWRcbiAgICAgKiBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGVhY2ggbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXNGdW5jID8gYXBwbHkocGF0aCwgdmFsdWUsIGFyZ3MpIDogYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCBmdW5jdGlvbihvKSB7XG4gICAgICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvLmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBrZXlCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICAgICAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICAgICAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeWAgZXhjZXB0IHRoYXQgaXQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIHNvcnRcbiAgICAgKiBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc1xuICAgICAqIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yXG4gICAgICogZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlciBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXlbXXxGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcmRlcnNdIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBTb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICogXy5vcmRlckJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xuICAgICAgfVxuICAgICAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBvcmRlcnM7XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byB0d28gZ3JvdXBzLCB0aGUgZmlyc3Qgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIHRoZSBzZWNvbmQgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydwZWJibGVzJ10sIFsnYmFybmV5JywgJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKi9cbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gICAgICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gICAgICogYW5kIGBzb3J0QnlgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG47XG4gICAgICogfSwgMCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICpcbiAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2VSaWdodCA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2hSaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmA7IHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5maWx0ZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZWplY3QodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZSA6IGJhc2VTYW1wbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGBuYCByYW5kb20gZWxlbWVudHMgYXQgdW5pcXVlIGtleXMgZnJvbSBgY29sbGVjdGlvbmAgdXAgdG8gdGhlXG4gICAgICogc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZVNpemUgOiBiYXNlU2FtcGxlU2l6ZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gICAgICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICAgICAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCAzMF1dXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQ4XV1cbiAgICAgKi9cbiAgICB2YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICAgICAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IERhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAgICogfSwgXy5ub3coKSk7XG4gICAgICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmJlZm9yZWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiBgZnVuY2Agb25jZSBpdCdzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHVwIHRvIGBuYCBhcmd1bWVudHMsXG4gICAgICogaWdub3JpbmcgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgY2FwLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLmFyeShwYXJzZUludCwgMSkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgIG4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IG47XG4gICAgICBuID0gKGZ1bmMgJiYgbiA9PSBudWxsKSA/IGZ1bmMubGVuZ3RoIDogbjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQVJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQncyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAgICAgKiAvLyA9PiBBbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmQpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIHdpdGggYHBhcnRpYWxzYFxuICAgICAqIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuIFNlZVxuICAgICAqIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52b2tlIHRoZSBtZXRob2Qgb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAndXNlcic6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kS2V5ID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZEtleSkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoa2V5LCBiaXRtYXNrLCBvYmplY3QsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYXJndW1lbnRzIG9mIGBmdW5jYCBhbmQgZWl0aGVyIGludm9rZXNcbiAgICAgKiBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGF0IGxlYXN0IGBhcml0eWAgbnVtYmVyIG9mIGFyZ3VtZW50cyBoYXZlXG4gICAgICogYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIGBmdW5jYFxuICAgICAqIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIG1heSBiZSBzcGVjaWZpZWQgaWYgYGZ1bmMubGVuZ3RoYFxuICAgICAqIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeS5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnlSaWdodChhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgzKSgyKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMiwgMykoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5UmlnaHQoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeVJpZ2h0LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAgICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gICAgICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gICAgICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICAgICAqIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICAgICAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gICAgICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxhc3RBcmdzLFxuICAgICAgICAgIGxhc3RUaGlzLFxuICAgICAgICAgIG1heFdhaXQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHRpbWVySWQsXG4gICAgICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICAgICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgICAgICByZXR1cm4gbWF4aW5nXG4gICAgICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgICAgIDogdGltZVdhaXRpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICAgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgICAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAgICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgICByZXR1cm4gZGVib3VuY2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBpbnZva2luZyB0aGUgYGZ1bmNgIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuIEFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyA9PiBMb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWZlciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgMSwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBmdW5jYCBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBMb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVsYXkgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgcmV2ZXJzZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBmbGlwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxpcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZsaXBwZWQgPSBfLmZsaXAoZnVuY3Rpb24oKSB7XG4gICAgICogICByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmbGlwcGVkKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gWydkJywgJ2MnLCAnYicsICdhJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGlwKGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfRkxJUF9GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAgICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICAgICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAgICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICAgICAqXG4gICAgICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YWx1ZXMob3RoZXIpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqXG4gICAgICogb2JqZWN0LmEgPSAyO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAgICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKlxuICAgICAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gICAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgYE1hcENhY2hlYC5cbiAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxuICAgICAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbmVnYXRlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAgICAgKiB0byB0aGUgZnVuY3Rpb24gcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgaW52b2NhdGlvbi4gVGhlIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vID0+IGBjcmVhdGVBcHBsaWNhdGlvbmAgaXMgaW52b2tlZCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50cyB0cmFuc2Zvcm1lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFt0cmFuc2Zvcm1zPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGFyZ3VtZW50IHRyYW5zZm9ybXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGRvdWJsZWQobikge1xuICAgICAqICAgcmV0dXJuIG4gKiAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJBcmdzKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiBbeCwgeV07XG4gICAgICogfSwgW3NxdWFyZSwgZG91YmxlZF0pO1xuICAgICAqXG4gICAgICogZnVuYyg5LCAzKTtcbiAgICAgKiAvLyA9PiBbODEsIDZdXG4gICAgICpcbiAgICAgKiBmdW5jKDEwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTAwLCAxMF1cbiAgICAgKi9cbiAgICB2YXIgb3ZlckFyZ3MgPSBjYXN0UmVzdChmdW5jdGlvbihmdW5jLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB0cmFuc2Zvcm1zID0gKHRyYW5zZm9ybXMubGVuZ3RoID09IDEgJiYgaXNBcnJheSh0cmFuc2Zvcm1zWzBdKSlcbiAgICAgICAgPyBhcnJheU1hcCh0cmFuc2Zvcm1zWzBdLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpXG4gICAgICAgIDogYXJyYXlNYXAoYmFzZUZsYXR0ZW4odHJhbnNmb3JtcywgMSksIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciBmdW5jc0xlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oYXJncy5sZW5ndGgsIGZ1bmNzTGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gdHJhbnNmb3Jtc1tpbmRleF0uY2FsbCh0aGlzLCBhcmdzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpdCByZWNlaXZlcy4gVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5iaW5kYCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqXG4gICAgICogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWwoZ3JlZXQsICdoZWxsbycpO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWwoZ3JlZXQsIF8sICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsKSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50c1xuICAgICAqIGFyZSBhcHBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWxSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2hlbGxvJywgXyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWxSaWdodCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBgaW5kZXhlc2Agd2hlcmUgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBmaXJzdCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBzZWNvbmQgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZWFycmFuZ2UgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcmd1bWVudCBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhcmdlZCA9IF8ucmVhcmcoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9LCBbMiwgMCwgMV0pO1xuICAgICAqXG4gICAgICogcmVhcmdlZCgnYicsICdjJywgJ2EnKVxuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIHZhciByZWFyZyA9IGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUkVBUkdfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaW5kZXhlcyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXNcbiAgICAgKiBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vbWRuLmlvL3Jlc3RfcGFyYW1ldGVycykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8ucmVzdChmdW5jdGlvbih3aGF0LCBuYW1lcykge1xuICAgICAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICAgICAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jLCBzdGFydCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlIGZ1bmN0aW9uIGFuZCBhbiBhcnJheSBvZiBhcmd1bWVudHMgbXVjaCBsaWtlXG4gICAgICogW2BGdW5jdGlvbiNhcHBseWBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtzcHJlYWQgb3BlcmF0b3JdKGh0dHBzOi8vbWRuLmlvL3NwcmVhZF9vcGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzcHJlYWQgYXJndW1lbnRzIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHNwcmVhZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8uc3ByZWFkKGZ1bmN0aW9uKHdobywgd2hhdCkge1xuICAgICAqICAgcmV0dXJuIHdobyArICcgc2F5cyAnICsgd2hhdDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheShbJ2ZyZWQnLCAnaGVsbG8nXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQgc2F5cyBoZWxsbydcbiAgICAgKlxuICAgICAqIHZhciBudW1iZXJzID0gUHJvbWlzZS5hbGwoW1xuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDQwKSxcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4geCArIHk7XG4gICAgICogfSkpO1xuICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IG5hdGl2ZU1heCh0b0ludGVnZXIoc3RhcnQpLCAwKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3Nbc3RhcnRdLFxuICAgICAgICAgICAgb3RoZXJBcmdzID0gY2FzdFNsaWNlKGFyZ3MsIDAsIHN0YXJ0KTtcblxuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBhcnJheVB1c2gob3RoZXJBcmdzLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gICAgICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAgICAgKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gICAgICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gICAgICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICAgICAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAgICAgKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gICAgICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAgICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIG9uZSBhcmd1bWVudCwgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8udW5hcnkocGFyc2VJbnQpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5hcnkoZnVuYykge1xuICAgICAgcmV0dXJuIGFyeShmdW5jLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIGB3cmFwcGVyYCBhcyBpdHMgZmlyc3RcbiAgICAgKiBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYHdyYXBwZXJgLiBUaGUgd3JhcHBlciBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFt3cmFwcGVyPWlkZW50aXR5XSBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5mcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBwYXJ0aWFsKGNhc3RGdW5jdGlvbih3cmFwcGVyKSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgYXMgYW4gYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoMSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbbnVsbF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKiBjb25zb2xlLmxvZyhfLmNhc3RBcnJheShhcnJheSkgPT09IGFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5KCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAgICAgKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gICAgICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAgICAgKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gICAgICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHVwIHRvIGZvdXIgYXJndW1lbnRzOyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lV2l0aGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXBXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgb2JqZWN0YCBjb25mb3JtcyB0byBgc291cmNlYCBieSBpbnZva2luZyB0aGUgcHJlZGljYXRlXG4gICAgICogcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMjsgfSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2UgPT0gbnVsbCB8fCBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKE5hTiwgTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5ndCgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUd0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheUJ1ZmZlcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheUJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IG5vZGVJc0FycmF5QnVmZmVyID8gYmFzZVVuYXJ5KG5vZGVJc0FycmF5QnVmZmVyKSA6IGJhc2VJc0FycmF5QnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICAgICAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAgICAgKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gICAgICogaXMgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBEYXRlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzRGF0ZSA9IG5vZGVJc0RhdGUgPyBiYXNlVW5hcnkobm9kZUlzRGF0ZSkgOiBiYXNlSXNEYXRlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoJzxib2R5PicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAgICAgKlxuICAgICAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAgICAgKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gICAgICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gICAgICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICAgICAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gICAgICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gICAgICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogb2JqZWN0ID09PSBvdGhlcjtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzRXF1YWxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCB1cCB0b1xuICAgICAqIHNpeCBhcmd1bWVudHM6IChvYmpWYWx1ZSwgb3RoVmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIG90aGVyLCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcob3RoVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsV2l0aChhcnJheSwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsV2l0aCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCB1bmRlZmluZWQsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNGaW5pdGVgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNGaW5pdGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gICAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICAgICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAgICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBgb2JqZWN0YCBhbmQgYHNvdXJjZWAgdG9cbiAgICAgKiBkZXRlcm1pbmUgaWYgYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5tYXRjaGVzYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc01hdGNoYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggZml2ZVxuICAgICAqIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwgaW5kZXh8a2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcoc3JjVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdncmVldGluZyc6ICdoZWxsbycgfTtcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNOYU5gXShodHRwczovL21kbi5pby9OdW1iZXIvaXNOYU4pIGFuZCBpcyBub3QgdGhlIHNhbWUgYXNcbiAgICAgKiBnbG9iYWwgW2Bpc05hTmBdKGh0dHBzOi8vbWRuLmlvL2lzTmFOKSB3aGljaCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWJlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZVxuICAgICAgLy8gQWN0aXZlWCBvYmplY3RzIGluIElFLlxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcmlzdGluZSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgY2FuJ3QgcmVsaWFibHkgZGV0ZWN0IG5hdGl2ZSBmdW5jdGlvbnMgaW4gdGhlIHByZXNlbmNlXG4gICAgICogb2YgdGhlIGNvcmUtanMgcGFja2FnZSBiZWNhdXNlIGNvcmUtanMgY2lyY3VtdmVudHMgdGhpcyBraW5kIG9mIGRldGVjdGlvbi5cbiAgICAgKiBEZXNwaXRlIG11bHRpcGxlIHJlcXVlc3RzLCB0aGUgY29yZS1qcyBtYWludGFpbmVyIGhhcyBtYWRlIGl0IGNsZWFyOiBhbnlcbiAgICAgKiBhdHRlbXB0IHRvIGZpeCB0aGUgZGV0ZWN0aW9uIHdpbGwgYmUgb2JzdHJ1Y3RlZC4gQXMgYSByZXN1bHQsIHdlJ3JlIGxlZnRcbiAgICAgKiB3aXRoIGxpdHRsZSBjaG9pY2UgYnV0IHRvIHRocm93IGFuIGVycm9yLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGFsc28gYWZmZWN0c1xuICAgICAqIHBhY2thZ2VzLCBsaWtlIFtiYWJlbC1wb2x5ZmlsbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYmFiZWwtcG9seWZpbGwpLFxuICAgICAqIHdoaWNoIHJlbHkgb24gY29yZS1qcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoaXNNYXNrYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKENPUkVfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBudWxsaXNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICAgICAqIGNsYXNzaWZpZWQgYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gbnVtYmVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuOC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICAgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1JlZ0V4cCA9IG5vZGVJc1JlZ0V4cCA/IGJhc2VVbmFyeShub2RlSXNSZWdFeHApIDogYmFzZUlzUmVnRXhwO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIuIEFuIGludGVnZXIgaXMgc2FmZSBpZiBpdCdzIGFuIElFRUUtNzU0XG4gICAgICogZG91YmxlIHByZWNpc2lvbiBudW1iZXIgd2hpY2ggaXNuJ3QgdGhlIHJlc3VsdCBvZiBhIHJvdW5kZWQgdW5zYWZlIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc1NhZmVJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzU2FmZUludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IC1NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gd2Vha01hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHdlYWtTZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0KDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHQgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VMdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDw9IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0FycmF5KHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KDEpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHN0cmluZ1RvQXJyYXkodmFsdWUpIDogY29weUFycmF5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW1JdGVyYXRvciAmJiB2YWx1ZVtzeW1JdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVG9BcnJheSh2YWx1ZVtzeW1JdGVyYXRvcl0oKSk7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICBmdW5jID0gdGFnID09IG1hcFRhZyA/IG1hcFRvQXJyYXkgOiAodGFnID09IHNldFRhZyA/IHNldFRvQXJyYXkgOiB2YWx1ZXMpO1xuXG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICAgICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlciBzdWl0YWJsZSBmb3IgdXNlIGFzIHRoZSBsZW5ndGggb2YgYW5cbiAgICAgKiBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDQyOTQ5NjcyOTVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIDAsIE1BWF9BUlJBWV9MRU5HVEgpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b051bWJlcigzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IEluZmluaXR5XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gICAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICAgICAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgICAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcGxhaW4gb2JqZWN0IGZsYXR0ZW5pbmcgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nXG4gICAgICoga2V5ZWQgcHJvcGVydGllcyBvZiBgdmFsdWVgIHRvIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBwbGFpbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzYWZlIGludGVnZXIuIEEgc2FmZSBpbnRlZ2VyIGNhbiBiZSBjb21wYXJlZCBhbmRcbiAgICAgKiByZXByZXNlbnRlZCBjb3JyZWN0bHkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDkwMDcxOTkyNTQ3NDA5OTFcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcignMy4yJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgOiAodmFsdWUgPT09IDAgPyB2YWx1ZSA6IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gICAgICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1N0cmluZyhudWxsKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZygtMCk7XG4gICAgICogLy8gPT4gJy0wJ1xuICAgICAqXG4gICAgICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+ICcxLDIsMydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YCBhbmQgaXMgbG9vc2VseSBiYXNlZCBvblxuICAgICAqIFtgT2JqZWN0LmFzc2lnbmBdKGh0dHBzOi8vbWRuLmlvL09iamVjdC9hc3NpZ24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgaWYgKGlzUHJvdG90eXBlKHNvdXJjZSkgfHwgaXNBcnJheUxpa2Uoc291cmNlKSkge1xuICAgICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgc291cmNlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ25Jbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMsICdkJzogNCB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduSW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduSW5XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIGBwYXRoc2Agb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfSwgNF0gfTtcbiAgICAgKlxuICAgICAqIF8uYXQob2JqZWN0LCBbJ2FbMF0uYi5jJywgJ2FbMV0nXSk7XG4gICAgICogLy8gPT4gWzMsIDRdXG4gICAgICovXG4gICAgdmFyIGF0ID0gZmxhdFJlc3QoYmFzZUF0KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gICAgICogYHByb3BlcnRpZXNgIG9iamVjdCBpcyBnaXZlbiwgaXRzIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIGFzc2lnbmVkIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gVGhlIHByb3BlcnRpZXMgdG8gYXNzaWduIHRvIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgICogICB0aGlzLnggPSAwO1xuICAgICAqICAgdGhpcy55ID0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBDaXJjbGUoKSB7XG4gICAgICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHtcbiAgICAgKiAgICdjb25zdHJ1Y3Rvcic6IENpcmNsZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGU7XG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgQ2lyY2xlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIFNoYXBlO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlLCBwcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXMgPT0gbnVsbCA/IHJlc3VsdCA6IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gICAgICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gICAgICogcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0cyA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgICAgdmFyIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzb3VyY2VzWzBdLCBzb3VyY2VzWzFdLCBndWFyZCkpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcbiAgICAgICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICAgICAgdmFyIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwcm9wc1twcm9wc0luZGV4XTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgIChlcSh2YWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGVmYXVsdHNgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGFzc2lnbnNcbiAgICAgKiBkZWZhdWx0IHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmRlZmF1bHRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHNEZWVwKHsgJ2EnOiB7ICdiJzogMiB9IH0sIHsgJ2EnOiB7ICdiJzogMSwgJ2MnOiAzIH0gfSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiAyLCAnYyc6IDMgfSB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzRGVlcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGFyZ3MucHVzaCh1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UpO1xuICAgICAgcmV0dXJuIGFwcGx5KG1lcmdlV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUga2V5IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5JyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kS2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRLZXlgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBhIGNvbGxlY3Rpb24gaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gUmV0dXJucyB0aGUga2V5IG9mIHRoZSBtYXRjaGVkIGVsZW1lbnQsXG4gICAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdiYXJuZXknOiAgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICAnZnJlZCc6ICAgIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gcmV0dXJucyAncGViYmxlcycgYXNzdW1pbmcgYF8uZmluZEtleWAgcmV0dXJucyAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZExhc3RLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd25SaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuXG4gICAgICogb2JqZWN0IGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXRcbiAgICAgKiBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJywgJ2InLCB0aGVuICdjJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9ySW5gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvckluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdjJywgJ2InLCB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JJbmAgbG9ncyAnYScsICdiJywgdGhlbiAnYycuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW5SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICAgICAgPyBvYmplY3RcbiAgICAgICAgOiBiYXNlRm9yUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgYW5kXG4gICAgICogaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvblxuICAgICAqIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd24obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duKG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvck93bmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93blJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYicgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9yT3duYCBsb2dzICdhJyB0aGVuICdiJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAgICAgKiBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9ucyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmcm9tIG93biBhbmQgaW5oZXJpdGVkXG4gICAgICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSBfLmNvbnN0YW50KCdhJyk7XG4gICAgICogICB0aGlzLmIgPSBfLmNvbnN0YW50KCdiJyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gXy5jb25zdGFudCgnYycpO1xuICAgICAqXG4gICAgICogXy5mdW5jdGlvbnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZUZ1bmN0aW9ucyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICAgICAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XG4gICAgICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob3RoZXIsICdhJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgaW52ZXJ0ZWQga2V5cyBhbmQgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqIElmIGBvYmplY3RgIGNvbnRhaW5zIGR1cGxpY2F0ZSB2YWx1ZXMsIHN1YnNlcXVlbnQgdmFsdWVzIG92ZXJ3cml0ZVxuICAgICAqIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6ICdjJywgJzInOiAnYicgfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnQgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0W3ZhbHVlXSA9IGtleTtcbiAgICB9LCBjb25zdGFudChpZGVudGl0eSkpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pbnZlcnRgIGV4Y2VwdCB0aGF0IHRoZSBpbnZlcnRlZCBvYmplY3QgaXMgZ2VuZXJhdGVkXG4gICAgICogZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nIGVhY2ggZWxlbWVudCBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgaW52ZXJ0ZWQgdmFsdWUgb2YgZWFjaCBpbnZlcnRlZCBrZXkgaXMgYW4gYXJyYXkgb2Yga2V5c1xuICAgICAqIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBpbnZlcnRlZCB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52ZXJ0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICByZXR1cm4gJ2dyb3VwJyArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2dyb3VwMSc6IFsnYScsICdjJ10sICdncm91cDInOiBbJ2InXSB9XG4gICAgICovXG4gICAgdmFyIGludmVydEJ5ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0ucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXSA9IFtrZXldO1xuICAgICAgfVxuICAgIH0sIGdldEl0ZXJhdGVlKTtcblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiBbMSwgMiwgMywgNF0gfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5pbnZva2Uob2JqZWN0LCAnYVswXS5iLmMuc2xpY2UnLCAxLCAzKTtcbiAgICAgKiAvLyA9PiBbMiwgM11cbiAgICAgKi9cbiAgICB2YXIgaW52b2tlID0gYmFzZVJlc3QoYmFzZUludm9rZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gICAgICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy5rZXlzKCdoaScpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5c0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tYXBWYWx1ZXNgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAqIHNhbWUgdmFsdWVzIGFzIGBvYmplY3RgIGFuZCBrZXlzIGdlbmVyYXRlZCBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGVcbiAgICAgKiBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjguMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBWYWx1ZXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXBLZXlzKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgcmV0dXJuIGtleSArIHZhbHVlO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2ExJzogMSwgJ2IyJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwS2V5cyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gICAgICogYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwS2V5c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnZnJlZCc6ICAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZTsgfSk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgaW50byB0aGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuIFNvdXJjZSBwcm9wZXJ0aWVzIHRoYXQgcmVzb2x2ZSB0byBgdW5kZWZpbmVkYCBhcmVcbiAgICAgKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAgICAgKiBhcmUgbWVyZ2VkIHJlY3Vyc2l2ZWx5LiBPdGhlciBvYmplY3RzIGFuZCB2YWx1ZSB0eXBlcyBhcmUgb3ZlcnJpZGRlbiBieVxuICAgICAqIGFzc2lnbm1lbnQuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC4gU3Vic2VxdWVudFxuICAgICAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2InOiAyIH0sIHsgJ2QnOiA0IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBvdGhlciA9IHtcbiAgICAgKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzogMiwgJ2MnOiAzIH0sIHsgJ2QnOiA0LCAnZSc6IDUgfV0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lcmdlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgbWVyZ2VkIHZhbHVlcyBvZiB0aGUgZGVzdGluYXRpb24gYW5kIHNvdXJjZVxuICAgICAqIHByb3BlcnRpZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBtZXJnaW5nIGlzIGhhbmRsZWQgYnkgdGhlXG4gICAgICogbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIHNpeCBhcmd1bWVudHM6XG4gICAgICogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0FycmF5KG9ialZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gb2JqVmFsdWUuY29uY2F0KHNyY1ZhbHVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFsxXSwgJ2InOiBbMl0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogWzNdLCAnYic6IFs0XSB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZVdpdGgob2JqZWN0LCBvdGhlciwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4geyAnYSc6IFsxLCAzXSwgJ2InOiBbMiwgNF0gfVxuICAgICAqL1xuICAgIHZhciBtZXJnZVdpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAgICAgKiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IHBhdGhzIG9mIGBvYmplY3RgIHRoYXQgYXJlIG5vdCBvbWl0dGVkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIG9taXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXQob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICB2YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIGlzRGVlcCA9IGZhbHNlO1xuICAgICAgcGF0aHMgPSBhcnJheU1hcChwYXRocywgZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH0pO1xuICAgICAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xuICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICByZXN1bHQgPSBiYXNlQ2xvbmUocmVzdWx0LCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGJhc2VVbnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrQnlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZlxuICAgICAqIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgIHRoYXRcbiAgICAgKiBgcHJlZGljYXRlYCBkb2Vzbid0IHJldHVybiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d29cbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0Qnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdiJzogJzInIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbWl0Qnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBwaWNrQnkob2JqZWN0LCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBwaWNrZWQgYG9iamVjdGAgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2sob2JqZWN0LCBbJ2EnLCAnYyddKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgcGljayA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXG4gICAgICogdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLnBpY2tCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IGFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHJldHVybiBbcHJvcF07XG4gICAgICB9KTtcbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSk7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZ2V0YCBleGNlcHQgdGhhdCBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXMgYVxuICAgICAqIGZ1bmN0aW9uIGl0J3MgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBpdHMgcGFyZW50IG9iamVjdCBhbmRcbiAgICAgKiBpdHMgcmVzdWx0IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MxJzogMywgJ2MyJzogXy5jb25zdGFudCg0KSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzEnKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzInKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgXy5jb25zdGFudCgnZGVmYXVsdCcpKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgLy8gRW5zdXJlIHRoZSBsb29wIGlzIGVudGVyZWQgd2hlbiBwYXRoIGlzIGVtcHR5LlxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgb2JqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3RbdG9LZXkocGF0aFtpbmRleF0pXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBvYmplY3QgPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIGEgcG9ydGlvbiBvZiBgcGF0aGAgZG9lc24ndCBleGlzdCxcbiAgICAgKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcbiAgICAgKiBhcmUgY3JlYXRlZCBmb3IgYWxsIG90aGVyIG1pc3NpbmcgcHJvcGVydGllcy4gVXNlIGBfLnNldFdpdGhgIHRvIGN1c3RvbWl6ZVxuICAgICAqIGBwYXRoYCBjcmVhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsIFsneCcsICcwJywgJ3knLCAneiddLCA1KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy5zZXRXaXRoKG9iamVjdCwgJ1swXVsxXScsICdhJywgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRXaXRoKG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgXG4gICAgICogd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwIG9yIHNldCwgaXRzXG4gICAgICogZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlycyA9IGNyZWF0ZVRvUGFpcnMoa2V5cyk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzXG4gICAgICogZm9yIGBvYmplY3RgIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcFxuICAgICAqIG9yIHNldCwgaXRzIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNJblxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnRvUGFpcnNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICB2YXIgdG9QYWlyc0luID0gY3JlYXRlVG9QYWlycyhrZXlzSW4pO1xuXG4gICAgLyoqXG4gICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICAgICAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAgICAgKiBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIHRocnUgYGl0ZXJhdGVlYCwgd2l0aCBlYWNoIGludm9jYXRpb25cbiAgICAgKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XG4gICAgICogcHJvdmlkZWQsIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGBbW1Byb3RvdHlwZV1dYCB3aWxsIGJlIHVzZWQuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czogKGFjY3VtdWxhdG9yLCB2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgY3VzdG9tIGFjY3VtdWxhdG9yIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAgICAgKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9LCBbXSk7XG4gICAgICogLy8gPT4gWzQsIDldXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtKG9iamVjdCwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICAgICAgaXNBcnJMaWtlID0gaXNBcnIgfHwgaXNCdWZmZXIob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCk7XG4gICAgICBpZiAoYWNjdW11bGF0b3IgPT0gbnVsbCkge1xuICAgICAgICB2YXIgQ3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyID8gbmV3IEN0b3IgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0Z1bmN0aW9uKEN0b3IpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAoaXNBcnJMaWtlID8gYXJyYXlFYWNoIDogYmFzZUZvck93bikob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIHByb3BlcnR5IGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVuc2V0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDcgfSB9XSB9O1xuICAgICAqIF8udW5zZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHRydWUgOiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNldGAgZXhjZXB0IHRoYXQgYWNjZXB0cyBgdXBkYXRlcmAgdG8gcHJvZHVjZSB0aGVcbiAgICAgKiB2YWx1ZSB0byBzZXQuIFVzZSBgXy51cGRhdGVXaXRoYCB0byBjdXN0b21pemUgYHBhdGhgIGNyZWF0aW9uLiBUaGUgYHVwZGF0ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICdhWzBdLmIuYycsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gKiBuOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ3hbMF0ueS56JywgZnVuY3Rpb24obikgeyByZXR1cm4gbiA/IG4gKyAxIDogMDsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlcikge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51cGRhdGVgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVyIFRoZSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB1cGRhdGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZVdpdGgob2JqZWN0LCAnWzBdWzFdJywgXy5jb25zdGFudCgnYScpLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVdpdGgob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXMobmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLnZhbHVlcygnaGknKTtcbiAgICAgKiAvLyA9PiBbJ2gnLCAnaSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eVxuICAgICAqIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmFsdWVzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIGBudW1iZXJgIHdpdGhpbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jbGFtcCgtMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiAtNVxuICAgICAqXG4gICAgICogXy5jbGFtcCgxMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IHRvTnVtYmVyKHVwcGVyKTtcbiAgICAgICAgdXBwZXIgPSB1cHBlciA9PT0gdXBwZXIgPyB1cHBlciA6IDA7XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IHRvTnVtYmVyKGxvd2VyKTtcbiAgICAgICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUNsYW1wKHRvTnVtYmVyKG51bWJlciksIGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBuYCBpcyBiZXR3ZWVuIGBzdGFydGAgYW5kIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIElmXG4gICAgICogYGVuZGAgaXMgbm90IHNwZWNpZmllZCwgaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqIElmIGBzdGFydGAgaXMgZ3JlYXRlciB0aGFuIGBlbmRgIHRoZSBwYXJhbXMgYXJlIHN3YXBwZWQgdG8gc3VwcG9ydFxuICAgICAqIG5lZ2F0aXZlIHJhbmdlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjMuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5yYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgOCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMiwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoLTMsIC0yLCAtNik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgICAgIH1cbiAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICByZXR1cm4gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiB0aGUgaW5jbHVzaXZlIGBsb3dlcmAgYW5kIGB1cHBlcmAgYm91bmRzLlxuICAgICAqIElmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHByb3ZpZGVkIGEgbnVtYmVyIGJldHdlZW4gYDBgIGFuZCB0aGUgZ2l2ZW4gbnVtYmVyXG4gICAgICogaXMgcmV0dXJuZWQuIElmIGBmbG9hdGluZ2AgaXMgYHRydWVgLCBvciBlaXRoZXIgYGxvd2VyYCBvciBgdXBwZXJgIGFyZVxuICAgICAqIGZsb2F0cywgYSBmbG9hdGluZy1wb2ludCBudW1iZXIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcj0wXSBUaGUgbG93ZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1cHBlcj0xXSBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZmxvYXRpbmddIFNwZWNpZnkgcmV0dXJuaW5nIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgICAqIC8vID0+IGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1KTtcbiAgICAgKiAvLyA9PiBhbHNvIGFuIGludGVnZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSg1LCB0cnVlKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDEuMiwgNS4yKTtcbiAgICAgKiAvLyA9PiBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBiZXR3ZWVuIDEuMiBhbmQgNS4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmbG9hdGluZyAmJiB0eXBlb2YgZmxvYXRpbmcgIT0gJ2Jvb2xlYW4nICYmIGlzSXRlcmF0ZWVDYWxsKGxvd2VyLCB1cHBlciwgZmxvYXRpbmcpKSB7XG4gICAgICAgIHVwcGVyID0gZmxvYXRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIHVwcGVyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gdXBwZXI7XG4gICAgICAgICAgdXBwZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvd2VyID09ICdib29sZWFuJykge1xuICAgICAgICAgIGZsb2F0aW5nID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA9PT0gdW5kZWZpbmVkICYmIHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB1cHBlciA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbG93ZXIgPSB0b0Zpbml0ZShsb3dlcik7XG4gICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXBwZXIgPSB0b0Zpbml0ZSh1cHBlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciA+IHVwcGVyKSB7XG4gICAgICAgIHZhciB0ZW1wID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdXBwZXI7XG4gICAgICAgIHVwcGVyID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyB8fCBsb3dlciAlIDEgfHwgdXBwZXIgJSAxKSB7XG4gICAgICAgIHZhciByYW5kID0gbmF0aXZlUmFuZG9tKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVNaW4obG93ZXIgKyAocmFuZCAqICh1cHBlciAtIGxvd2VyICsgZnJlZVBhcnNlRmxvYXQoJzFlLScgKyAoKHJhbmQgKyAnJykubGVuZ3RoIC0gMSkpKSksIHVwcGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcik7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gW2NhbWVsIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhbWVsQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYW1lbCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqL1xuICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gY2FwaXRhbGl6ZSh3b3JkKSA6IHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlIGFuZCB0aGUgcmVtYWluaW5nXG4gICAgICogdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhcGl0YWxpemVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXBpdGFsaXplKCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcbiAgICAgIHJldHVybiB1cHBlckZpcnN0KHRvU3RyaW5nKHN0cmluZykudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVidXJycyBgc3RyaW5nYCBieSBjb252ZXJ0aW5nXG4gICAgICogW0xhdGluLTEgU3VwcGxlbWVudF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW4tMV9TdXBwbGVtZW50XyhVbmljb2RlX2Jsb2NrKSNDaGFyYWN0ZXJfdGFibGUpXG4gICAgICogYW5kIFtMYXRpbiBFeHRlbmRlZC1BXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9FeHRlbmRlZC1BKVxuICAgICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycyBhbmQgcmVtb3ZpbmdcbiAgICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3MpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGRlYnVyci5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVidXJyKCdkw6lqw6AgdnUnKTtcbiAgICAgKiAvLyA9PiAnZGVqYSB2dSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPXN0cmluZy5sZW5ndGhdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggdXAgdG8uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdiJywgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuZHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGxlbmd0aFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBsZW5ndGgpO1xuXG4gICAgICB2YXIgZW5kID0gcG9zaXRpb247XG4gICAgICBwb3NpdGlvbiAtPSB0YXJnZXQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBlbmQpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY2hhcmFjdGVycyBcIiZcIiwgXCI8XCIsIFwiPlwiLCAnXCInLCBhbmQgXCInXCIgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICAgKiBjb3JyZXNwb25kaW5nIEhUTUwgZW50aXRpZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVG8gZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBjaGFyYWN0ZXJzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIFRob3VnaCB0aGUgXCI+XCIgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2VcbiAgICAgKiBcIj5cIiBhbmQgXCIvXCIgZG9uJ3QgbmVlZCBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZ1xuICAgICAqIHVubGVzcyB0aGV5J3JlIHBhcnQgb2YgYSB0YWcgb3IgdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBTZWVcbiAgICAgKiBbTWF0aGlhcyBCeW5lbnMncyBhcnRpY2xlXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMpXG4gICAgICogKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBXaGVuIHdvcmtpbmcgd2l0aCBIVE1MIHlvdSBzaG91bGQgYWx3YXlzXG4gICAgICogW3F1b3RlIGF0dHJpYnV0ZSB2YWx1ZXNdKGh0dHA6Ly93b25rby5jb20vcG9zdC9odG1sLWVzY2FwaW5nKSB0byByZWR1Y2VcbiAgICAgKiBYU1MgdmVjdG9ycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBlc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXNjYXBlcyB0aGUgYFJlZ0V4cGAgc3BlY2lhbCBjaGFyYWN0ZXJzIFwiXlwiLCBcIiRcIiwgXCJcXFwiLCBcIi5cIiwgXCIqXCIsIFwiK1wiLFxuICAgICAqIFwiP1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBhbmQgXCJ8XCIgaW4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZVJlZ0V4cCgnW2xvZGFzaF0oaHR0cHM6Ly9sb2Rhc2guY29tLyknKTtcbiAgICAgKiAvLyA9PiAnXFxbbG9kYXNoXFxdXFwoaHR0cHM6Ly9sb2Rhc2hcXC5jb20vXFwpJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW2tlYmFiIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1NwZWNpYWxfY2FzZV9zdHlsZXMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUga2ViYWIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICovXG4gICAgdmFyIGtlYmFiQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICctJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCctLUZvby1CYXItLScpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICovXG4gICAgdmFyIGxvd2VyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRnJlZCcpO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ2ZSRUQnXG4gICAgICovXG4gICAgdmFyIGxvd2VyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvTG93ZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IGFuZCByaWdodCBzaWRlcyBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC5cbiAgICAgKiBQYWRkaW5nIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGNhbid0IGJlIGV2ZW5seSBkaXZpZGVkIGJ5IGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4KTtcbiAgICAgKiAvLyA9PiAnICBhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHN0ckxlbmd0aCA+PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBtaWQgPSAobGVuZ3RoIC0gc3RyTGVuZ3RoKSAvIDI7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUZsb29yKG1pZCksIGNoYXJzKSArXG4gICAgICAgIHN0cmluZyArXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlQ2VpbChtaWQpLCBjaGFycylcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgcmlnaHQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJ2FiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjXy1fJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkRW5kKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoc3RyaW5nICsgY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSlcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICcgICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1fYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRTdGFydChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykgKyBzdHJpbmcpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGFuIGludGVnZXIgb2YgdGhlIHNwZWNpZmllZCByYWRpeC4gSWYgYHJhZGl4YCBpc1xuICAgICAqIGB1bmRlZmluZWRgIG9yIGAwYCwgYSBgcmFkaXhgIG9mIGAxMGAgaXMgdXNlZCB1bmxlc3MgYHZhbHVlYCBpcyBhXG4gICAgICogaGV4YWRlY2ltYWwsIGluIHdoaWNoIGNhc2UgYSBgcmFkaXhgIG9mIGAxNmAgaXMgdXNlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBhbGlnbnMgd2l0aCB0aGVcbiAgICAgKiBbRVM1IGltcGxlbWVudGF0aW9uXShodHRwczovL2VzNS5naXRodWIuaW8vI3gxNS4xLjIuMikgb2YgYHBhcnNlSW50YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JhZGl4PTEwXSBUaGUgcmFkaXggdG8gaW50ZXJwcmV0IGB2YWx1ZWAgYnkuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYXJzZUludCgnMDgnKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnMDgnLCAnMTAnXSwgXy5wYXJzZUludCk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgsIGd1YXJkKSB7XG4gICAgICBpZiAoZ3VhcmQgfHwgcmFkaXggPT0gbnVsbCkge1xuICAgICAgICByYWRpeCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHJhZGl4KSB7XG4gICAgICAgIHJhZGl4ID0gK3JhZGl4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZVBhcnNlSW50KHRvU3RyaW5nKHN0cmluZykucmVwbGFjZShyZVRyaW1TdGFydCwgJycpLCByYWRpeCB8fCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXRzIHRoZSBnaXZlbiBzdHJpbmcgYG5gIHRpbWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBlYXQoJyonLCAzKTtcbiAgICAgKiAvLyA9PiAnKioqJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDIpO1xuICAgICAqIC8vID0+ICdhYmNhYmMnXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJlcGVhdCh0b1N0cmluZyhzdHJpbmcpLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBtYXRjaGVzIGZvciBgcGF0dGVybmAgaW4gYHN0cmluZ2Agd2l0aCBgcmVwbGFjZW1lbnRgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjcmVwbGFjZWBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9yZXBsYWNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBwYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IHJlcGxhY2VtZW50IFRoZSBtYXRjaCByZXBsYWNlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBtb2RpZmllZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwbGFjZSgnSGkgRnJlZCcsICdGcmVkJywgJ0Jhcm5leScpO1xuICAgICAqIC8vID0+ICdIaSBCYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZSgpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKGFyZ3NbMF0pO1xuXG4gICAgICByZXR1cm4gYXJncy5sZW5ndGggPCAzID8gc3RyaW5nIDogc3RyaW5nLnJlcGxhY2UoYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc25ha2UgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU25ha2VfY2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzbmFrZSBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnLS1GT08tQkFSLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKi9cbiAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJ18nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BTdHJpbmcjc3BsaXRgXShodHRwczovL21kbi5pby9TdHJpbmcvc3BsaXQpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHNwbGl0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gc2VwYXJhdG9yIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byBzcGxpdCBieS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBUaGUgbGVuZ3RoIHRvIHRydW5jYXRlIHJlc3VsdHMgdG8uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzdHJpbmcgc2VnbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3BsaXQoJ2EtYi1jJywgJy0nLCAyKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICBpZiAobGltaXQgJiYgdHlwZW9mIGxpbWl0ICE9ICdudW1iZXInICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gbGltaXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBsaW1pdCA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfQVJSQVlfTEVOR1RIIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAoIWxpbWl0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChcbiAgICAgICAgICAgIHR5cGVvZiBzZXBhcmF0b3IgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIChzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHAoc2VwYXJhdG9yKSlcbiAgICAgICAgICApKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoIXNlcGFyYXRvciAmJiBoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgICByZXR1cm4gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwgMCwgbGltaXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3N0YXJ0IGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xldHRlcl9jYXNlI1N0eWxpc3RpY19vcl9zcGVjaWFsaXNlZF91c2FnZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdGFydCBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCctLWZvby1iYXItLScpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGb28gQmFyJ1xuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHVwcGVyRmlyc3Qod29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249MF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCBgdGFyZ2V0YCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PSBudWxsXG4gICAgICAgID8gMFxuICAgICAgICA6IGJhc2VDbGFtcCh0b0ludGVnZXIocG9zaXRpb24pLCAwLCBzdHJpbmcubGVuZ3RoKTtcblxuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG4gICAgICByZXR1cm4gc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIHRhcmdldC5sZW5ndGgpID09IHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBjYW4gaW50ZXJwb2xhdGUgZGF0YSBwcm9wZXJ0aWVzXG4gICAgICogaW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlcnMsIEhUTUwtZXNjYXBlIGludGVycG9sYXRlZCBkYXRhIHByb3BlcnRpZXMgaW5cbiAgICAgKiBcImVzY2FwZVwiIGRlbGltaXRlcnMsIGFuZCBleGVjdXRlIEphdmFTY3JpcHQgaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuIERhdGFcbiAgICAgKiBwcm9wZXJ0aWVzIG1heSBiZSBhY2Nlc3NlZCBhcyBmcmVlIHZhcmlhYmxlcyBpbiB0aGUgdGVtcGxhdGUuIElmIGEgc2V0dGluZ1xuICAgICAqIG9iamVjdCBpcyBnaXZlbiwgaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGBfLnRlbXBsYXRlU2V0dGluZ3NgIHZhbHVlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJbiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgYF8udGVtcGxhdGVgIHV0aWxpemVzXG4gICAgICogW3NvdXJjZVVSTHNdKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmwpXG4gICAgICogZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBwcmVjb21waWxpbmcgdGVtcGxhdGVzIHNlZVxuICAgICAqIFtsb2Rhc2gncyBjdXN0b20gYnVpbGRzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vbG9kYXNoLmNvbS9jdXN0b20tYnVpbGRzKS5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENocm9tZSBleHRlbnNpb24gc2FuZGJveGVzIHNlZVxuICAgICAqIFtDaHJvbWUncyBleHRlbnNpb25zIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSB0ZW1wbGF0ZSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmVzY2FwZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXNjYXBlXVxuICAgICAqICBUaGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXZhbHVhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmV2YWx1YXRlXVxuICAgICAqICBUaGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuaW1wb3J0cz1fLnRlbXBsYXRlU2V0dGluZ3MuaW1wb3J0c11cbiAgICAgKiAgQW4gb2JqZWN0IHRvIGltcG9ydCBpbnRvIHRoZSB0ZW1wbGF0ZSBhcyBmcmVlIHZhcmlhYmxlcy5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuaW50ZXJwb2xhdGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlXVxuICAgICAqICBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc291cmNlVVJMPSdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzW25dJ11cbiAgICAgKiAgVGhlIHNvdXJjZVVSTCBvZiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnZhcmlhYmxlPSdvYmonXVxuICAgICAqICBUaGUgZGF0YSBvYmplY3QgdmFyaWFibGUgbmFtZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciB0byBjcmVhdGUgYSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgSFRNTCBcImVzY2FwZVwiIGRlbGltaXRlciB0byBlc2NhcGUgZGF0YSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPGI+PCUtIHZhbHVlICU+PC9iPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJzxzY3JpcHQ+JyB9KTtcbiAgICAgKiAvLyA9PiAnPGI+Jmx0O3NjcmlwdCZndDs8L2I+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyIHRvIGV4ZWN1dGUgSmF2YVNjcmlwdCBhbmQgZ2VuZXJhdGUgSFRNTC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBfLmZvckVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBpbnRlcm5hbCBgcHJpbnRgIGZ1bmN0aW9uIGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIHByaW50KFwiaGVsbG8gXCIgKyB1c2VyKTsgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdiYXJuZXknIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBiYXJuZXkhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBFUyB0ZW1wbGF0ZSBsaXRlcmFsIGRlbGltaXRlciBhcyBhbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIC8vIERpc2FibGUgc3VwcG9ydCBieSByZXBsYWNpbmcgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gJHsgdXNlciB9IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAncGViYmxlcycgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIHBlYmJsZXMhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIGJhY2tzbGFzaGVzIHRvIHRyZWF0IGRlbGltaXRlcnMgYXMgcGxhaW4gdGV4dC5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JT0gXCJcXFxcPCUtIHZhbHVlICVcXFxcPlwiICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnaWdub3JlZCcgfSk7XG4gICAgICogLy8gPT4gJzwlLSB2YWx1ZSAlPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYGltcG9ydHNgIG9wdGlvbiB0byBpbXBvcnQgYGpRdWVyeWAgYXMgYGpxYC5cbiAgICAgKiB2YXIgdGV4dCA9ICc8JSBqcS5lYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUodGV4dCwgeyAnaW1wb3J0cyc6IHsgJ2pxJzogalF1ZXJ5IH0gfSk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VVUkxgIG9wdGlvbiB0byBzcGVjaWZ5IGEgY3VzdG9tIHNvdXJjZVVSTCBmb3IgdGhlIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScsIHsgJ3NvdXJjZVVSTCc6ICcvYmFzaWMvZ3JlZXRpbmcuanN0JyB9KTtcbiAgICAgKiBjb21waWxlZChkYXRhKTtcbiAgICAgKiAvLyA9PiBGaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yLlxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoaSA8JT0gZGF0YS51c2VyICU+IScsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgICAqIGNvbXBpbGVkLnNvdXJjZTtcbiAgICAgKiAvLyA9PiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICogLy8gICB2YXIgX190LCBfX3AgPSAnJztcbiAgICAgKiAvLyAgIF9fcCArPSAnaGkgJyArICgoX190ID0gKCBkYXRhLnVzZXIgKSkgPT0gbnVsbCA/ICcnIDogX190KSArICchJztcbiAgICAgKiAvLyAgIHJldHVybiBfX3A7XG4gICAgICogLy8gfVxuICAgICAqXG4gICAgICogLy8gVXNlIGN1c3RvbSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLlxuICAgICAqIF8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZSA9IC97eyhbXFxzXFxTXSs/KX19L2c7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8ge3sgdXNlciB9fSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ211c3RhY2hlJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlYCBwcm9wZXJ0eSB0byBpbmxpbmUgY29tcGlsZWQgdGVtcGxhdGVzIGZvciBtZWFuaW5nZnVsXG4gICAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBzdGFjayB0cmFjZXMuXG4gICAgICogZnMud3JpdGVGaWxlU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ2pzdC5qcycpLCAnXFxcbiAgICAgKiAgIHZhciBKU1QgPSB7XFxcbiAgICAgKiAgICAgXCJtYWluXCI6ICcgKyBfLnRlbXBsYXRlKG1haW5UZXh0KS5zb3VyY2UgKyAnXFxcbiAgICAgKiAgIH07XFxcbiAgICAgKiAnKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSB7XG4gICAgICAvLyBCYXNlZCBvbiBKb2huIFJlc2lnJ3MgYHRtcGxgIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyAoaHR0cDovL2Vqb2huLm9yZy9ibG9nL2phdmFzY3JpcHQtbWljcm8tdGVtcGxhdGluZy8pXG4gICAgICAvLyBhbmQgTGF1cmEgRG9rdG9yb3ZhJ3MgZG9ULmpzIChodHRwczovL2dpdGh1Yi5jb20vb2xhZG8vZG9UKS5cbiAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBvcHRpb25zID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLCBzZXR0aW5ncywgY3VzdG9tRGVmYXVsdHNBc3NpZ25Jbik7XG5cbiAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLFxuICAgICAgICAgIGltcG9ydHNLZXlzID0ga2V5cyhpbXBvcnRzKSxcbiAgICAgICAgICBpbXBvcnRzVmFsdWVzID0gYmFzZVZhbHVlcyhpbXBvcnRzLCBpbXBvcnRzS2V5cyk7XG5cbiAgICAgIHZhciBpc0VzY2FwaW5nLFxuICAgICAgICAgIGlzRXZhbHVhdGluZyxcbiAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgICBzb3VyY2UgPSBcIl9fcCArPSAnXCI7XG5cbiAgICAgIC8vIENvbXBpbGUgdGhlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlci5cbiAgICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAgIChpbnRlcnBvbGF0ZSA9PT0gcmVJbnRlcnBvbGF0ZSA/IHJlRXNUZW1wbGF0ZSA6IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCQnXG4gICAgICAsICdnJyk7XG5cbiAgICAgIC8vIFVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgIC8vIFRoZSBzb3VyY2VVUkwgZ2V0cyBpbmplY3RlZCBpbnRvIHRoZSBzb3VyY2UgdGhhdCdzIGV2YWwtZWQsIHNvIGJlIGNhcmVmdWxcbiAgICAgIC8vIHRvIG5vcm1hbGl6ZSBhbGwga2luZHMgb2Ygd2hpdGVzcGFjZSwgc28gZS5nLiBuZXdsaW5lcyAoYW5kIHVuaWNvZGUgdmVyc2lvbnMgb2YgaXQpIGNhbid0IHNuZWFrIGluXG4gICAgICAvLyBhbmQgZXNjYXBlIHRoZSBjb21tZW50LCB0aHVzIGluamVjdGluZyBjb2RlIHRoYXQgZ2V0cyBldmFsZWQuXG4gICAgICB2YXIgc291cmNlVVJMID0gJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsICdzb3VyY2VVUkwnKVxuICAgICAgICAgID8gKG9wdGlvbnMuc291cmNlVVJMICsgJycpLnJlcGxhY2UoL1xccy9nLCAnICcpXG4gICAgICAgICAgOiAoJ2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbJyArICgrK3RlbXBsYXRlQ291bnRlcikgKyAnXScpXG4gICAgICAgICkgKyAnXFxuJztcblxuICAgICAgc3RyaW5nLnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuXG4gICAgICAgIC8vIEVzY2FwZSBjaGFyYWN0ZXJzIHRoYXQgY2FuJ3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzLlxuICAgICAgICBzb3VyY2UgKz0gc3RyaW5nLnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UocmVVbmVzY2FwZWRTdHJpbmcsIGVzY2FwZVN0cmluZ0NoYXIpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgICAgICBpZiAoZXNjYXBlVmFsdWUpIHtcbiAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG5fX2UoXCIgKyBlc2NhcGVWYWx1ZSArIFwiKSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGVWYWx1ZSArIFwiO1xcbl9fcCArPSAnXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgICAgICBzb3VyY2UgKz0gXCInICtcXG4oKF9fdCA9IChcIiArIGludGVycG9sYXRlVmFsdWUgKyBcIikpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgICAvLyBUaGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIHByb2R1Y3RzIG5lZWRzIGBtYXRjaGAgcmV0dXJuZWQgaW5cbiAgICAgICAgLy8gb3JkZXIgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBgb2Zmc2V0YCB2YWx1ZS5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7XG5cbiAgICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAgIC8vIElmIGB2YXJpYWJsZWAgaXMgbm90IHNwZWNpZmllZCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWRcbiAgICAgIC8vIGNvZGUgdG8gYWRkIHRoZSBkYXRhIG9iamVjdCB0byB0aGUgdG9wIG9mIHRoZSBzY29wZSBjaGFpbi5cbiAgICAgIHZhciB2YXJpYWJsZSA9IGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3ZhcmlhYmxlJykgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgc291cmNlID0gJ3dpdGggKG9iaikge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICAvLyBDbGVhbnVwIGNvZGUgYnkgc3RyaXBwaW5nIGVtcHR5IHN0cmluZ3MuXG4gICAgICBzb3VyY2UgPSAoaXNFdmFsdWF0aW5nID8gc291cmNlLnJlcGxhY2UocmVFbXB0eVN0cmluZ0xlYWRpbmcsICcnKSA6IHNvdXJjZSlcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAgIC8vIEZyYW1lIGNvZGUgYXMgdGhlIGZ1bmN0aW9uIGJvZHkuXG4gICAgICBzb3VyY2UgPSAnZnVuY3Rpb24oJyArICh2YXJpYWJsZSB8fCAnb2JqJykgKyAnKSB7XFxuJyArXG4gICAgICAgICh2YXJpYWJsZVxuICAgICAgICAgID8gJydcbiAgICAgICAgICA6ICdvYmogfHwgKG9iaiA9IHt9KTtcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBcInZhciBfX3QsIF9fcCA9ICcnXCIgK1xuICAgICAgICAoaXNFc2NhcGluZ1xuICAgICAgICAgICA/ICcsIF9fZSA9IF8uZXNjYXBlJ1xuICAgICAgICAgICA6ICcnXG4gICAgICAgICkgK1xuICAgICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgICAgPyAnLCBfX2ogPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG4nICtcbiAgICAgICAgICAgIFwiZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCJcbiAgICAgICAgICA6ICc7XFxuJ1xuICAgICAgICApICtcbiAgICAgICAgc291cmNlICtcbiAgICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgICAgdmFyIHJlc3VsdCA9IGF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvbihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgJ3JldHVybiAnICsgc291cmNlKVxuICAgICAgICAgIC5hcHBseSh1bmRlZmluZWQsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAgICAgLy8gdGhlIGBzb3VyY2VgIHByb3BlcnR5IGFzIGEgY29udmVuaWVuY2UgZm9yIGlubGluaW5nIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICBpZiAoaXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIGxvd2VyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b0xvd2VyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9Mb3dlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tZm9vLWJhci0tJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vYmFyJ1xuICAgICAqXG4gICAgICogXy50b0xvd2VyKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdfX2Zvb19iYXJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvd2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIGEgd2hvbGUsIHRvIHVwcGVyIGNhc2UganVzdCBsaWtlXG4gICAgICogW1N0cmluZyN0b1VwcGVyQ2FzZV0oaHR0cHM6Ly9tZG4uaW8vdG9VcHBlckNhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJy0tRk9PLUJBUi0tJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PQkFSJ1xuICAgICAqXG4gICAgICogXy50b1VwcGVyKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdfX0ZPT19CQVJfXydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1VwcGVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8udHJpbSgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnICBmb28gICcsICcgIGJhciAgJ10sIF8udHJpbSk7XG4gICAgICogLy8gPT4gWydmb28nLCAnYmFyJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBjaHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShjaGFycyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0cmFpbGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltRW5kKCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJyAgYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltRW5kKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnLV8tYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1FbmQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltRW5kLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgbGVhZGluZyB3aGl0ZXNwYWNlIG9yIHNwZWNpZmllZCBjaGFyYWN0ZXJzIGZyb20gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPXdoaXRlc3BhY2VdIFRoZSBjaGFyYWN0ZXJzIHRvIHRyaW0uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjICAnXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiYy1fLSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltU3RhcnQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgc3RhcnQgPSBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgc3RyaW5nVG9BcnJheShjaGFycykpO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0KS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZXMgYHN0cmluZ2AgaWYgaXQncyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIFRoZSBsYXN0IGNoYXJhY3RlcnMgb2YgdGhlIHRydW5jYXRlZCBzdHJpbmcgYXJlIHJlcGxhY2VkIHdpdGggdGhlIG9taXNzaW9uXG4gICAgICogc3RyaW5nIHdoaWNoIGRlZmF1bHRzIHRvIFwiLi4uXCIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxlbmd0aD0zMF0gVGhlIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMub21pc3Npb249Jy4uLiddIFRoZSBzdHJpbmcgdG8gaW5kaWNhdGUgdGV4dCBpcyBvbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW29wdGlvbnMuc2VwYXJhdG9yXSBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gdHJ1bmNhdGUgdG8uXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJ1bmNhdGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycpO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm8uLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6ICcgJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAvLD8gKy9cbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdvbWlzc2lvbic6ICcgWy4uLl0nXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZyBbLi4uXSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShzdHJpbmcsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBERUZBVUxUX1RSVU5DX0xFTkdUSCxcbiAgICAgICAgICBvbWlzc2lvbiA9IERFRkFVTFRfVFJVTkNfT01JU1NJT047XG5cbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gJ3NlcGFyYXRvcicgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICBsZW5ndGggPSAnbGVuZ3RoJyBpbiBvcHRpb25zID8gdG9JbnRlZ2VyKG9wdGlvbnMubGVuZ3RoKSA6IGxlbmd0aDtcbiAgICAgICAgb21pc3Npb24gPSAnb21pc3Npb24nIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgaWYgKGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICAgICAgc3RyTGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoID49IHN0ckxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIHN0cmluZ1NpemUob21pc3Npb24pO1xuICAgICAgaWYgKGVuZCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHN0clN5bWJvbHNcbiAgICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKVxuICAgICAgICA6IHN0cmluZy5zbGljZSgwLCBlbmQpO1xuXG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKHN0clN5bWJvbHMpIHtcbiAgICAgICAgZW5kICs9IChyZXN1bHQubGVuZ3RoIC0gZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1JlZ0V4cChzZXBhcmF0b3IpKSB7XG4gICAgICAgIGlmIChzdHJpbmcuc2xpY2UoZW5kKS5zZWFyY2goc2VwYXJhdG9yKSkge1xuICAgICAgICAgIHZhciBtYXRjaCxcbiAgICAgICAgICAgICAgc3Vic3RyaW5nID0gcmVzdWx0O1xuXG4gICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgdG9TdHJpbmcocmVGbGFncy5leGVjKHNlcGFyYXRvcikpICsgJ2cnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpKSB7XG4gICAgICAgICAgICB2YXIgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBuZXdFbmQgPT09IHVuZGVmaW5lZCA/IGVuZCA6IG5ld0VuZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RyaW5nLmluZGV4T2YoYmFzZVRvU3RyaW5nKHNlcGFyYXRvciksIGVuZCkgIT0gZW5kKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW52ZXJzZSBvZiBgXy5lc2NhcGVgOyB0aGlzIG1ldGhvZCBjb252ZXJ0cyB0aGUgSFRNTCBlbnRpdGllc1xuICAgICAqIGAmYW1wO2AsIGAmbHQ7YCwgYCZndDtgLCBgJnF1b3Q7YCwgYW5kIGAmIzM5O2AgaW4gYHN0cmluZ2AgdG9cbiAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm8gb3RoZXIgSFRNTCBlbnRpdGllcyBhcmUgdW5lc2NhcGVkLiBUbyB1bmVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogSFRNTCBlbnRpdGllcyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzRXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgLCBhcyBzcGFjZSBzZXBhcmF0ZWQgd29yZHMsIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCctLWZvby1iYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKlxuICAgICAqIF8udXBwZXJDYXNlKCdfX2Zvb19iYXJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGUkVEJ1xuICAgICAqL1xuICAgIHZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogU3BsaXRzIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbcGF0dGVybl0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd29yZHMuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcyddXG4gICAgICpcbiAgICAgKiBfLndvcmRzKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycsIC9bXiwgXSsvZyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICcmJywgJ3BlYmJsZXMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdvcmRzKHN0cmluZywgcGF0dGVybiwgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwYXR0ZXJuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBwYXR0ZXJuO1xuXG4gICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHBhdHRlcm4pIHx8IFtdO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGludm9rZSBgZnVuY2AsIHJldHVybmluZyBlaXRoZXIgdGhlIHJlc3VsdCBvciB0aGUgY2F1Z2h0IGVycm9yXG4gICAgICogb2JqZWN0LiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYGZ1bmNgIHJlc3VsdCBvciBlcnJvciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIHRocm93aW5nIGVycm9ycyBmb3IgaW52YWxpZCBzZWxlY3RvcnMuXG4gICAgICogdmFyIGVsZW1lbnRzID0gXy5hdHRlbXB0KGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICogICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICogfSwgJz5fPicpO1xuICAgICAqXG4gICAgICogaWYgKF8uaXNFcnJvcihlbGVtZW50cykpIHtcbiAgICAgKiAgIGVsZW1lbnRzID0gW107XG4gICAgICogfVxuICAgICAqL1xuICAgIHZhciBhdHRlbXB0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgYXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBpc0Vycm9yKGUpID8gZSA6IG5ldyBFcnJvcihlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEJpbmRzIG1ldGhvZHMgb2YgYW4gb2JqZWN0IHRvIHRoZSBvYmplY3QgaXRzZWxmLCBvdmVyd3JpdGluZyB0aGUgZXhpc3RpbmdcbiAgICAgKiBtZXRob2QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gYmluZCBhbmQgYXNzaWduIHRoZSBib3VuZCBtZXRob2RzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IG1ldGhvZE5hbWVzIFRoZSBvYmplY3QgbWV0aG9kIG5hbWVzIHRvIGJpbmQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHZpZXcgPSB7XG4gICAgICogICAnbGFiZWwnOiAnZG9jcycsXG4gICAgICogICAnY2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coJ2NsaWNrZWQgJyArIHRoaXMubGFiZWwpO1xuICAgICAqICAgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmJpbmRBbGwodmlldywgWydjbGljayddKTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdmlldy5jbGljayk7XG4gICAgICogLy8gPT4gTG9ncyAnY2xpY2tlZCBkb2NzJyB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgdmFyIGJpbmRBbGwgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIG1ldGhvZE5hbWVzKSB7XG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBrZXkgPSB0b0tleShrZXkpO1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIGJpbmQob2JqZWN0W2tleV0sIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXRlcmF0ZXMgb3ZlciBgcGFpcnNgIGFuZCBpbnZva2VzIHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICogZnVuY3Rpb24gb2YgdGhlIGZpcnN0IHByZWRpY2F0ZSB0byByZXR1cm4gdHJ1dGh5LiBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uXG4gICAgICogcGFpcnMgYXJlIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlycyBUaGUgcHJlZGljYXRlLWZ1bmN0aW9uIHBhaXJzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLmNvbmQoW1xuICAgICAqICAgW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgICAgICAgICAgIF8uY29uc3RhbnQoJ21hdGNoZXMgQScpXSxcbiAgICAgKiAgIFtfLmNvbmZvcm1zKHsgJ2InOiBfLmlzTnVtYmVyIH0pLCBfLmNvbnN0YW50KCdtYXRjaGVzIEInKV0sXG4gICAgICogICBbXy5zdHViVHJ1ZSwgICAgICAgICAgICAgICAgICAgICAgXy5jb25zdGFudCgnbm8gbWF0Y2gnKV1cbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBBJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMCwgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEInXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAnMScsICdiJzogJzInIH0pO1xuICAgICAqIC8vID0+ICdubyBtYXRjaCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25kKHBhaXJzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgdG9JdGVyYXRlZSA9IGdldEl0ZXJhdGVlKCk7XG5cbiAgICAgIHBhaXJzID0gIWxlbmd0aCA/IFtdIDogYXJyYXlNYXAocGFpcnMsIGZ1bmN0aW9uKHBhaXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWlyWzFdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0b0l0ZXJhdGVlKHBhaXJbMF0pLCBwYWlyWzFdXTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgICBpZiAoYXBwbHkocGFpclswXSwgdGhpcywgYXJncykpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShwYWlyWzFdLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHByZWRpY2F0ZSBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHdpdGhcbiAgICAgKiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYSBnaXZlbiBvYmplY3QsIHJldHVybmluZyBgdHJ1ZWAgaWZcbiAgICAgKiBhbGwgcHJlZGljYXRlcyByZXR1cm4gdHJ1dGh5LCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc1RvYCB3aXRoXG4gICAgICogYHNvdXJjZWAgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSBwcmVkaWNhdGVzIHRvIGNvbmZvcm0gdG8uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMiwgJ2InOiAxIH0sXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5jb25mb3Jtcyh7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDE7IH0gfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZm9ybXMoc291cmNlKSB7XG4gICAgICByZXR1cm4gYmFzZUNvbmZvcm1zKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgYHZhbHVlYCB0byBkZXRlcm1pbmUgd2hldGhlciBhIGRlZmF1bHQgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkIGluXG4gICAgICogaXRzIHBsYWNlLiBUaGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaWYgYHZhbHVlYCBpcyBgTmFOYCwgYG51bGxgLFxuICAgICAqIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHsqfSBkZWZhdWx0VmFsdWUgVGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbygxLCAxMCk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8odW5kZWZpbmVkLCAxMCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWZhdWx0VG8odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcmV0dXJuICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSkgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uc1xuICAgICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3coW18uYWRkLCBzcXVhcmVdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93ID0gY3JlYXRlRmxvdygpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbG93YCBleGNlcHQgdGhhdCBpdCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdFxuICAgICAqIGludm9rZXMgdGhlIGdpdmVuIGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhZGRTcXVhcmUgPSBfLmZsb3dSaWdodChbc3F1YXJlLCBfLmFkZF0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3dSaWdodCA9IGNyZWF0ZUZsb3codHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uIElmIGBmdW5jYCBpcyBhIHByb3BlcnR5IG5hbWUsIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgdGhlXG4gICAgICogcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZWxlbWVudC4gSWYgYGZ1bmNgIGlzIGFuIGFycmF5IG9yIG9iamVjdCwgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgZWxlbWVudHMgdGhhdCBjb250YWluIHRoZSBlcXVpdmFsZW50XG4gICAgICogc291cmNlIHByb3BlcnRpZXMsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gW2Z1bmM9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNhbGxiYWNrLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IHRydWUgfSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZShbJ3VzZXInLCAnZnJlZCddKSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnZnJlZCcsICdhZ2UnOiA0MCB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXAodXNlcnMsIF8uaXRlcmF0ZWUoJ3VzZXInKSk7XG4gICAgICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBDcmVhdGUgY3VzdG9tIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICogXy5pdGVyYXRlZSA9IF8ud3JhcChfLml0ZXJhdGVlLCBmdW5jdGlvbihpdGVyYXRlZSwgZnVuYykge1xuICAgICAqICAgcmV0dXJuICFfLmlzUmVnRXhwKGZ1bmMpID8gaXRlcmF0ZWUoZnVuYykgOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgKiAgICAgcmV0dXJuIGZ1bmMudGVzdChzdHJpbmcpO1xuICAgICAqICAgfTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsnYWJjJywgJ2RlZiddLCAvZWYvKTtcbiAgICAgKiAvLyA9PiBbJ2RlZiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWUoZnVuYykge1xuICAgICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh0eXBlb2YgZnVuYyA9PSAnZnVuY3Rpb24nID8gZnVuYyA6IGJhc2VDbG9uZShmdW5jLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYSBnaXZlblxuICAgICAqIG9iamVjdCBhbmQgYHNvdXJjZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBoYXMgZXF1aXZhbGVudFxuICAgICAqIHByb3BlcnR5IHZhbHVlcywgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uaXNNYXRjaGAgd2l0aCBgc291cmNlYFxuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE11bHRpcGxlIHZhbHVlcyBjYW4gYmUgY2hlY2tlZCBieSBjb21iaW5pbmcgc2V2ZXJhbCBtYXRjaGVyc1xuICAgICAqIHVzaW5nIGBfLm92ZXJTb21lYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm1hdGNoZXMoeyAnYSc6IDQsICdjJzogNiB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XVxuICAgICAqXG4gICAgICogLy8gQ2hlY2tpbmcgZm9yIHNldmVyYWwgcG9zc2libGUgdmFsdWVzXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5vdmVyU29tZShbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCBfLm1hdGNoZXMoeyAnYSc6IDQgfSldKSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0aGVcbiAgICAgKiB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QgdG8gYHNyY1ZhbHVlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGVcbiAgICAgKiBvYmplY3QgdmFsdWUgaXMgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0XG4gICAgICogYHNyY1ZhbHVlYCB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZVxuICAgICAqIGBfLmlzRXF1YWxgIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE11bHRpcGxlIHZhbHVlcyBjYW4gYmUgY2hlY2tlZCBieSBjb21iaW5pbmcgc2V2ZXJhbCBtYXRjaGVyc1xuICAgICAqIHVzaW5nIGBfLm92ZXJTb21lYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH0sXG4gICAgICogICB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmQob2JqZWN0cywgXy5tYXRjaGVzUHJvcGVydHkoJ2EnLCA0KSk7XG4gICAgICogLy8gPT4geyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKlxuICAgICAqIC8vIENoZWNraW5nIGZvciBzZXZlcmFsIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ub3ZlclNvbWUoW18ubWF0Y2hlc1Byb3BlcnR5KCdhJywgMSksIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCldKSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LCB7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIGJhc2VDbG9uZShzcmNWYWx1ZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIHRvIHRoZSBpbnZva2VkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiBfLmNvbnN0YW50KDIpIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgxKSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5tZXRob2QoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKFsnYScsICdiJ10pKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5tZXRob2RgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogdGhlIG1ldGhvZCBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmVcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgaW52b2tlciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gXy50aW1lcygzLCBfLmNvbnN0YW50KSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLm1ldGhvZE9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIHZhciBtZXRob2RPZiA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgYXJncykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGFsbCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBhIHNvdXJjZVxuICAgICAqIG9iamVjdCB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LiBJZiBgb2JqZWN0YCBpcyBhIGZ1bmN0aW9uLCB0aGVuIG1ldGhvZHNcbiAgICAgKiBhcmUgYWRkZWQgdG8gaXRzIHByb3RvdHlwZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVzZSBgXy5ydW5JbkNvbnRleHRgIHRvIGNyZWF0ZSBhIHByaXN0aW5lIGBsb2Rhc2hgIGZ1bmN0aW9uIHRvXG4gICAgICogYXZvaWQgY29uZmxpY3RzIGNhdXNlZCBieSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gW29iamVjdD1sb2Rhc2hdIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9ucyB0byBhZGQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGFpbj10cnVlXSBTcGVjaWZ5IHdoZXRoZXIgbWl4aW5zIGFyZSBjaGFpbmFibGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gdm93ZWxzKHN0cmluZykge1xuICAgICAqICAgcmV0dXJuIF8uZmlsdGVyKHN0cmluZywgZnVuY3Rpb24odikge1xuICAgICAqICAgICByZXR1cm4gL1thZWlvdV0vaS50ZXN0KHYpO1xuICAgICAqICAgfSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5taXhpbih7ICd2b3dlbHMnOiB2b3dlbHMgfSk7XG4gICAgICogXy52b3dlbHMoJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqXG4gICAgICogXygnZnJlZCcpLnZvd2VscygpLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0sIHsgJ2NoYWluJzogZmFsc2UgfSk7XG4gICAgICogXygnZnJlZCcpLnZvd2VscygpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKSxcbiAgICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBwcm9wcyk7XG5cbiAgICAgIGlmIChvcHRpb25zID09IG51bGwgJiZcbiAgICAgICAgICAhKGlzT2JqZWN0KHNvdXJjZSkgJiYgKG1ldGhvZE5hbWVzLmxlbmd0aCB8fCAhcHJvcHMubGVuZ3RoKSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgc291cmNlID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QgPSB0aGlzO1xuICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgfVxuICAgICAgdmFyIGNoYWluID0gIShpc09iamVjdChvcHRpb25zKSAmJiAnY2hhaW4nIGluIG9wdGlvbnMpIHx8ICEhb3B0aW9ucy5jaGFpbixcbiAgICAgICAgICBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9iamVjdCk7XG5cbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgb2JqZWN0W21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgaWYgKGlzRnVuYykge1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fO1xuICAgICAgICAgICAgaWYgKGNoYWluIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBvYmplY3QodGhpcy5fX3dyYXBwZWRfXyksXG4gICAgICAgICAgICAgICAgICBhY3Rpb25zID0gcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuXG4gICAgICAgICAgICAgIGFjdGlvbnMucHVzaCh7ICdmdW5jJzogZnVuYywgJ2FyZ3MnOiBhcmd1bWVudHMsICd0aGlzQXJnJzogb2JqZWN0IH0pO1xuICAgICAgICAgICAgICByZXN1bHQuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShvYmplY3QsIGFycmF5UHVzaChbdGhpcy52YWx1ZSgpXSwgYXJndW1lbnRzKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJ0cyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGxvZGFzaCA9IF8ubm9Db25mbGljdCgpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vQ29uZmxpY3QoKSB7XG4gICAgICBpZiAocm9vdC5fID09PSB0aGlzKSB7XG4gICAgICAgIHJvb3QuXyA9IG9sZERhc2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLm5vb3ApO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBnZXRzIHRoZSBhcmd1bWVudCBhdCBpbmRleCBgbmAuIElmIGBuYCBpcyBuZWdhdGl2ZSxcbiAgICAgKiB0aGUgbnRoIGFyZ3VtZW50IGZyb20gdGhlIGVuZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTBdIFRoZSBpbmRleCBvZiB0aGUgYXJndW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhc3MtdGhydSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygxKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2InXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ubnRoQXJnKC0yKTtcbiAgICAgKiBmdW5jKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gJ2MnXG4gICAgICovXG4gICAgZnVuY3Rpb24gbnRoQXJnKG4pIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gYmFzZU50aChhcmdzLCBuKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGl0ZXJhdGVlc2Agd2l0aCB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzXG4gICAgICogYW5kIHJldHVybnMgdGhlaXIgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXIoW01hdGgubWF4LCBNYXRoLm1pbl0pO1xuICAgICAqXG4gICAgICogZnVuYygxLCAyLCAzLCA0KTtcbiAgICAgKiAvLyA9PiBbNCwgMV1cbiAgICAgKi9cbiAgICB2YXIgb3ZlciA9IGNyZWF0ZU92ZXIoYXJyYXlNYXApO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYWxsKiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEZvbGxvd2luZyBzaG9ydGhhbmRzIGFyZSBwb3NzaWJsZSBmb3IgcHJvdmlkaW5nIHByZWRpY2F0ZXMuXG4gICAgICogUGFzcyBhbiBgT2JqZWN0YCBhbmQgaXQgd2lsbCBiZSB1c2VkIGFzIGFuIHBhcmFtZXRlciBmb3IgYF8ubWF0Y2hlc2AgdG8gY3JlYXRlIHRoZSBwcmVkaWNhdGUuXG4gICAgICogUGFzcyBhbiBgQXJyYXlgIG9mIHBhcmFtZXRlcnMgZm9yIGBfLm1hdGNoZXNQcm9wZXJ0eWAgYW5kIHRoZSBwcmVkaWNhdGUgd2lsbCBiZSBjcmVhdGVkIHVzaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckV2ZXJ5KFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBvdmVyRXZlcnkgPSBjcmVhdGVPdmVyKGFycmF5RXZlcnkpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYW55Kiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEZvbGxvd2luZyBzaG9ydGhhbmRzIGFyZSBwb3NzaWJsZSBmb3IgcHJvdmlkaW5nIHByZWRpY2F0ZXMuXG4gICAgICogUGFzcyBhbiBgT2JqZWN0YCBhbmQgaXQgd2lsbCBiZSB1c2VkIGFzIGFuIHBhcmFtZXRlciBmb3IgYF8ubWF0Y2hlc2AgdG8gY3JlYXRlIHRoZSBwcmVkaWNhdGUuXG4gICAgICogUGFzcyBhbiBgQXJyYXlgIG9mIHBhcmFtZXRlcnMgZm9yIGBfLm1hdGNoZXNQcm9wZXJ0eWAgYW5kIHRoZSBwcmVkaWNhdGUgd2lsbCBiZSBjcmVhdGVkIHVzaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlclNvbWUoW0Jvb2xlYW4sIGlzRmluaXRlXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKCcxJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIHZhciBtYXRjaGVzRnVuYyA9IF8ub3ZlclNvbWUoW3sgJ2EnOiAxIH0sIHsgJ2EnOiAyIH1dKVxuICAgICAqIHZhciBtYXRjaGVzUHJvcGVydHlGdW5jID0gXy5vdmVyU29tZShbWydhJywgMV0sIFsnYScsIDJdXSlcbiAgICAgKi9cbiAgICB2YXIgb3ZlclNvbWUgPSBjcmVhdGVPdmVyKGFycmF5U29tZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICAgICAqIC8vID0+IFsyLCAxXVxuICAgICAqXG4gICAgICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gICAgICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucHJvcGVydHlgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zXG4gICAgICogdGhlIHZhbHVlIGF0IGEgZ2l2ZW4gcGF0aCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMCwgMSwgMl0sXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqXG4gICAgICogXy5tYXAoW1snYScsICcyJ10sIFsnYycsICcwJ11dLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHlPZihvYmplY3QpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICAgKiBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuIEEgc3RlcCBvZiBgLTFgIGlzIHVzZWQgaWYgYSBuZWdhdGl2ZVxuICAgICAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICAgICAqIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZSg0KTtcbiAgICAgKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoLTQpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA1KTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZSA9IGNyZWF0ZVJhbmdlKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJhbmdlYCBleGNlcHQgdGhhdCBpdCBwb3B1bGF0ZXMgdmFsdWVzIGluXG4gICAgICogZGVzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoNCk7XG4gICAgICogLy8gPT4gWzMsIDIsIDEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoLTQpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDUpO1xuICAgICAqIC8vID0+IFs0LCAzLCAyLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTUsIDEwLCA1LCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDAsIC00LCAtMSk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2VSaWdodCA9IGNyZWF0ZVJhbmdlKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICAgICAqIC8vID0+IFtbXSwgW11dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gICAgICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5zdHViT2JqZWN0KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7fSwge31dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJPYmplY3QoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJycsICcnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViVHJ1ZSk7XG4gICAgICogLy8gPT4gW3RydWUsIHRydWVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlRydWUoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBpdGVyYXRlZSBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cyBvZlxuICAgICAqIGVhY2ggaW52b2NhdGlvbi4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7IChpbmRleCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDMsIFN0cmluZyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnLCAnMiddXG4gICAgICpcbiAgICAgKiAgXy50aW1lcyg0LCBfLmNvbnN0YW50KDApKTtcbiAgICAgKiAvLyA9PiBbMCwgMCwgMCwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZSkge1xuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILFxuICAgICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKTtcblxuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSk7XG4gICAgICBuIC09IE1BWF9BUlJBWV9MRU5HVEg7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICcwJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCB0b0tleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNTeW1ib2wodmFsdWUpID8gW3ZhbHVlXSA6IGNvcHlBcnJheShzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmlxdWUgSUQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoJ2NvbnRhY3RfJyk7XG4gICAgICogLy8gPT4gJ2NvbnRhY3RfMTA0J1xuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgpO1xuICAgICAqIC8vID0+ICcxMDUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XG4gICAgICB2YXIgaWQgPSArK2lkQ291bnRlcjtcbiAgICAgIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGF1Z2VuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdG90YWwuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uYWRkKDYsIDQpO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgdmFyIGFkZCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oYXVnZW5kLCBhZGRlbmQpIHtcbiAgICAgIHJldHVybiBhdWdlbmQgKyBhZGRlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHVwIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIHVwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdXAgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCB1cCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg0LjAwNik7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogXy5jZWlsKDYuMDA0LCAyKTtcbiAgICAgKiAvLyA9PiA2LjAxXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNjA0MCwgLTIpO1xuICAgICAqIC8vID0+IDYxMDBcbiAgICAgKi9cbiAgICB2YXIgY2VpbCA9IGNyZWF0ZVJvdW5kKCdjZWlsJyk7XG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGUgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpZGVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3IgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBxdW90aWVudC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kaXZpZGUoNiwgNCk7XG4gICAgICogLy8gPT4gMS41XG4gICAgICovXG4gICAgdmFyIGRpdmlkZSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgIHJldHVybiBkaXZpZGVuZCAvIGRpdmlzb3I7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIGRvd24gdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgZG93bi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIGRvd24gdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBkb3duIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mbG9vcig0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5mbG9vcigwLjA0NiwgMik7XG4gICAgICogLy8gPT4gMC4wNFxuICAgICAqXG4gICAgICogXy5mbG9vcig0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDAwMFxuICAgICAqL1xuICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKCdmbG9vcicpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXgoW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1heGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tYXhCeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtZWFuIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1lYW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbihhcnJheSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBpZGVudGl0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZWFuYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgYXZlcmFnZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1pbmltdW0gdmFsdWUgb2YgYGFycmF5YC4gSWYgYGFycmF5YCBpcyBlbXB0eSBvciBmYWxzZXksXG4gICAgICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogXy5taW4oW10pO1xuICAgICAqIC8vID0+IHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1pbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICAgICAqIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gICAgICpcbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5taW5CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE11bHRpcGx5IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGllciBUaGUgZmlyc3QgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpY2FuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHByb2R1Y3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubXVsdGlwbHkoNiwgNCk7XG4gICAgICogLy8gPT4gMjRcbiAgICAgKi9cbiAgICB2YXIgbXVsdGlwbHkgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG11bHRpcGxpZXIsIG11bHRpcGxpY2FuZCkge1xuICAgICAgcmV0dXJuIG11bHRpcGxpZXIgKiBtdWx0aXBsaWNhbmQ7XG4gICAgfSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBgbnVtYmVyYCByb3VuZGVkIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgdG8uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcm91bmRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNC4wMDYsIDIpO1xuICAgICAqIC8vID0+IDQuMDFcbiAgICAgKlxuICAgICAqIF8ucm91bmQoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQxMDBcbiAgICAgKi9cbiAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZCgncm91bmQnKTtcblxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0IHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWludWVuZCBUaGUgZmlyc3QgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN1YnRyYWhlbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1YnRyYWN0KDYsIDQpO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG1pbnVlbmQsIHN1YnRyYWhlbmQpIHtcbiAgICAgIHJldHVybiBtaW51ZW5kIC0gc3VidHJhaGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdW0oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgaWRlbnRpdHkpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnN1bWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIHN1bW1lZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zdW1CeShvYmplY3RzLCAnbicpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB3cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFmdGVyID0gYWZ0ZXI7XG4gICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICBsb2Rhc2guYXNzaWduID0gYXNzaWduO1xuICAgIGxvZGFzaC5hc3NpZ25JbiA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5hc3NpZ25JbldpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgbG9kYXNoLmFzc2lnbldpdGggPSBhc3NpZ25XaXRoO1xuICAgIGxvZGFzaC5hdCA9IGF0O1xuICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICAgIGxvZGFzaC5iaW5kQWxsID0gYmluZEFsbDtcbiAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgbG9kYXNoLmNhc3RBcnJheSA9IGNhc3RBcnJheTtcbiAgICBsb2Rhc2guY2hhaW4gPSBjaGFpbjtcbiAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICBsb2Rhc2guY29tcGFjdCA9IGNvbXBhY3Q7XG4gICAgbG9kYXNoLmNvbmNhdCA9IGNvbmNhdDtcbiAgICBsb2Rhc2guY29uZCA9IGNvbmQ7XG4gICAgbG9kYXNoLmNvbmZvcm1zID0gY29uZm9ybXM7XG4gICAgbG9kYXNoLmNvbnN0YW50ID0gY29uc3RhbnQ7XG4gICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgIGxvZGFzaC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgbG9kYXNoLmN1cnJ5ID0gY3Vycnk7XG4gICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIGxvZGFzaC5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuICAgIGxvZGFzaC5kZWZhdWx0c0RlZXAgPSBkZWZhdWx0c0RlZXA7XG4gICAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XG4gICAgbG9kYXNoLmRlbGF5ID0gZGVsYXk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlQnkgPSBkaWZmZXJlbmNlQnk7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VXaXRoID0gZGlmZmVyZW5jZVdpdGg7XG4gICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgIGxvZGFzaC5kcm9wUmlnaHQgPSBkcm9wUmlnaHQ7XG4gICAgbG9kYXNoLmRyb3BSaWdodFdoaWxlID0gZHJvcFJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICBsb2Rhc2guZmlsbCA9IGZpbGw7XG4gICAgbG9kYXNoLmZpbHRlciA9IGZpbHRlcjtcbiAgICBsb2Rhc2guZmxhdE1hcCA9IGZsYXRNYXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZWVwID0gZmxhdE1hcERlZXA7XG4gICAgbG9kYXNoLmZsYXRNYXBEZXB0aCA9IGZsYXRNYXBEZXB0aDtcbiAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgbG9kYXNoLmZsYXR0ZW5EZWVwID0gZmxhdHRlbkRlZXA7XG4gICAgbG9kYXNoLmZsYXR0ZW5EZXB0aCA9IGZsYXR0ZW5EZXB0aDtcbiAgICBsb2Rhc2guZmxpcCA9IGZsaXA7XG4gICAgbG9kYXNoLmZsb3cgPSBmbG93O1xuICAgIGxvZGFzaC5mbG93UmlnaHQgPSBmbG93UmlnaHQ7XG4gICAgbG9kYXNoLmZyb21QYWlycyA9IGZyb21QYWlycztcbiAgICBsb2Rhc2guZnVuY3Rpb25zID0gZnVuY3Rpb25zO1xuICAgIGxvZGFzaC5mdW5jdGlvbnNJbiA9IGZ1bmN0aW9uc0luO1xuICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICBsb2Rhc2guaW5pdGlhbCA9IGluaXRpYWw7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uQnkgPSBpbnRlcnNlY3Rpb25CeTtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uV2l0aCA9IGludGVyc2VjdGlvbldpdGg7XG4gICAgbG9kYXNoLmludmVydCA9IGludmVydDtcbiAgICBsb2Rhc2guaW52ZXJ0QnkgPSBpbnZlcnRCeTtcbiAgICBsb2Rhc2guaW52b2tlTWFwID0gaW52b2tlTWFwO1xuICAgIGxvZGFzaC5pdGVyYXRlZSA9IGl0ZXJhdGVlO1xuICAgIGxvZGFzaC5rZXlCeSA9IGtleUJ5O1xuICAgIGxvZGFzaC5rZXlzID0ga2V5cztcbiAgICBsb2Rhc2gua2V5c0luID0ga2V5c0luO1xuICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgbG9kYXNoLm1hcEtleXMgPSBtYXBLZXlzO1xuICAgIGxvZGFzaC5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7XG4gICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgIGxvZGFzaC5tYXRjaGVzUHJvcGVydHkgPSBtYXRjaGVzUHJvcGVydHk7XG4gICAgbG9kYXNoLm1lbW9pemUgPSBtZW1vaXplO1xuICAgIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICAgIGxvZGFzaC5tZXJnZVdpdGggPSBtZXJnZVdpdGg7XG4gICAgbG9kYXNoLm1ldGhvZCA9IG1ldGhvZDtcbiAgICBsb2Rhc2gubWV0aG9kT2YgPSBtZXRob2RPZjtcbiAgICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgIGxvZGFzaC5udGhBcmcgPSBudGhBcmc7XG4gICAgbG9kYXNoLm9taXQgPSBvbWl0O1xuICAgIGxvZGFzaC5vbWl0QnkgPSBvbWl0Qnk7XG4gICAgbG9kYXNoLm9uY2UgPSBvbmNlO1xuICAgIGxvZGFzaC5vcmRlckJ5ID0gb3JkZXJCeTtcbiAgICBsb2Rhc2gub3ZlciA9IG92ZXI7XG4gICAgbG9kYXNoLm92ZXJBcmdzID0gb3ZlckFyZ3M7XG4gICAgbG9kYXNoLm92ZXJFdmVyeSA9IG92ZXJFdmVyeTtcbiAgICBsb2Rhc2gub3ZlclNvbWUgPSBvdmVyU29tZTtcbiAgICBsb2Rhc2gucGFydGlhbCA9IHBhcnRpYWw7XG4gICAgbG9kYXNoLnBhcnRpYWxSaWdodCA9IHBhcnRpYWxSaWdodDtcbiAgICBsb2Rhc2gucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgIGxvZGFzaC5waWNrID0gcGljaztcbiAgICBsb2Rhc2gucGlja0J5ID0gcGlja0J5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIGxvZGFzaC5wcm9wZXJ0eU9mID0gcHJvcGVydHlPZjtcbiAgICBsb2Rhc2gucHVsbCA9IHB1bGw7XG4gICAgbG9kYXNoLnB1bGxBbGwgPSBwdWxsQWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsQnkgPSBwdWxsQWxsQnk7XG4gICAgbG9kYXNoLnB1bGxBbGxXaXRoID0gcHVsbEFsbFdpdGg7XG4gICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICBsb2Rhc2gucmFuZ2UgPSByYW5nZTtcbiAgICBsb2Rhc2gucmFuZ2VSaWdodCA9IHJhbmdlUmlnaHQ7XG4gICAgbG9kYXNoLnJlYXJnID0gcmVhcmc7XG4gICAgbG9kYXNoLnJlamVjdCA9IHJlamVjdDtcbiAgICBsb2Rhc2gucmVtb3ZlID0gcmVtb3ZlO1xuICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICBsb2Rhc2gucmV2ZXJzZSA9IHJldmVyc2U7XG4gICAgbG9kYXNoLnNhbXBsZVNpemUgPSBzYW1wbGVTaXplO1xuICAgIGxvZGFzaC5zZXQgPSBzZXQ7XG4gICAgbG9kYXNoLnNldFdpdGggPSBzZXRXaXRoO1xuICAgIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICBsb2Rhc2guc29ydEJ5ID0gc29ydEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxID0gc29ydGVkVW5pcTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcUJ5ID0gc29ydGVkVW5pcUJ5O1xuICAgIGxvZGFzaC5zcGxpdCA9IHNwbGl0O1xuICAgIGxvZGFzaC5zcHJlYWQgPSBzcHJlYWQ7XG4gICAgbG9kYXNoLnRhaWwgPSB0YWlsO1xuICAgIGxvZGFzaC50YWtlID0gdGFrZTtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0ID0gdGFrZVJpZ2h0O1xuICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuICAgIGxvZGFzaC50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XG4gICAgbG9kYXNoLnRhcCA9IHRhcDtcbiAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICBsb2Rhc2gudGhydSA9IHRocnU7XG4gICAgbG9kYXNoLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIGxvZGFzaC50b1BhaXJzID0gdG9QYWlycztcbiAgICBsb2Rhc2gudG9QYWlyc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC50b1BhdGggPSB0b1BhdGg7XG4gICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgbG9kYXNoLnVuYXJ5ID0gdW5hcnk7XG4gICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgbG9kYXNoLnVuaW9uQnkgPSB1bmlvbkJ5O1xuICAgIGxvZGFzaC51bmlvbldpdGggPSB1bmlvbldpdGg7XG4gICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgIGxvZGFzaC51bmlxQnkgPSB1bmlxQnk7XG4gICAgbG9kYXNoLnVuaXFXaXRoID0gdW5pcVdpdGg7XG4gICAgbG9kYXNoLnVuc2V0ID0gdW5zZXQ7XG4gICAgbG9kYXNoLnVuemlwID0gdW56aXA7XG4gICAgbG9kYXNoLnVuemlwV2l0aCA9IHVuemlwV2l0aDtcbiAgICBsb2Rhc2gudXBkYXRlID0gdXBkYXRlO1xuICAgIGxvZGFzaC51cGRhdGVXaXRoID0gdXBkYXRlV2l0aDtcbiAgICBsb2Rhc2gudmFsdWVzID0gdmFsdWVzO1xuICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgICBsb2Rhc2gud29yZHMgPSB3b3JkcztcbiAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgbG9kYXNoLnhvciA9IHhvcjtcbiAgICBsb2Rhc2gueG9yQnkgPSB4b3JCeTtcbiAgICBsb2Rhc2gueG9yV2l0aCA9IHhvcldpdGg7XG4gICAgbG9kYXNoLnppcCA9IHppcDtcbiAgICBsb2Rhc2guemlwT2JqZWN0ID0gemlwT2JqZWN0O1xuICAgIGxvZGFzaC56aXBPYmplY3REZWVwID0gemlwT2JqZWN0RGVlcDtcbiAgICBsb2Rhc2guemlwV2l0aCA9IHppcFdpdGg7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZW50cmllcyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLmVudHJpZXNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2guZXh0ZW5kID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmV4dGVuZFdpdGggPSBhc3NpZ25JbldpdGg7XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgbWl4aW4obG9kYXNoLCBsb2Rhc2gpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gdW53cmFwcGVkIHZhbHVlcyBpbiBjaGFpbiBzZXF1ZW5jZXMuXG4gICAgbG9kYXNoLmFkZCA9IGFkZDtcbiAgICBsb2Rhc2guYXR0ZW1wdCA9IGF0dGVtcHQ7XG4gICAgbG9kYXNoLmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbiAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgbG9kYXNoLmNlaWwgPSBjZWlsO1xuICAgIGxvZGFzaC5jbGFtcCA9IGNsYW1wO1xuICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgIGxvZGFzaC5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG4gICAgbG9kYXNoLmNsb25lRGVlcFdpdGggPSBjbG9uZURlZXBXaXRoO1xuICAgIGxvZGFzaC5jbG9uZVdpdGggPSBjbG9uZVdpdGg7XG4gICAgbG9kYXNoLmNvbmZvcm1zVG8gPSBjb25mb3Jtc1RvO1xuICAgIGxvZGFzaC5kZWJ1cnIgPSBkZWJ1cnI7XG4gICAgbG9kYXNoLmRlZmF1bHRUbyA9IGRlZmF1bHRUbztcbiAgICBsb2Rhc2guZGl2aWRlID0gZGl2aWRlO1xuICAgIGxvZGFzaC5lbmRzV2l0aCA9IGVuZHNXaXRoO1xuICAgIGxvZGFzaC5lcSA9IGVxO1xuICAgIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gICAgbG9kYXNoLmVzY2FwZVJlZ0V4cCA9IGVzY2FwZVJlZ0V4cDtcbiAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gICAgbG9kYXNoLmZpbmRJbmRleCA9IGZpbmRJbmRleDtcbiAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgbG9kYXNoLmZpbmRMYXN0ID0gZmluZExhc3Q7XG4gICAgbG9kYXNoLmZpbmRMYXN0SW5kZXggPSBmaW5kTGFzdEluZGV4O1xuICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgIGxvZGFzaC5mbG9vciA9IGZsb29yO1xuICAgIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5mb3JJbiA9IGZvckluO1xuICAgIGxvZGFzaC5mb3JJblJpZ2h0ID0gZm9ySW5SaWdodDtcbiAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgIGxvZGFzaC5mb3JPd25SaWdodCA9IGZvck93blJpZ2h0O1xuICAgIGxvZGFzaC5nZXQgPSBnZXQ7XG4gICAgbG9kYXNoLmd0ID0gZ3Q7XG4gICAgbG9kYXNoLmd0ZSA9IGd0ZTtcbiAgICBsb2Rhc2guaGFzID0gaGFzO1xuICAgIGxvZGFzaC5oYXNJbiA9IGhhc0luO1xuICAgIGxvZGFzaC5oZWFkID0gaGVhZDtcbiAgICBsb2Rhc2guaWRlbnRpdHkgPSBpZGVudGl0eTtcbiAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICBsb2Rhc2guaW5kZXhPZiA9IGluZGV4T2Y7XG4gICAgbG9kYXNoLmluUmFuZ2UgPSBpblJhbmdlO1xuICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgbG9kYXNoLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG4gICAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICAgIGxvZGFzaC5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2UgPSBpc0FycmF5TGlrZTtcbiAgICBsb2Rhc2guaXNBcnJheUxpa2VPYmplY3QgPSBpc0FycmF5TGlrZU9iamVjdDtcbiAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgIGxvZGFzaC5pc0J1ZmZlciA9IGlzQnVmZmVyO1xuICAgIGxvZGFzaC5pc0RhdGUgPSBpc0RhdGU7XG4gICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgbG9kYXNoLmlzRXF1YWwgPSBpc0VxdWFsO1xuICAgIGxvZGFzaC5pc0VxdWFsV2l0aCA9IGlzRXF1YWxXaXRoO1xuICAgIGxvZGFzaC5pc0Vycm9yID0gaXNFcnJvcjtcbiAgICBsb2Rhc2guaXNGaW5pdGUgPSBpc0Zpbml0ZTtcbiAgICBsb2Rhc2guaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4gICAgbG9kYXNoLmlzSW50ZWdlciA9IGlzSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNMZW5ndGggPSBpc0xlbmd0aDtcbiAgICBsb2Rhc2guaXNNYXAgPSBpc01hcDtcbiAgICBsb2Rhc2guaXNNYXRjaCA9IGlzTWF0Y2g7XG4gICAgbG9kYXNoLmlzTWF0Y2hXaXRoID0gaXNNYXRjaFdpdGg7XG4gICAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG4gICAgbG9kYXNoLmlzTmlsID0gaXNOaWw7XG4gICAgbG9kYXNoLmlzTnVsbCA9IGlzTnVsbDtcbiAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgICBsb2Rhc2guaXNPYmplY3RMaWtlID0gaXNPYmplY3RMaWtlO1xuICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgICBsb2Rhc2guaXNTYWZlSW50ZWdlciA9IGlzU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLmlzU2V0ID0gaXNTZXQ7XG4gICAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gICAgbG9kYXNoLmlzU3ltYm9sID0gaXNTeW1ib2w7XG4gICAgbG9kYXNoLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbiAgICBsb2Rhc2guaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcbiAgICBsb2Rhc2guaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuICAgIGxvZGFzaC5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG4gICAgbG9kYXNoLmpvaW4gPSBqb2luO1xuICAgIGxvZGFzaC5rZWJhYkNhc2UgPSBrZWJhYkNhc2U7XG4gICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgIGxvZGFzaC5sYXN0SW5kZXhPZiA9IGxhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5sb3dlckNhc2UgPSBsb3dlckNhc2U7XG4gICAgbG9kYXNoLmxvd2VyRmlyc3QgPSBsb3dlckZpcnN0O1xuICAgIGxvZGFzaC5sdCA9IGx0O1xuICAgIGxvZGFzaC5sdGUgPSBsdGU7XG4gICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICBsb2Rhc2gubWF4QnkgPSBtYXhCeTtcbiAgICBsb2Rhc2gubWVhbiA9IG1lYW47XG4gICAgbG9kYXNoLm1lYW5CeSA9IG1lYW5CeTtcbiAgICBsb2Rhc2gubWluID0gbWluO1xuICAgIGxvZGFzaC5taW5CeSA9IG1pbkJ5O1xuICAgIGxvZGFzaC5zdHViQXJyYXkgPSBzdHViQXJyYXk7XG4gICAgbG9kYXNoLnN0dWJGYWxzZSA9IHN0dWJGYWxzZTtcbiAgICBsb2Rhc2guc3R1Yk9iamVjdCA9IHN0dWJPYmplY3Q7XG4gICAgbG9kYXNoLnN0dWJTdHJpbmcgPSBzdHViU3RyaW5nO1xuICAgIGxvZGFzaC5zdHViVHJ1ZSA9IHN0dWJUcnVlO1xuICAgIGxvZGFzaC5tdWx0aXBseSA9IG11bHRpcGx5O1xuICAgIGxvZGFzaC5udGggPSBudGg7XG4gICAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICAgIGxvZGFzaC5ub29wID0gbm9vcDtcbiAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgIGxvZGFzaC5wYWQgPSBwYWQ7XG4gICAgbG9kYXNoLnBhZEVuZCA9IHBhZEVuZDtcbiAgICBsb2Rhc2gucGFkU3RhcnQgPSBwYWRTdGFydDtcbiAgICBsb2Rhc2gucGFyc2VJbnQgPSBwYXJzZUludDtcbiAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gICAgbG9kYXNoLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7XG4gICAgbG9kYXNoLnJlcGVhdCA9IHJlcGVhdDtcbiAgICBsb2Rhc2gucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgbG9kYXNoLnJlc3VsdCA9IHJlc3VsdDtcbiAgICBsb2Rhc2gucm91bmQgPSByb3VuZDtcbiAgICBsb2Rhc2gucnVuSW5Db250ZXh0ID0gcnVuSW5Db250ZXh0O1xuICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG4gICAgbG9kYXNoLnNpemUgPSBzaXplO1xuICAgIGxvZGFzaC5zbmFrZUNhc2UgPSBzbmFrZUNhc2U7XG4gICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleEJ5ID0gc29ydGVkSW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhPZiA9IHNvcnRlZEluZGV4T2Y7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleCA9IHNvcnRlZExhc3RJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4QnkgPSBzb3J0ZWRMYXN0SW5kZXhCeTtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4T2YgPSBzb3J0ZWRMYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2guc3RhcnRDYXNlID0gc3RhcnRDYXNlO1xuICAgIGxvZGFzaC5zdGFydHNXaXRoID0gc3RhcnRzV2l0aDtcbiAgICBsb2Rhc2guc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBsb2Rhc2guc3VtID0gc3VtO1xuICAgIGxvZGFzaC5zdW1CeSA9IHN1bUJ5O1xuICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICAgIGxvZGFzaC50b0Zpbml0ZSA9IHRvRmluaXRlO1xuICAgIGxvZGFzaC50b0ludGVnZXIgPSB0b0ludGVnZXI7XG4gICAgbG9kYXNoLnRvTGVuZ3RoID0gdG9MZW5ndGg7XG4gICAgbG9kYXNoLnRvTG93ZXIgPSB0b0xvd2VyO1xuICAgIGxvZGFzaC50b051bWJlciA9IHRvTnVtYmVyO1xuICAgIGxvZGFzaC50b1NhZmVJbnRlZ2VyID0gdG9TYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBsb2Rhc2gudG9VcHBlciA9IHRvVXBwZXI7XG4gICAgbG9kYXNoLnRyaW0gPSB0cmltO1xuICAgIGxvZGFzaC50cmltRW5kID0gdHJpbUVuZDtcbiAgICBsb2Rhc2gudHJpbVN0YXJ0ID0gdHJpbVN0YXJ0O1xuICAgIGxvZGFzaC50cnVuY2F0ZSA9IHRydW5jYXRlO1xuICAgIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgIGxvZGFzaC51cHBlckNhc2UgPSB1cHBlckNhc2U7XG4gICAgbG9kYXNoLnVwcGVyRmlyc3QgPSB1cHBlckZpcnN0O1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5lYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZpcnN0ID0gaGVhZDtcblxuICAgIG1peGluKGxvZGFzaCwgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHt9O1xuICAgICAgYmFzZUZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaC5wcm90b3R5cGUsIG1ldGhvZE5hbWUpKSB7XG4gICAgICAgICAgc291cmNlW21ldGhvZE5hbWVdID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gc291cmNlO1xuICAgIH0oKSksIHsgJ2NoYWluJzogZmFsc2UgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIGxvZGFzaC5WRVJTSU9OID0gVkVSU0lPTjtcblxuICAgIC8vIEFzc2lnbiBkZWZhdWx0IHBsYWNlaG9sZGVycy5cbiAgICBhcnJheUVhY2goWydiaW5kJywgJ2JpbmRLZXknLCAnY3VycnknLCAnY3VycnlSaWdodCcsICdwYXJ0aWFsJywgJ3BhcnRpYWxSaWdodCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5kcm9wYCBhbmQgYF8udGFrZWAgdmFyaWFudHMuXG4gICAgYXJyYXlFYWNoKFsnZHJvcCcsICd0YWtlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIG4gPSBuID09PSB1bmRlZmluZWQgPyAxIDogbmF0aXZlTWF4KHRvSW50ZWdlcihuKSwgMCk7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9ICh0aGlzLl9fZmlsdGVyZWRfXyAmJiAhaW5kZXgpXG4gICAgICAgICAgPyBuZXcgTGF6eVdyYXBwZXIodGhpcylcbiAgICAgICAgICA6IHRoaXMuY2xvbmUoKTtcblxuICAgICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXykge1xuICAgICAgICAgIHJlc3VsdC5fX3Rha2VDb3VudF9fID0gbmF0aXZlTWluKG4sIHJlc3VsdC5fX3Rha2VDb3VudF9fKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQuX192aWV3c19fLnB1c2goe1xuICAgICAgICAgICAgJ3NpemUnOiBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCksXG4gICAgICAgICAgICAndHlwZSc6IG1ldGhvZE5hbWUgKyAocmVzdWx0Ll9fZGlyX18gPCAwID8gJ1JpZ2h0JyA6ICcnKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArICdSaWdodCddID0gZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdGhhdCBhY2NlcHQgYW4gYGl0ZXJhdGVlYCB2YWx1ZS5cbiAgICBhcnJheUVhY2goWydmaWx0ZXInLCAnbWFwJywgJ3Rha2VXaGlsZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHR5cGUgPSBpbmRleCArIDEsXG4gICAgICAgICAgaXNGaWx0ZXIgPSB0eXBlID09IExBWllfRklMVEVSX0ZMQUcgfHwgdHlwZSA9PSBMQVpZX1dISUxFX0ZMQUc7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJlc3VsdC5fX2l0ZXJhdGVlc19fLnB1c2goe1xuICAgICAgICAgICdpdGVyYXRlZSc6IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSxcbiAgICAgICAgICAndHlwZSc6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5fX2ZpbHRlcmVkX18gPSByZXN1bHQuX19maWx0ZXJlZF9fIHx8IGlzRmlsdGVyO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmhlYWRgIGFuZCBgXy5sYXN0YC5cbiAgICBhcnJheUVhY2goWydoZWFkJywgJ2xhc3QnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0YWtlTmFtZSA9ICd0YWtlJyArIChpbmRleCA/ICdSaWdodCcgOiAnJyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5pbml0aWFsYCBhbmQgYF8udGFpbGAuXG4gICAgYXJyYXlFYWNoKFsnaW5pdGlhbCcsICd0YWlsJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgZHJvcE5hbWUgPSAnZHJvcCcgKyAoaW5kZXggPyAnJyA6ICdSaWdodCcpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19maWx0ZXJlZF9fID8gbmV3IExhenlXcmFwcGVyKHRoaXMpIDogdGhpc1tkcm9wTmFtZV0oMSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihpZGVudGl0eSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIocHJlZGljYXRlKS5oZWFkKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5maW5kTGFzdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIobmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0ludGVnZXIoc3RhcnQpO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcztcbiAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcihyZXN1bHQpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQudGFrZVJpZ2h0KC1zdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5kcm9wKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbmQgPSB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgcmVzdWx0ID0gZW5kIDwgMCA/IHJlc3VsdC5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQudGFrZShlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudGFrZVJpZ2h0V2hpbGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS50YWtlV2hpbGUocHJlZGljYXRlKS5yZXZlcnNlKCk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWtlKE1BWF9BUlJBWV9MRU5HVEgpO1xuICAgIH07XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGNoZWNrSXRlcmF0ZWUgPSAvXig/OmZpbHRlcnxmaW5kfG1hcHxyZWplY3QpfFdoaWxlJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBpc1Rha2VyID0gL14oPzpoZWFkfGxhc3QpJC8udGVzdChtZXRob2ROYW1lKSxcbiAgICAgICAgICBsb2Rhc2hGdW5jID0gbG9kYXNoW2lzVGFrZXIgPyAoJ3Rha2UnICsgKG1ldGhvZE5hbWUgPT0gJ2xhc3QnID8gJ1JpZ2h0JyA6ICcnKSkgOiBtZXRob2ROYW1lXSxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSBpc1Rha2VyIHx8IC9eZmluZC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXyxcbiAgICAgICAgICAgIGFyZ3MgPSBpc1Rha2VyID8gWzFdIDogYXJndW1lbnRzLFxuICAgICAgICAgICAgaXNMYXp5ID0gdmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcixcbiAgICAgICAgICAgIGl0ZXJhdGVlID0gYXJnc1swXSxcbiAgICAgICAgICAgIHVzZUxhenkgPSBpc0xhenkgfHwgaXNBcnJheSh2YWx1ZSk7XG5cbiAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9kYXNoRnVuYy5hcHBseShsb2Rhc2gsIGFycmF5UHVzaChbdmFsdWVdLCBhcmdzKSk7XG4gICAgICAgICAgcmV0dXJuIChpc1Rha2VyICYmIGNoYWluQWxsKSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodXNlTGF6eSAmJiBjaGVja0l0ZXJhdGVlICYmIHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nICYmIGl0ZXJhdGVlLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgLy8gQXZvaWQgbGF6eSB1c2UgaWYgdGhlIGl0ZXJhdGVlIGhhcyBhIFwibGVuZ3RoXCIgdmFsdWUgb3RoZXIgdGhhbiBgMWAuXG4gICAgICAgICAgaXNMYXp5ID0gdXNlTGF6eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLFxuICAgICAgICAgICAgaXNIeWJyaWQgPSAhIXRoaXMuX19hY3Rpb25zX18ubGVuZ3RoLFxuICAgICAgICAgICAgaXNVbndyYXBwZWQgPSByZXRVbndyYXBwZWQgJiYgIWNoYWluQWxsLFxuICAgICAgICAgICAgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuXG4gICAgICAgIGlmICghcmV0VW53cmFwcGVkICYmIHVzZUxhenkpIHtcbiAgICAgICAgICB2YWx1ZSA9IG9ubHlMYXp5ID8gdmFsdWUgOiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgIHJlc3VsdC5fX2FjdGlvbnNfXy5wdXNoKHsgJ2Z1bmMnOiB0aHJ1LCAnYXJncyc6IFtpbnRlcmNlcHRvcl0sICd0aGlzQXJnJzogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQsIGNoYWluQWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbndyYXBwZWQgJiYgb25seUxhenkpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSB0aGlzLnRocnUoaW50ZXJjZXB0b3IpO1xuICAgICAgICByZXR1cm4gaXNVbndyYXBwZWQgPyAoaXNUYWtlciA/IHJlc3VsdC52YWx1ZSgpWzBdIDogcmVzdWx0LnZhbHVlKCkpIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgQXJyYXlgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGFycmF5RWFjaChbJ3BvcCcsICdwdXNoJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBhcnJheVByb3RvW21ldGhvZE5hbWVdLFxuICAgICAgICAgIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/ICd0YXAnIDogJ3RocnUnLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IC9eKD86cG9wfHNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZSgpO1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbY2hhaW5OYW1lXShmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIE1hcCBtaW5pZmllZCBtZXRob2QgbmFtZXMgdG8gdGhlaXIgcmVhbCBuYW1lcy5cbiAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV07XG4gICAgICBpZiAobG9kYXNoRnVuYykge1xuICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lICsgJyc7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIGtleSkpIHtcbiAgICAgICAgICByZWFsTmFtZXNba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlYWxOYW1lc1trZXldLnB1c2goeyAnbmFtZSc6IG1ldGhvZE5hbWUsICdmdW5jJzogbG9kYXNoRnVuYyB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlYWxOYW1lc1tjcmVhdGVIeWJyaWQodW5kZWZpbmVkLCBXUkFQX0JJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3tcbiAgICAgICduYW1lJzogJ3dyYXBwZXInLFxuICAgICAgJ2Z1bmMnOiB1bmRlZmluZWRcbiAgICB9XTtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMYXp5V3JhcHBlcmAuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNsb25lID0gbGF6eUNsb25lO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZXZlcnNlID0gbGF6eVJldmVyc2U7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuXG4gICAgLy8gQWRkIGNoYWluIHNlcXVlbmNlIG1ldGhvZHMgdG8gdGhlIGBsb2Rhc2hgIHdyYXBwZXIuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5hdCA9IHdyYXBwZXJBdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY29tbWl0ID0gd3JhcHBlckNvbW1pdDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLm5leHQgPSB3cmFwcGVyTmV4dDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucmV2ZXJzZSA9IHdyYXBwZXJSZXZlcnNlO1xuICAgIGxvZGFzaC5wcm90b3R5cGUudG9KU09OID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZU9mID0gbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAgIC8vIEFkZCBsYXp5IGFsaWFzZXMuXG4gICAgbG9kYXNoLnByb3RvdHlwZS5maXJzdCA9IGxvZGFzaC5wcm90b3R5cGUuaGVhZDtcblxuICAgIGlmIChzeW1JdGVyYXRvcikge1xuICAgICAgbG9kYXNoLnByb3RvdHlwZVtzeW1JdGVyYXRvcl0gPSB3cmFwcGVyVG9JdGVyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIGxvZGFzaDtcbiAgfSk7XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gRXhwb3J0IGxvZGFzaC5cbiAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcblxuICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBjb25kaXRpb24gcGF0dGVybnMgbGlrZTpcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gRXhwb3NlIExvZGFzaCBvbiB0aGUgZ2xvYmFsIG9iamVjdCB0byBwcmV2ZW50IGVycm9ycyB3aGVuIExvZGFzaCBpc1xuICAgIC8vIGxvYWRlZCBieSBhIHNjcmlwdCB0YWcgaW4gdGhlIHByZXNlbmNlIG9mIGFuIEFNRCBsb2FkZXIuXG4gICAgLy8gU2VlIGh0dHA6Ly9yZXF1aXJlanMub3JnL2RvY3MvZXJyb3JzLmh0bWwjbWlzbWF0Y2ggZm9yIG1vcmUgZGV0YWlscy5cbiAgICAvLyBVc2UgYF8ubm9Db25mbGljdGAgdG8gcmVtb3ZlIExvZGFzaCBmcm9tIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG5cbiAgICAvLyBEZWZpbmUgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSBzbywgdGhyb3VnaCBwYXRoIG1hcHBpbmcsIGl0IGNhbiBiZVxuICAgIC8vIHJlZmVyZW5jZWQgYXMgdGhlIFwidW5kZXJzY29yZVwiIG1vZHVsZS5cbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBpdC5cbiAgZWxzZSBpZiAoZnJlZU1vZHVsZSkge1xuICAgIC8vIEV4cG9ydCBmb3IgTm9kZS5qcy5cbiAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBzdXBwb3J0LlxuICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIEV4cG9ydCB0byB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibnVuanVja3NcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wibnVuanVja3NcIl0gPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDExKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA1ZTgwMzEyZjhlZmYyMjAxNGY1YSIsIid1c2Ugc3RyaWN0JztcblxudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG52YXIgZXNjYXBlTWFwID0ge1xuICAnJic6ICcmYW1wOycsXG4gICdcIic6ICcmcXVvdDsnLFxuICAnXFwnJzogJyYjMzk7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnXG59O1xuXG52YXIgZXNjYXBlUmVnZXggPSAvWyZcIic8Pl0vZztcblxudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wKG9iaiwgaykge1xuICByZXR1cm4gT2JqUHJvdG8uaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspO1xufVxuXG5leHBvcnRzLmhhc093blByb3AgPSBoYXNPd25Qcm9wO1xuXG5mdW5jdGlvbiBsb29rdXBFc2NhcGUoY2gpIHtcbiAgcmV0dXJuIGVzY2FwZU1hcFtjaF07XG59XG5cbmZ1bmN0aW9uIF9wcmV0dGlmeUVycm9yKHBhdGgsIHdpdGhJbnRlcm5hbHMsIGVycikge1xuICBpZiAoIWVyci5VcGRhdGUpIHtcbiAgICAvLyBub3Qgb25lIG9mIG91cnMsIGNhc3QgaXRcbiAgICBlcnIgPSBuZXcgZXhwb3J0cy5UZW1wbGF0ZUVycm9yKGVycik7XG4gIH1cbiAgZXJyLlVwZGF0ZShwYXRoKTtcblxuICAvLyBVbmxlc3MgdGhleSBtYXJrZWQgdGhlIGRldiBmbGFnLCBzaG93IHRoZW0gYSB0cmFjZSBmcm9tIGhlcmVcbiAgaWYgKCF3aXRoSW50ZXJuYWxzKSB7XG4gICAgY29uc3Qgb2xkID0gZXJyO1xuICAgIGVyciA9IG5ldyBFcnJvcihvbGQubWVzc2FnZSk7XG4gICAgZXJyLm5hbWUgPSBvbGQubmFtZTtcbiAgfVxuXG4gIHJldHVybiBlcnI7XG59XG5cbmV4cG9ydHMuX3ByZXR0aWZ5RXJyb3IgPSBfcHJldHRpZnlFcnJvcjtcblxuZnVuY3Rpb24gVGVtcGxhdGVFcnJvcihtZXNzYWdlLCBsaW5lbm8sIGNvbG5vKSB7XG4gIHZhciBlcnI7XG4gIHZhciBjYXVzZTtcblxuICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgY2F1c2UgPSBtZXNzYWdlO1xuICAgIG1lc3NhZ2UgPSBgJHtjYXVzZS5uYW1lfTogJHtjYXVzZS5tZXNzYWdlfWA7XG4gIH1cblxuICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihlcnIsIFRlbXBsYXRlRXJyb3IucHJvdG90eXBlKTtcbiAgfSBlbHNlIHtcbiAgICBlcnIgPSB0aGlzO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICdtZXNzYWdlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBtZXNzYWdlLFxuICAgIH0pO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ25hbWUnLCB7XG4gICAgdmFsdWU6ICdUZW1wbGF0ZSByZW5kZXIgZXJyb3InLFxuICB9KTtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9XG5cbiAgbGV0IGdldFN0YWNrO1xuXG4gIGlmIChjYXVzZSkge1xuICAgIGNvbnN0IHN0YWNrRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY2F1c2UsICdzdGFjaycpO1xuICAgIGdldFN0YWNrID0gc3RhY2tEZXNjcmlwdG9yICYmIChzdGFja0Rlc2NyaXB0b3IuZ2V0IHx8ICgoKSA9PiBzdGFja0Rlc2NyaXB0b3IudmFsdWUpKTtcbiAgICBpZiAoIWdldFN0YWNrKSB7XG4gICAgICBnZXRTdGFjayA9ICgpID0+IGNhdXNlLnN0YWNrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdGFjayA9IChuZXcgRXJyb3IobWVzc2FnZSkpLnN0YWNrO1xuICAgIGdldFN0YWNrID0gKCgpID0+IHN0YWNrKTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsICdzdGFjaycsIHtcbiAgICBnZXQ6ICgpID0+IGdldFN0YWNrLmNhbGwoZXJyKSxcbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVyciwgJ2NhdXNlJywge1xuICAgIHZhbHVlOiBjYXVzZVxuICB9KTtcblxuICBlcnIubGluZW5vID0gbGluZW5vO1xuICBlcnIuY29sbm8gPSBjb2xubztcbiAgZXJyLmZpcnN0VXBkYXRlID0gdHJ1ZTtcblxuICBlcnIuVXBkYXRlID0gZnVuY3Rpb24gVXBkYXRlKHBhdGgpIHtcbiAgICBsZXQgbXNnID0gJygnICsgKHBhdGggfHwgJ3Vua25vd24gcGF0aCcpICsgJyknO1xuXG4gICAgLy8gb25seSBzaG93IGxpbmVubyArIGNvbG5vIG5leHQgdG8gcGF0aCBvZiB0ZW1wbGF0ZVxuICAgIC8vIHdoZXJlIGVycm9yIG9jY3VycmVkXG4gICAgaWYgKHRoaXMuZmlyc3RVcGRhdGUpIHtcbiAgICAgIGlmICh0aGlzLmxpbmVubyAmJiB0aGlzLmNvbG5vKSB7XG4gICAgICAgIG1zZyArPSBgIFtMaW5lICR7dGhpcy5saW5lbm99LCBDb2x1bW4gJHt0aGlzLmNvbG5vfV1gO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmxpbmVubykge1xuICAgICAgICBtc2cgKz0gYCBbTGluZSAke3RoaXMubGluZW5vfV1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1zZyArPSAnXFxuICc7XG4gICAgaWYgKHRoaXMuZmlyc3RVcGRhdGUpIHtcbiAgICAgIG1zZyArPSAnICc7XG4gICAgfVxuXG4gICAgdGhpcy5tZXNzYWdlID0gbXNnICsgKHRoaXMubWVzc2FnZSB8fCAnJyk7XG4gICAgdGhpcy5maXJzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBlcnI7XG59XG5cblxuaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoVGVtcGxhdGVFcnJvci5wcm90b3R5cGUsIEVycm9yLnByb3RvdHlwZSk7XG59IGVsc2Uge1xuICBUZW1wbGF0ZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBUZW1wbGF0ZUVycm9yLFxuICAgIH0sXG4gIH0pO1xufVxuXG5leHBvcnRzLlRlbXBsYXRlRXJyb3IgPSBUZW1wbGF0ZUVycm9yO1xuXG5mdW5jdGlvbiBlc2NhcGUodmFsKSB7XG4gIHJldHVybiB2YWwucmVwbGFjZShlc2NhcGVSZWdleCwgbG9va3VwRXNjYXBlKTtcbn1cblxuZXhwb3J0cy5lc2NhcGUgPSBlc2NhcGU7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBPYmpQcm90by50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gIHJldHVybiBPYmpQcm90by50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICByZXR1cm4gT2JqUHJvdG8udG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn1cblxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIE9ialByb3RvLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGF0dHJcbiAqIEByZXR1cm5zIHsoc3RyaW5nfG51bWJlcilbXX1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9wcmVwYXJlQXR0cmlidXRlUGFydHMoYXR0cikge1xuICBpZiAoIWF0dHIpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAodHlwZW9mIGF0dHIgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF0dHIuc3BsaXQoJy4nKTtcbiAgfVxuXG4gIHJldHVybiBbYXR0cl07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9ICAgYXR0cmlidXRlICAgICAgQXR0cmlidXRlIHZhbHVlLiBEb3RzIGFsbG93ZWQuXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oT2JqZWN0KTogKn1cbiAqL1xuZnVuY3Rpb24gZ2V0QXR0ckdldHRlcihhdHRyaWJ1dGUpIHtcbiAgY29uc3QgcGFydHMgPSBfcHJlcGFyZUF0dHJpYnV0ZVBhcnRzKGF0dHJpYnV0ZSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGF0dHJHZXR0ZXIoaXRlbSkge1xuICAgIGxldCBfaXRlbSA9IGl0ZW07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG5cbiAgICAgIC8vIElmIGl0ZW0gaXMgbm90IGFuIG9iamVjdCwgYW5kIHdlIHN0aWxsIGdvdCBwYXJ0cyB0byBoYW5kbGUsIGl0IG1lYW5zXG4gICAgICAvLyB0aGF0IHNvbWV0aGluZyBnb2VzIHdyb25nLiBKdXN0IHJvbGwgb3V0IHRvIHVuZGVmaW5lZCBpbiB0aGF0IGNhc2UuXG4gICAgICBpZiAoaGFzT3duUHJvcChfaXRlbSwgcGFydCkpIHtcbiAgICAgICAgX2l0ZW0gPSBfaXRlbVtwYXJ0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9pdGVtO1xuICB9O1xufVxuXG5mdW5jdGlvbiBncm91cEJ5KG9iaiwgdmFsLCB0aHJvd09uVW5kZWZpbmVkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBpdGVyYXRvciA9IGlzRnVuY3Rpb24odmFsKSA/IHZhbCA6IGdldEF0dHJHZXR0ZXIodmFsKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IG9ialtpXTtcbiAgICBjb25zdCBrZXkgPSBpdGVyYXRvcih2YWx1ZSwgaSk7XG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkICYmIHRocm93T25VbmRlZmluZWQgPT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGdyb3VwYnk6IGF0dHJpYnV0ZSBcIiR7dmFsfVwiIHJlc29sdmVkIHRvIHVuZGVmaW5lZGApO1xuICAgIH1cbiAgICAocmVzdWx0W2tleV0gfHwgKHJlc3VsdFtrZXldID0gW10pKS5wdXNoKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnRzLmdyb3VwQnkgPSBncm91cEJ5O1xuXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwob2JqKTtcbn1cblxuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gd2l0aG91dChhcnJheSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKCFhcnJheSkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICBjb25zdCBjb250YWlucyA9IHRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKTtcbiAgbGV0IGluZGV4ID0gLTE7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaW5kZXhPZihjb250YWlucywgYXJyYXlbaW5kZXhdKSA9PT0gLTEpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydHMud2l0aG91dCA9IHdpdGhvdXQ7XG5cbmZ1bmN0aW9uIHJlcGVhdChjaGFyXywgbikge1xuICB2YXIgc3RyID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgc3RyICs9IGNoYXJfO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbmV4cG9ydHMucmVwZWF0ID0gcmVwZWF0O1xuXG5mdW5jdGlvbiBlYWNoKG9iaiwgZnVuYywgY29udGV4dCkge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXlQcm90by5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBBcnJheVByb3RvLmZvckVhY2gpIHtcbiAgICBvYmouZm9yRWFjaChmdW5jLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZnVuYy5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5lYWNoID0gZWFjaDtcblxuZnVuY3Rpb24gbWFwKG9iaiwgZnVuYykge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIGlmIChBcnJheVByb3RvLm1hcCAmJiBvYmoubWFwID09PSBBcnJheVByb3RvLm1hcCkge1xuICAgIHJldHVybiBvYmoubWFwKGZ1bmMpO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IGZ1bmMob2JqW2ldLCBpKTtcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgIHJlc3VsdHMubGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5leHBvcnRzLm1hcCA9IG1hcDtcblxuZnVuY3Rpb24gYXN5bmNJdGVyKGFyciwgaXRlciwgY2IpIHtcbiAgbGV0IGkgPSAtMTtcblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGkrKztcblxuICAgIGlmIChpIDwgYXJyLmxlbmd0aCkge1xuICAgICAgaXRlcihhcnJbaV0sIGksIG5leHQsIGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59XG5cbmV4cG9ydHMuYXN5bmNJdGVyID0gYXN5bmNJdGVyO1xuXG5mdW5jdGlvbiBhc3luY0ZvcihvYmosIGl0ZXIsIGNiKSB7XG4gIGNvbnN0IGtleXMgPSBrZXlzXyhvYmogfHwge30pO1xuICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgbGV0IGkgPSAtMTtcblxuICBmdW5jdGlvbiBuZXh0KCkge1xuICAgIGkrKztcbiAgICBjb25zdCBrID0ga2V5c1tpXTtcblxuICAgIGlmIChpIDwgbGVuKSB7XG4gICAgICBpdGVyKGssIG9ialtrXSwgaSwgbGVuLCBuZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59XG5cbmV4cG9ydHMuYXN5bmNGb3IgPSBhc3luY0ZvcjtcblxuZnVuY3Rpb24gaW5kZXhPZihhcnIsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhcnIgfHwgW10sIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XG59XG5cbmV4cG9ydHMuaW5kZXhPZiA9IGluZGV4T2Y7XG5cbmZ1bmN0aW9uIGtleXNfKG9iaikge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1yZXN0cmljdGVkLXN5bnRheCAqL1xuICBjb25zdCBhcnIgPSBbXTtcbiAgZm9yIChsZXQgayBpbiBvYmopIHtcbiAgICBpZiAoaGFzT3duUHJvcChvYmosIGspKSB7XG4gICAgICBhcnIucHVzaChrKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0cy5rZXlzID0ga2V5c187XG5cbmZ1bmN0aW9uIF9lbnRyaWVzKG9iaikge1xuICByZXR1cm4ga2V5c18ob2JqKS5tYXAoKGspID0+IFtrLCBvYmpba11dKTtcbn1cblxuZXhwb3J0cy5fZW50cmllcyA9IF9lbnRyaWVzO1xuXG5mdW5jdGlvbiBfdmFsdWVzKG9iaikge1xuICByZXR1cm4ga2V5c18ob2JqKS5tYXAoKGspID0+IG9ialtrXSk7XG59XG5cbmV4cG9ydHMuX3ZhbHVlcyA9IF92YWx1ZXM7XG5cbmZ1bmN0aW9uIGV4dGVuZChvYmoxLCBvYmoyKSB7XG4gIG9iajEgPSBvYmoxIHx8IHt9O1xuICBrZXlzXyhvYmoyKS5mb3JFYWNoKGsgPT4ge1xuICAgIG9iajFba10gPSBvYmoyW2tdO1xuICB9KTtcbiAgcmV0dXJuIG9iajE7XG59XG5cbmV4cG9ydHMuX2Fzc2lnbiA9IGV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kO1xuXG5mdW5jdGlvbiBpbk9wZXJhdG9yKGtleSwgdmFsKSB7XG4gIGlmIChpc0FycmF5KHZhbCkgfHwgaXNTdHJpbmcodmFsKSkge1xuICAgIHJldHVybiB2YWwuaW5kZXhPZihrZXkpICE9PSAtMTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgcmV0dXJuIGtleSBpbiB2YWw7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIFwiaW5cIiBvcGVyYXRvciB0byBzZWFyY2ggZm9yIFwiJ1xuICAgICsga2V5ICsgJ1wiIGluIHVuZXhwZWN0ZWQgdHlwZXMuJyk7XG59XG5cbmV4cG9ydHMuaW5PcGVyYXRvciA9IGluT3BlcmF0b3I7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9udW5qdWNrcy9zcmMvbGliLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBBIHNpbXBsZSBjbGFzcyBzeXN0ZW0sIG1vcmUgZG9jdW1lbnRhdGlvbiB0byBjb21lXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGxpYiA9IHJlcXVpcmUoJy4vbGliJyk7XG5cbmZ1bmN0aW9uIHBhcmVudFdyYXAocGFyZW50LCBwcm9wKSB7XG4gIGlmICh0eXBlb2YgcGFyZW50ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBwcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgLy8gU2F2ZSB0aGUgY3VycmVudCBwYXJlbnQgbWV0aG9kXG4gICAgY29uc3QgdG1wID0gdGhpcy5wYXJlbnQ7XG5cbiAgICAvLyBTZXQgcGFyZW50IHRvIHRoZSBwcmV2aW91cyBtZXRob2QsIGNhbGwsIGFuZCByZXN0b3JlXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgY29uc3QgcmVzID0gcHJvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMucGFyZW50ID0gdG1wO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kQ2xhc3MoY2xzLCBuYW1lLCBwcm9wcykge1xuICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gIGxpYi5rZXlzKHByb3BzKS5mb3JFYWNoKGsgPT4ge1xuICAgIHByb3BzW2tdID0gcGFyZW50V3JhcChjbHMucHJvdG90eXBlW2tdLCBwcm9wc1trXSk7XG4gIH0pO1xuXG4gIGNsYXNzIHN1YmNsYXNzIGV4dGVuZHMgY2xzIHtcbiAgICBnZXQgdHlwZW5hbWUoKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gIH1cblxuICBsaWIuX2Fzc2lnbihzdWJjbGFzcy5wcm90b3R5cGUsIHByb3BzKTtcblxuICByZXR1cm4gc3ViY2xhc3M7XG59XG5cbmNsYXNzIE9iaiB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAvLyBVbmZvcnR1bmF0ZWx5IG5lY2Vzc2FyeSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICB0aGlzLmluaXQoLi4uYXJncyk7XG4gIH1cblxuICBpbml0KCkge31cblxuICBnZXQgdHlwZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIHN0YXRpYyBleHRlbmQobmFtZSwgcHJvcHMpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICBwcm9wcyA9IG5hbWU7XG4gICAgICBuYW1lID0gJ2Fub255bW91cyc7XG4gICAgfVxuICAgIHJldHVybiBleHRlbmRDbGFzcyh0aGlzLCBuYW1lLCBwcm9wcyk7XG4gIH1cbn1cblxuY2xhc3MgRW1pdHRlck9iaiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIC8vIFVuZm9ydHVuYXRlbHkgbmVjZXNzYXJ5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIHRoaXMuaW5pdCguLi5hcmdzKTtcbiAgfVxuXG4gIGluaXQoKSB7fVxuXG4gIGdldCB0eXBlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgc3RhdGljIGV4dGVuZChuYW1lLCBwcm9wcykge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHByb3BzID0gbmFtZTtcbiAgICAgIG5hbWUgPSAnYW5vbnltb3VzJztcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZENsYXNzKHRoaXMsIG5hbWUsIHByb3BzKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgT2JqLCBFbWl0dGVyT2JqIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9udW5qdWNrcy9zcmMvb2JqZWN0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbGliID0gcmVxdWlyZSgnLi9saWInKTtcbnZhciBhcnJheUZyb20gPSBBcnJheS5mcm9tO1xudmFyIHN1cHBvcnRzSXRlcmF0b3JzID0gKFxuICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvciAmJiB0eXBlb2YgYXJyYXlGcm9tID09PSAnZnVuY3Rpb24nXG4pO1xuXG5cbi8vIEZyYW1lcyBrZWVwIHRyYWNrIG9mIHNjb3BpbmcgYm90aCBhdCBjb21waWxlLXRpbWUgYW5kIHJ1bi10aW1lIHNvXG4vLyB3ZSBrbm93IGhvdyB0byBhY2Nlc3MgdmFyaWFibGVzLiBCbG9jayB0YWdzIGNhbiBpbnRyb2R1Y2Ugc3BlY2lhbFxuLy8gdmFyaWFibGVzLCBmb3IgZXhhbXBsZS5cbmNsYXNzIEZyYW1lIHtcbiAgY29uc3RydWN0b3IocGFyZW50LCBpc29sYXRlV3JpdGVzKSB7XG4gICAgdGhpcy52YXJpYWJsZXMgPSB7fTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnRvcExldmVsID0gZmFsc2U7XG4gICAgLy8gaWYgdGhpcyBpcyB0cnVlLCB3cml0ZXMgKHNldCkgc2hvdWxkIG5ldmVyIHByb3BhZ2F0ZSB1cHdhcmRzIHBhc3RcbiAgICAvLyB0aGlzIGZyYW1lIHRvIGl0cyBwYXJlbnQgKHRob3VnaCByZWFkcyBtYXkpLlxuICAgIHRoaXMuaXNvbGF0ZVdyaXRlcyA9IGlzb2xhdGVXcml0ZXM7XG4gIH1cblxuICBzZXQobmFtZSwgdmFsLCByZXNvbHZlVXApIHtcbiAgICAvLyBBbGxvdyB2YXJpYWJsZXMgd2l0aCBkb3RzIGJ5IGF1dG9tYXRpY2FsbHkgY3JlYXRpbmcgdGhlXG4gICAgLy8gbmVzdGVkIHN0cnVjdHVyZVxuICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICB2YXIgb2JqID0gdGhpcy52YXJpYWJsZXM7XG4gICAgdmFyIGZyYW1lID0gdGhpcztcblxuICAgIGlmIChyZXNvbHZlVXApIHtcbiAgICAgIGlmICgoZnJhbWUgPSB0aGlzLnJlc29sdmUocGFydHNbMF0sIHRydWUpKSkge1xuICAgICAgICBmcmFtZS5zZXQobmFtZSwgdmFsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICBjb25zdCBpZCA9IHBhcnRzW2ldO1xuXG4gICAgICBpZiAoIW9ialtpZF0pIHtcbiAgICAgICAgb2JqW2lkXSA9IHt9O1xuICAgICAgfVxuICAgICAgb2JqID0gb2JqW2lkXTtcbiAgICB9XG5cbiAgICBvYmpbcGFydHNbcGFydHMubGVuZ3RoIC0gMV1dID0gdmFsO1xuICB9XG5cbiAgZ2V0KG5hbWUpIHtcbiAgICB2YXIgdmFsID0gdGhpcy52YXJpYWJsZXNbbmFtZV07XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxvb2t1cChuYW1lKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhcmVudDtcbiAgICB2YXIgdmFsID0gdGhpcy52YXJpYWJsZXNbbmFtZV07XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gcCAmJiBwLmxvb2t1cChuYW1lKTtcbiAgfVxuXG4gIHJlc29sdmUobmFtZSwgZm9yV3JpdGUpIHtcbiAgICB2YXIgcCA9IChmb3JXcml0ZSAmJiB0aGlzLmlzb2xhdGVXcml0ZXMpID8gdW5kZWZpbmVkIDogdGhpcy5wYXJlbnQ7XG4gICAgdmFyIHZhbCA9IHRoaXMudmFyaWFibGVzW25hbWVdO1xuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBwICYmIHAucmVzb2x2ZShuYW1lKTtcbiAgfVxuXG4gIHB1c2goaXNvbGF0ZVdyaXRlcykge1xuICAgIHJldHVybiBuZXcgRnJhbWUodGhpcywgaXNvbGF0ZVdyaXRlcyk7XG4gIH1cblxuICBwb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VNYWNybyhhcmdOYW1lcywga3dhcmdOYW1lcywgZnVuYykge1xuICByZXR1cm4gKC4uLm1hY3JvQXJncykgPT4ge1xuICAgIHZhciBhcmdDb3VudCA9IG51bUFyZ3MobWFjcm9BcmdzKTtcbiAgICB2YXIgYXJncztcbiAgICB2YXIga3dhcmdzID0gZ2V0S2V5d29yZEFyZ3MobWFjcm9BcmdzKTtcblxuICAgIGlmIChhcmdDb3VudCA+IGFyZ05hbWVzLmxlbmd0aCkge1xuICAgICAgYXJncyA9IG1hY3JvQXJncy5zbGljZSgwLCBhcmdOYW1lcy5sZW5ndGgpO1xuXG4gICAgICAvLyBQb3NpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgaW4gYXNcbiAgICAgIC8vIGtleXdvcmQgYXJndW1lbnRzIChlc3NlbnRpYWxseSBkZWZhdWx0IHZhbHVlcylcbiAgICAgIG1hY3JvQXJncy5zbGljZShhcmdzLmxlbmd0aCwgYXJnQ291bnQpLmZvckVhY2goKHZhbCwgaSkgPT4ge1xuICAgICAgICBpZiAoaSA8IGt3YXJnTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAga3dhcmdzW2t3YXJnTmFtZXNbaV1dID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGFyZ3MucHVzaChrd2FyZ3MpO1xuICAgIH0gZWxzZSBpZiAoYXJnQ291bnQgPCBhcmdOYW1lcy5sZW5ndGgpIHtcbiAgICAgIGFyZ3MgPSBtYWNyb0FyZ3Muc2xpY2UoMCwgYXJnQ291bnQpO1xuXG4gICAgICBmb3IgKGxldCBpID0gYXJnQ291bnQ7IGkgPCBhcmdOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcmcgPSBhcmdOYW1lc1tpXTtcblxuICAgICAgICAvLyBLZXl3b3JkIGFyZ3VtZW50cyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgYXNcbiAgICAgICAgLy8gcG9zaXRpb25hbCBhcmd1bWVudHMsIGkuZS4gdGhlIGNhbGxlciBleHBsaWNpdGx5XG4gICAgICAgIC8vIHVzZWQgdGhlIG5hbWUgb2YgYSBwb3NpdGlvbmFsIGFyZ1xuICAgICAgICBhcmdzLnB1c2goa3dhcmdzW2FyZ10pO1xuICAgICAgICBkZWxldGUga3dhcmdzW2FyZ107XG4gICAgICB9XG4gICAgICBhcmdzLnB1c2goa3dhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJncyA9IG1hY3JvQXJncztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZUtleXdvcmRBcmdzKG9iaikge1xuICBvYmouX19rZXl3b3JkcyA9IHRydWU7XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGlzS2V5d29yZEFyZ3Mob2JqKSB7XG4gIHJldHVybiBvYmogJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ19fa2V5d29yZHMnKTtcbn1cblxuZnVuY3Rpb24gZ2V0S2V5d29yZEFyZ3MoYXJncykge1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIGlmIChsZW4pIHtcbiAgICBjb25zdCBsYXN0QXJnID0gYXJnc1tsZW4gLSAxXTtcbiAgICBpZiAoaXNLZXl3b3JkQXJncyhsYXN0QXJnKSkge1xuICAgICAgcmV0dXJuIGxhc3RBcmc7XG4gICAgfVxuICB9XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gbnVtQXJncyhhcmdzKSB7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgaWYgKGxlbiA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgY29uc3QgbGFzdEFyZyA9IGFyZ3NbbGVuIC0gMV07XG4gIGlmIChpc0tleXdvcmRBcmdzKGxhc3RBcmcpKSB7XG4gICAgcmV0dXJuIGxlbiAtIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxlbjtcbiAgfVxufVxuXG4vLyBBIFNhZmVTdHJpbmcgb2JqZWN0IGluZGljYXRlcyB0aGF0IHRoZSBzdHJpbmcgc2hvdWxkIG5vdCBiZVxuLy8gYXV0b2VzY2FwZWQuIFRoaXMgaGFwcGVucyBtYWdpY2FsbHkgYmVjYXVzZSBhdXRvZXNjYXBpbmcgb25seVxuLy8gb2NjdXJzIG9uIHByaW1pdGl2ZSBzdHJpbmcgb2JqZWN0cy5cbmZ1bmN0aW9uIFNhZmVTdHJpbmcodmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICB0aGlzLnZhbCA9IHZhbDtcbiAgdGhpcy5sZW5ndGggPSB2YWwubGVuZ3RoO1xufVxuXG5TYWZlU3RyaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RyaW5nLnByb3RvdHlwZSwge1xuICBsZW5ndGg6IHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IDBcbiAgfVxufSk7XG5TYWZlU3RyaW5nLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgcmV0dXJuIHRoaXMudmFsO1xufTtcblNhZmVTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0aGlzLnZhbDtcbn07XG5cbmZ1bmN0aW9uIGNvcHlTYWZlbmVzcyhkZXN0LCB0YXJnZXQpIHtcbiAgaWYgKGRlc3QgaW5zdGFuY2VvZiBTYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBTYWZlU3RyaW5nKHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldC50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBtYXJrU2FmZSh2YWwpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuXG4gIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBuZXcgU2FmZVN0cmluZyh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiB3cmFwU2FmZShhcmdzKSB7XG4gICAgICB2YXIgcmV0ID0gdmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICh0eXBlb2YgcmV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IFNhZmVTdHJpbmcocmV0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHByZXNzVmFsdWUodmFsLCBhdXRvZXNjYXBlKSB7XG4gIHZhbCA9ICh2YWwgIT09IHVuZGVmaW5lZCAmJiB2YWwgIT09IG51bGwpID8gdmFsIDogJyc7XG5cbiAgaWYgKGF1dG9lc2NhcGUgJiYgISh2YWwgaW5zdGFuY2VvZiBTYWZlU3RyaW5nKSkge1xuICAgIHZhbCA9IGxpYi5lc2NhcGUodmFsLnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gZW5zdXJlRGVmaW5lZCh2YWwsIGxpbmVubywgY29sbm8pIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBsaWIuVGVtcGxhdGVFcnJvcihcbiAgICAgICdhdHRlbXB0ZWQgdG8gb3V0cHV0IG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlJyxcbiAgICAgIGxpbmVubyArIDEsXG4gICAgICBjb2xubyArIDFcbiAgICApO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIG1lbWJlckxvb2t1cChvYmosIHZhbCkge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqW3ZhbF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IG9ialt2YWxdLmFwcGx5KG9iaiwgYXJncyk7XG4gIH1cblxuICByZXR1cm4gb2JqW3ZhbF07XG59XG5cbmZ1bmN0aW9uIGNhbGxXcmFwKG9iaiwgbmFtZSwgY29udGV4dCwgYXJncykge1xuICBpZiAoIW9iaikge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNhbGwgYCcgKyBuYW1lICsgJ2AsIHdoaWNoIGlzIHVuZGVmaW5lZCBvciBmYWxzZXknKTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY2FsbCBgJyArIG5hbWUgKyAnYCwgd2hpY2ggaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHJldHVybiBvYmouYXBwbHkoY29udGV4dCwgYXJncyk7XG59XG5cbmZ1bmN0aW9uIGNvbnRleHRPckZyYW1lTG9va3VwKGNvbnRleHQsIGZyYW1lLCBuYW1lKSB7XG4gIHZhciB2YWwgPSBmcmFtZS5sb29rdXAobmFtZSk7XG4gIHJldHVybiAodmFsICE9PSB1bmRlZmluZWQpID9cbiAgICB2YWwgOlxuICAgIGNvbnRleHQubG9va3VwKG5hbWUpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvciwgbGluZW5vLCBjb2xubykge1xuICBpZiAoZXJyb3IubGluZW5vKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgbGliLlRlbXBsYXRlRXJyb3IoZXJyb3IsIGxpbmVubywgY29sbm8pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzeW5jRWFjaChhcnIsIGRpbWVuLCBpdGVyLCBjYikge1xuICBpZiAobGliLmlzQXJyYXkoYXJyKSkge1xuICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgICBsaWIuYXN5bmNJdGVyKGFyciwgZnVuY3Rpb24gaXRlckNhbGxiYWNrKGl0ZW0sIGksIG5leHQpIHtcbiAgICAgIHN3aXRjaCAoZGltZW4pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGl0ZXIoaXRlbSwgaSwgbGVuLCBuZXh0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGl0ZXIoaXRlbVswXSwgaXRlbVsxXSwgaSwgbGVuLCBuZXh0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGl0ZXIoaXRlbVswXSwgaXRlbVsxXSwgaXRlbVsyXSwgaSwgbGVuLCBuZXh0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpdGVtLnB1c2goaSwgbGVuLCBuZXh0KTtcbiAgICAgICAgICBpdGVyLmFwcGx5KHRoaXMsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0sIGNiKTtcbiAgfSBlbHNlIHtcbiAgICBsaWIuYXN5bmNGb3IoYXJyLCBmdW5jdGlvbiBpdGVyQ2FsbGJhY2soa2V5LCB2YWwsIGksIGxlbiwgbmV4dCkge1xuICAgICAgaXRlcihrZXksIHZhbCwgaSwgbGVuLCBuZXh0KTtcbiAgICB9LCBjYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXN5bmNBbGwoYXJyLCBkaW1lbiwgZnVuYywgY2IpIHtcbiAgdmFyIGZpbmlzaGVkID0gMDtcbiAgdmFyIGxlbjtcbiAgdmFyIG91dHB1dEFycjtcblxuICBmdW5jdGlvbiBkb25lKGksIG91dHB1dCkge1xuICAgIGZpbmlzaGVkKys7XG4gICAgb3V0cHV0QXJyW2ldID0gb3V0cHV0O1xuXG4gICAgaWYgKGZpbmlzaGVkID09PSBsZW4pIHtcbiAgICAgIGNiKG51bGwsIG91dHB1dEFyci5qb2luKCcnKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxpYi5pc0FycmF5KGFycikpIHtcbiAgICBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIG91dHB1dEFyciA9IG5ldyBBcnJheShsZW4pO1xuXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgY2IobnVsbCwgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXJyW2ldO1xuXG4gICAgICAgIHN3aXRjaCAoZGltZW4pIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBmdW5jKGl0ZW0sIGksIGxlbiwgZG9uZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBmdW5jKGl0ZW1bMF0sIGl0ZW1bMV0sIGksIGxlbiwgZG9uZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBmdW5jKGl0ZW1bMF0sIGl0ZW1bMV0sIGl0ZW1bMl0sIGksIGxlbiwgZG9uZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaXRlbS5wdXNoKGksIGxlbiwgZG9uZSk7XG4gICAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGtleXMgPSBsaWIua2V5cyhhcnIgfHwge30pO1xuICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIG91dHB1dEFyciA9IG5ldyBBcnJheShsZW4pO1xuXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgY2IobnVsbCwgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgayA9IGtleXNbaV07XG4gICAgICAgIGZ1bmMoaywgYXJyW2tdLCBpLCBsZW4sIGRvbmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmcm9tSXRlcmF0b3IoYXJyKSB7XG4gIGlmICh0eXBlb2YgYXJyICE9PSAnb2JqZWN0JyB8fCBhcnIgPT09IG51bGwgfHwgbGliLmlzQXJyYXkoYXJyKSkge1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSBpZiAoc3VwcG9ydHNJdGVyYXRvcnMgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGFycikge1xuICAgIHJldHVybiBhcnJheUZyb20oYXJyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBGcmFtZTogRnJhbWUsXG4gIG1ha2VNYWNybzogbWFrZU1hY3JvLFxuICBtYWtlS2V5d29yZEFyZ3M6IG1ha2VLZXl3b3JkQXJncyxcbiAgbnVtQXJnczogbnVtQXJncyxcbiAgc3VwcHJlc3NWYWx1ZTogc3VwcHJlc3NWYWx1ZSxcbiAgZW5zdXJlRGVmaW5lZDogZW5zdXJlRGVmaW5lZCxcbiAgbWVtYmVyTG9va3VwOiBtZW1iZXJMb29rdXAsXG4gIGNvbnRleHRPckZyYW1lTG9va3VwOiBjb250ZXh0T3JGcmFtZUxvb2t1cCxcbiAgY2FsbFdyYXA6IGNhbGxXcmFwLFxuICBoYW5kbGVFcnJvcjogaGFuZGxlRXJyb3IsXG4gIGlzQXJyYXk6IGxpYi5pc0FycmF5LFxuICBrZXlzOiBsaWIua2V5cyxcbiAgU2FmZVN0cmluZzogU2FmZVN0cmluZyxcbiAgY29weVNhZmVuZXNzOiBjb3B5U2FmZW5lc3MsXG4gIG1hcmtTYWZlOiBtYXJrU2FmZSxcbiAgYXN5bmNFYWNoOiBhc3luY0VhY2gsXG4gIGFzeW5jQWxsOiBhc3luY0FsbCxcbiAgaW5PcGVyYXRvcjogbGliLmluT3BlcmF0b3IsXG4gIGZyb21JdGVyYXRvcjogZnJvbUl0ZXJhdG9yXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbnVuanVja3Mvc3JjL3J1bnRpbWUuanMiLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtPYmp9ID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcblxuZnVuY3Rpb24gdHJhdmVyc2VBbmRDaGVjayhvYmosIHR5cGUsIHJlc3VsdHMpIHtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICByZXN1bHRzLnB1c2gob2JqKTtcbiAgfVxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgb2JqLmZpbmRBbGwodHlwZSwgcmVzdWx0cyk7XG4gIH1cbn1cblxuY2xhc3MgTm9kZSBleHRlbmRzIE9iaiB7XG4gIGluaXQobGluZW5vLCBjb2xubywgLi4uYXJncykge1xuICAgIHRoaXMubGluZW5vID0gbGluZW5vO1xuICAgIHRoaXMuY29sbm8gPSBjb2xubztcblxuICAgIHRoaXMuZmllbGRzLmZvckVhY2goKGZpZWxkLCBpKSA9PiB7XG4gICAgICAvLyBUaGUgZmlyc3QgdHdvIGFyZ3MgYXJlIGxpbmUvY29sIG51bWJlcnMsIHNvIG9mZnNldCBieSAyXG4gICAgICB2YXIgdmFsID0gYXJndW1lbnRzW2kgKyAyXTtcblxuICAgICAgLy8gRmllbGRzIHNob3VsZCBuZXZlciBiZSB1bmRlZmluZWQsIGJ1dCBudWxsLiBJdCBtYWtlc1xuICAgICAgLy8gdGVzdGluZyBlYXNpZXIgdG8gbm9ybWFsaXplIHZhbHVlcy5cbiAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWwgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzW2ZpZWxkXSA9IHZhbDtcbiAgICB9KTtcbiAgfVxuXG4gIGZpbmRBbGwodHlwZSwgcmVzdWx0cykge1xuICAgIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBOb2RlTGlzdCkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHRyYXZlcnNlQW5kQ2hlY2soY2hpbGQsIHR5cGUsIHJlc3VsdHMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maWVsZHMuZm9yRWFjaChmaWVsZCA9PiB0cmF2ZXJzZUFuZENoZWNrKHRoaXNbZmllbGRdLCB0eXBlLCByZXN1bHRzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBpdGVyRmllbGRzKGZ1bmMpIHtcbiAgICB0aGlzLmZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgZnVuYyh0aGlzW2ZpZWxkXSwgZmllbGQpO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIEFic3RyYWN0IG5vZGVzXG5jbGFzcyBWYWx1ZSBleHRlbmRzIE5vZGUge1xuICBnZXQgdHlwZW5hbWUoKSB7IHJldHVybiAnVmFsdWUnOyB9XG4gIGdldCBmaWVsZHMoKSB7XG4gICAgcmV0dXJuIFsndmFsdWUnXTtcbiAgfVxufVxuXG4vLyBDb25jcmV0ZSBub2Rlc1xuY2xhc3MgTm9kZUxpc3QgZXh0ZW5kcyBOb2RlIHtcbiAgZ2V0IHR5cGVuYW1lKCkgeyByZXR1cm4gJ05vZGVMaXN0JzsgfVxuICBnZXQgZmllbGRzKCkgeyByZXR1cm4gWydjaGlsZHJlbiddOyB9XG5cbiAgaW5pdChsaW5lbm8sIGNvbG5vLCBub2Rlcykge1xuICAgIHN1cGVyLmluaXQobGluZW5vLCBjb2xubywgbm9kZXMgfHwgW10pO1xuICB9XG5cbiAgYWRkQ2hpbGQobm9kZSkge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgfVxufVxuXG5jb25zdCBSb290ID0gTm9kZUxpc3QuZXh0ZW5kKCdSb290Jyk7XG5jb25zdCBMaXRlcmFsID0gVmFsdWUuZXh0ZW5kKCdMaXRlcmFsJyk7XG5jb25zdCBTeW1ib2wgPSBWYWx1ZS5leHRlbmQoJ1N5bWJvbCcpO1xuY29uc3QgR3JvdXAgPSBOb2RlTGlzdC5leHRlbmQoJ0dyb3VwJyk7XG5jb25zdCBBcnJheU5vZGUgPSBOb2RlTGlzdC5leHRlbmQoJ0FycmF5Jyk7XG5jb25zdCBQYWlyID0gTm9kZS5leHRlbmQoJ1BhaXInLCB7IGZpZWxkczogWydrZXknLCAndmFsdWUnXSB9KTtcbmNvbnN0IERpY3QgPSBOb2RlTGlzdC5leHRlbmQoJ0RpY3QnKTtcbmNvbnN0IExvb2t1cFZhbCA9IE5vZGUuZXh0ZW5kKCdMb29rdXBWYWwnLCB7IGZpZWxkczogWyd0YXJnZXQnLCAndmFsJ10gfSk7XG5jb25zdCBJZiA9IE5vZGUuZXh0ZW5kKCdJZicsIHsgZmllbGRzOiBbJ2NvbmQnLCAnYm9keScsICdlbHNlXyddIH0pO1xuY29uc3QgSWZBc3luYyA9IElmLmV4dGVuZCgnSWZBc3luYycpO1xuY29uc3QgSW5saW5lSWYgPSBOb2RlLmV4dGVuZCgnSW5saW5lSWYnLCB7IGZpZWxkczogWydjb25kJywgJ2JvZHknLCAnZWxzZV8nXSB9KTtcbmNvbnN0IEZvciA9IE5vZGUuZXh0ZW5kKCdGb3InLCB7IGZpZWxkczogWydhcnInLCAnbmFtZScsICdib2R5JywgJ2Vsc2VfJ10gfSk7XG5jb25zdCBBc3luY0VhY2ggPSBGb3IuZXh0ZW5kKCdBc3luY0VhY2gnKTtcbmNvbnN0IEFzeW5jQWxsID0gRm9yLmV4dGVuZCgnQXN5bmNBbGwnKTtcbmNvbnN0IE1hY3JvID0gTm9kZS5leHRlbmQoJ01hY3JvJywgeyBmaWVsZHM6IFsnbmFtZScsICdhcmdzJywgJ2JvZHknXSB9KTtcbmNvbnN0IENhbGxlciA9IE1hY3JvLmV4dGVuZCgnQ2FsbGVyJyk7XG5jb25zdCBJbXBvcnQgPSBOb2RlLmV4dGVuZCgnSW1wb3J0JywgeyBmaWVsZHM6IFsndGVtcGxhdGUnLCAndGFyZ2V0JywgJ3dpdGhDb250ZXh0J10gfSk7XG5cbmNsYXNzIEZyb21JbXBvcnQgZXh0ZW5kcyBOb2RlIHtcbiAgZ2V0IHR5cGVuYW1lKCkgeyByZXR1cm4gJ0Zyb21JbXBvcnQnOyB9XG4gIGdldCBmaWVsZHMoKSB7IHJldHVybiBbJ3RlbXBsYXRlJywgJ25hbWVzJywgJ3dpdGhDb250ZXh0J107IH1cblxuICBpbml0KGxpbmVubywgY29sbm8sIHRlbXBsYXRlLCBuYW1lcywgd2l0aENvbnRleHQpIHtcbiAgICBzdXBlci5pbml0KGxpbmVubywgY29sbm8sIHRlbXBsYXRlLCBuYW1lcyB8fCBuZXcgTm9kZUxpc3QoKSwgd2l0aENvbnRleHQpO1xuICB9XG59XG5cbmNvbnN0IEZ1bkNhbGwgPSBOb2RlLmV4dGVuZCgnRnVuQ2FsbCcsIHsgZmllbGRzOiBbJ25hbWUnLCAnYXJncyddIH0pO1xuY29uc3QgRmlsdGVyID0gRnVuQ2FsbC5leHRlbmQoJ0ZpbHRlcicpO1xuY29uc3QgRmlsdGVyQXN5bmMgPSBGaWx0ZXIuZXh0ZW5kKCdGaWx0ZXJBc3luYycsIHsgZmllbGRzOiBbJ25hbWUnLCAnYXJncycsICdzeW1ib2wnXSB9KTtcbmNvbnN0IEtleXdvcmRBcmdzID0gRGljdC5leHRlbmQoJ0tleXdvcmRBcmdzJyk7XG5jb25zdCBCbG9jayA9IE5vZGUuZXh0ZW5kKCdCbG9jaycsIHsgZmllbGRzOiBbJ25hbWUnLCAnYm9keSddIH0pO1xuY29uc3QgU3VwZXIgPSBOb2RlLmV4dGVuZCgnU3VwZXInLCB7IGZpZWxkczogWydibG9ja05hbWUnLCAnc3ltYm9sJ10gfSk7XG5jb25zdCBUZW1wbGF0ZVJlZiA9IE5vZGUuZXh0ZW5kKCdUZW1wbGF0ZVJlZicsIHsgZmllbGRzOiBbJ3RlbXBsYXRlJ10gfSk7XG5jb25zdCBFeHRlbmRzID0gVGVtcGxhdGVSZWYuZXh0ZW5kKCdFeHRlbmRzJyk7XG5jb25zdCBJbmNsdWRlID0gTm9kZS5leHRlbmQoJ0luY2x1ZGUnLCB7IGZpZWxkczogWyd0ZW1wbGF0ZScsICdpZ25vcmVNaXNzaW5nJ10gfSk7XG5jb25zdCBTZXQgPSBOb2RlLmV4dGVuZCgnU2V0JywgeyBmaWVsZHM6IFsndGFyZ2V0cycsICd2YWx1ZSddIH0pO1xuY29uc3QgU3dpdGNoID0gTm9kZS5leHRlbmQoJ1N3aXRjaCcsIHsgZmllbGRzOiBbJ2V4cHInLCAnY2FzZXMnLCAnZGVmYXVsdCddIH0pO1xuY29uc3QgQ2FzZSA9IE5vZGUuZXh0ZW5kKCdDYXNlJywgeyBmaWVsZHM6IFsnY29uZCcsICdib2R5J10gfSk7XG5jb25zdCBPdXRwdXQgPSBOb2RlTGlzdC5leHRlbmQoJ091dHB1dCcpO1xuY29uc3QgQ2FwdHVyZSA9IE5vZGUuZXh0ZW5kKCdDYXB0dXJlJywgeyBmaWVsZHM6IFsnYm9keSddIH0pO1xuY29uc3QgVGVtcGxhdGVEYXRhID0gTGl0ZXJhbC5leHRlbmQoJ1RlbXBsYXRlRGF0YScpO1xuY29uc3QgVW5hcnlPcCA9IE5vZGUuZXh0ZW5kKCdVbmFyeU9wJywgeyBmaWVsZHM6IFsndGFyZ2V0J10gfSk7XG5jb25zdCBCaW5PcCA9IE5vZGUuZXh0ZW5kKCdCaW5PcCcsIHsgZmllbGRzOiBbJ2xlZnQnLCAncmlnaHQnXSB9KTtcbmNvbnN0IEluID0gQmluT3AuZXh0ZW5kKCdJbicpO1xuY29uc3QgSXMgPSBCaW5PcC5leHRlbmQoJ0lzJyk7XG5jb25zdCBPciA9IEJpbk9wLmV4dGVuZCgnT3InKTtcbmNvbnN0IEFuZCA9IEJpbk9wLmV4dGVuZCgnQW5kJyk7XG5jb25zdCBOb3QgPSBVbmFyeU9wLmV4dGVuZCgnTm90Jyk7XG5jb25zdCBBZGQgPSBCaW5PcC5leHRlbmQoJ0FkZCcpO1xuY29uc3QgQ29uY2F0ID0gQmluT3AuZXh0ZW5kKCdDb25jYXQnKTtcbmNvbnN0IFN1YiA9IEJpbk9wLmV4dGVuZCgnU3ViJyk7XG5jb25zdCBNdWwgPSBCaW5PcC5leHRlbmQoJ011bCcpO1xuY29uc3QgRGl2ID0gQmluT3AuZXh0ZW5kKCdEaXYnKTtcbmNvbnN0IEZsb29yRGl2ID0gQmluT3AuZXh0ZW5kKCdGbG9vckRpdicpO1xuY29uc3QgTW9kID0gQmluT3AuZXh0ZW5kKCdNb2QnKTtcbmNvbnN0IFBvdyA9IEJpbk9wLmV4dGVuZCgnUG93Jyk7XG5jb25zdCBOZWcgPSBVbmFyeU9wLmV4dGVuZCgnTmVnJyk7XG5jb25zdCBQb3MgPSBVbmFyeU9wLmV4dGVuZCgnUG9zJyk7XG5jb25zdCBDb21wYXJlID0gTm9kZS5leHRlbmQoJ0NvbXBhcmUnLCB7IGZpZWxkczogWydleHByJywgJ29wcyddIH0pO1xuY29uc3QgQ29tcGFyZU9wZXJhbmQgPSBOb2RlLmV4dGVuZCgnQ29tcGFyZU9wZXJhbmQnLCB7IGZpZWxkczogWydleHByJywgJ3R5cGUnXSB9KTtcbmNvbnN0IENhbGxFeHRlbnNpb24gPSBOb2RlLmV4dGVuZCgnQ2FsbEV4dGVuc2lvbicsIHtcbiAgaW5pdChleHQsIHByb3AsIGFyZ3MsIGNvbnRlbnRBcmdzKSB7XG4gICAgdGhpcy5wYXJlbnQoKTtcbiAgICB0aGlzLmV4dE5hbWUgPSBleHQuX19uYW1lIHx8IGV4dDtcbiAgICB0aGlzLnByb3AgPSBwcm9wO1xuICAgIHRoaXMuYXJncyA9IGFyZ3MgfHwgbmV3IE5vZGVMaXN0KCk7XG4gICAgdGhpcy5jb250ZW50QXJncyA9IGNvbnRlbnRBcmdzIHx8IFtdO1xuICAgIHRoaXMuYXV0b2VzY2FwZSA9IGV4dC5hdXRvZXNjYXBlO1xuICB9LFxuICBmaWVsZHM6IFsnZXh0TmFtZScsICdwcm9wJywgJ2FyZ3MnLCAnY29udGVudEFyZ3MnXVxufSk7XG5jb25zdCBDYWxsRXh0ZW5zaW9uQXN5bmMgPSBDYWxsRXh0ZW5zaW9uLmV4dGVuZCgnQ2FsbEV4dGVuc2lvbkFzeW5jJyk7XG5cbi8vIFRoaXMgaXMgaGFja3ksIGJ1dCB0aGlzIGlzIGp1c3QgYSBkZWJ1Z2dpbmcgZnVuY3Rpb24gYW55d2F5XG5mdW5jdGlvbiBwcmludChzdHIsIGluZGVudCwgaW5saW5lKSB7XG4gIHZhciBsaW5lcyA9IHN0ci5zcGxpdCgnXFxuJyk7XG5cbiAgbGluZXMuZm9yRWFjaCgobGluZSwgaSkgPT4ge1xuICAgIGlmIChsaW5lICYmICgoaW5saW5lICYmIGkgPiAwKSB8fCAhaW5saW5lKSkge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoKCcgJykucmVwZWF0KGluZGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBubCA9IChpID09PSBsaW5lcy5sZW5ndGggLSAxKSA/ICcnIDogJ1xcbic7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7bGluZX0ke25sfWApO1xuICB9KTtcbn1cblxuLy8gUHJpbnQgdGhlIEFTVCBpbiBhIG5pY2VseSBmb3JtYXR0ZWQgdHJlZSBmb3JtYXQgZm9yIGRlYnVnZ2luXG5mdW5jdGlvbiBwcmludE5vZGVzKG5vZGUsIGluZGVudCkge1xuICBpbmRlbnQgPSBpbmRlbnQgfHwgMDtcblxuICBwcmludChub2RlLnR5cGVuYW1lICsgJzogJywgaW5kZW50KTtcblxuICBpZiAobm9kZSBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7XG4gICAgcHJpbnQoJ1xcbicpO1xuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCgobikgPT4ge1xuICAgICAgcHJpbnROb2RlcyhuLCBpbmRlbnQgKyAyKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQ2FsbEV4dGVuc2lvbikge1xuICAgIHByaW50KGAke25vZGUuZXh0TmFtZX0uJHtub2RlLnByb3B9XFxuYCk7XG5cbiAgICBpZiAobm9kZS5hcmdzKSB7XG4gICAgICBwcmludE5vZGVzKG5vZGUuYXJncywgaW5kZW50ICsgMik7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuY29udGVudEFyZ3MpIHtcbiAgICAgIG5vZGUuY29udGVudEFyZ3MuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBwcmludE5vZGVzKG4sIGluZGVudCArIDIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBub2RlcyA9IFtdO1xuICAgIGxldCBwcm9wcyA9IG51bGw7XG5cbiAgICBub2RlLml0ZXJGaWVsZHMoKHZhbCwgZmllbGROYW1lKSA9PiB7XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICBub2Rlcy5wdXNoKFtmaWVsZE5hbWUsIHZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICAgICAgcHJvcHNbZmllbGROYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwcm9wcykge1xuICAgICAgcHJpbnQoSlNPTi5zdHJpbmdpZnkocHJvcHMsIG51bGwsIDIpICsgJ1xcbicsIG51bGwsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmludCgnXFxuJyk7XG4gICAgfVxuXG4gICAgbm9kZXMuZm9yRWFjaCgoW2ZpZWxkTmFtZSwgbl0pID0+IHtcbiAgICAgIHByaW50KGBbJHtmaWVsZE5hbWV9XSA9PmAsIGluZGVudCArIDIpO1xuICAgICAgcHJpbnROb2RlcyhuLCBpbmRlbnQgKyA0KTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTm9kZTogTm9kZSxcbiAgUm9vdDogUm9vdCxcbiAgTm9kZUxpc3Q6IE5vZGVMaXN0LFxuICBWYWx1ZTogVmFsdWUsXG4gIExpdGVyYWw6IExpdGVyYWwsXG4gIFN5bWJvbDogU3ltYm9sLFxuICBHcm91cDogR3JvdXAsXG4gIEFycmF5OiBBcnJheU5vZGUsXG4gIFBhaXI6IFBhaXIsXG4gIERpY3Q6IERpY3QsXG4gIE91dHB1dDogT3V0cHV0LFxuICBDYXB0dXJlOiBDYXB0dXJlLFxuICBUZW1wbGF0ZURhdGE6IFRlbXBsYXRlRGF0YSxcbiAgSWY6IElmLFxuICBJZkFzeW5jOiBJZkFzeW5jLFxuICBJbmxpbmVJZjogSW5saW5lSWYsXG4gIEZvcjogRm9yLFxuICBBc3luY0VhY2g6IEFzeW5jRWFjaCxcbiAgQXN5bmNBbGw6IEFzeW5jQWxsLFxuICBNYWNybzogTWFjcm8sXG4gIENhbGxlcjogQ2FsbGVyLFxuICBJbXBvcnQ6IEltcG9ydCxcbiAgRnJvbUltcG9ydDogRnJvbUltcG9ydCxcbiAgRnVuQ2FsbDogRnVuQ2FsbCxcbiAgRmlsdGVyOiBGaWx0ZXIsXG4gIEZpbHRlckFzeW5jOiBGaWx0ZXJBc3luYyxcbiAgS2V5d29yZEFyZ3M6IEtleXdvcmRBcmdzLFxuICBCbG9jazogQmxvY2ssXG4gIFN1cGVyOiBTdXBlcixcbiAgRXh0ZW5kczogRXh0ZW5kcyxcbiAgSW5jbHVkZTogSW5jbHVkZSxcbiAgU2V0OiBTZXQsXG4gIFN3aXRjaDogU3dpdGNoLFxuICBDYXNlOiBDYXNlLFxuICBMb29rdXBWYWw6IExvb2t1cFZhbCxcbiAgQmluT3A6IEJpbk9wLFxuICBJbjogSW4sXG4gIElzOiBJcyxcbiAgT3I6IE9yLFxuICBBbmQ6IEFuZCxcbiAgTm90OiBOb3QsXG4gIEFkZDogQWRkLFxuICBDb25jYXQ6IENvbmNhdCxcbiAgU3ViOiBTdWIsXG4gIE11bDogTXVsLFxuICBEaXY6IERpdixcbiAgRmxvb3JEaXY6IEZsb29yRGl2LFxuICBNb2Q6IE1vZCxcbiAgUG93OiBQb3csXG4gIE5lZzogTmVnLFxuICBQb3M6IFBvcyxcbiAgQ29tcGFyZTogQ29tcGFyZSxcbiAgQ29tcGFyZU9wZXJhbmQ6IENvbXBhcmVPcGVyYW5kLFxuXG4gIENhbGxFeHRlbnNpb246IENhbGxFeHRlbnNpb24sXG4gIENhbGxFeHRlbnNpb25Bc3luYzogQ2FsbEV4dGVuc2lvbkFzeW5jLFxuXG4gIHByaW50Tm9kZXM6IHByaW50Tm9kZXNcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9udW5qdWNrcy9zcmMvbm9kZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG5jb25zdCB0cmFuc2Zvcm1lciA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtZXInKTtcbmNvbnN0IG5vZGVzID0gcmVxdWlyZSgnLi9ub2RlcycpO1xuY29uc3Qge1RlbXBsYXRlRXJyb3J9ID0gcmVxdWlyZSgnLi9saWInKTtcbmNvbnN0IHtGcmFtZX0gPSByZXF1aXJlKCcuL3J1bnRpbWUnKTtcbmNvbnN0IHtPYmp9ID0gcmVxdWlyZSgnLi9vYmplY3QnKTtcblxuLy8gVGhlc2UgYXJlIGFsbCB0aGUgc2FtZSBmb3Igbm93LCBidXQgc2hvdWxkbid0IGJlIHBhc3NlZCBzdHJhaWdodFxuLy8gdGhyb3VnaFxuY29uc3QgY29tcGFyZU9wcyA9IHtcbiAgJz09JzogJz09JyxcbiAgJz09PSc6ICc9PT0nLFxuICAnIT0nOiAnIT0nLFxuICAnIT09JzogJyE9PScsXG4gICc8JzogJzwnLFxuICAnPic6ICc+JyxcbiAgJzw9JzogJzw9JyxcbiAgJz49JzogJz49J1xufTtcblxuY2xhc3MgQ29tcGlsZXIgZXh0ZW5kcyBPYmoge1xuICBpbml0KHRlbXBsYXRlTmFtZSwgdGhyb3dPblVuZGVmaW5lZCkge1xuICAgIHRoaXMudGVtcGxhdGVOYW1lID0gdGVtcGxhdGVOYW1lO1xuICAgIHRoaXMuY29kZWJ1ZiA9IFtdO1xuICAgIHRoaXMubGFzdElkID0gMDtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5idWZmZXJTdGFjayA9IFtdO1xuICAgIHRoaXMuX3Njb3BlQ2xvc2VycyA9ICcnO1xuICAgIHRoaXMuaW5CbG9jayA9IGZhbHNlO1xuICAgIHRoaXMudGhyb3dPblVuZGVmaW5lZCA9IHRocm93T25VbmRlZmluZWQ7XG4gIH1cblxuICBmYWlsKG1zZywgbGluZW5vLCBjb2xubykge1xuICAgIGlmIChsaW5lbm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGluZW5vICs9IDE7XG4gICAgfVxuICAgIGlmIChjb2xubyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb2xubyArPSAxO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUZW1wbGF0ZUVycm9yKG1zZywgbGluZW5vLCBjb2xubyk7XG4gIH1cblxuICBfcHVzaEJ1ZmZlcigpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuX3RtcGlkKCk7XG4gICAgdGhpcy5idWZmZXJTdGFjay5wdXNoKHRoaXMuYnVmZmVyKTtcbiAgICB0aGlzLmJ1ZmZlciA9IGlkO1xuICAgIHRoaXMuX2VtaXQoYHZhciAke3RoaXMuYnVmZmVyfSA9IFwiXCI7YCk7XG4gICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgX3BvcEJ1ZmZlcigpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyU3RhY2sucG9wKCk7XG4gIH1cblxuICBfZW1pdChjb2RlKSB7XG4gICAgdGhpcy5jb2RlYnVmLnB1c2goY29kZSk7XG4gIH1cblxuICBfZW1pdExpbmUoY29kZSkge1xuICAgIHRoaXMuX2VtaXQoY29kZSArICdcXG4nKTtcbiAgfVxuXG4gIF9lbWl0TGluZXMoLi4ubGluZXMpIHtcbiAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB0aGlzLl9lbWl0TGluZShsaW5lKSk7XG4gIH1cblxuICBfZW1pdEZ1bmNCZWdpbihub2RlLCBuYW1lKSB7XG4gICAgdGhpcy5idWZmZXIgPSAnb3V0cHV0JztcbiAgICB0aGlzLl9zY29wZUNsb3NlcnMgPSAnJztcbiAgICB0aGlzLl9lbWl0TGluZShgZnVuY3Rpb24gJHtuYW1lfShlbnYsIGNvbnRleHQsIGZyYW1lLCBydW50aW1lLCBjYikge2ApO1xuICAgIHRoaXMuX2VtaXRMaW5lKGB2YXIgbGluZW5vID0gJHtub2RlLmxpbmVub307YCk7XG4gICAgdGhpcy5fZW1pdExpbmUoYHZhciBjb2xubyA9ICR7bm9kZS5jb2xub307YCk7XG4gICAgdGhpcy5fZW1pdExpbmUoYHZhciAke3RoaXMuYnVmZmVyfSA9IFwiXCI7YCk7XG4gICAgdGhpcy5fZW1pdExpbmUoJ3RyeSB7Jyk7XG4gIH1cblxuICBfZW1pdEZ1bmNFbmQobm9SZXR1cm4pIHtcbiAgICBpZiAoIW5vUmV0dXJuKSB7XG4gICAgICB0aGlzLl9lbWl0TGluZSgnY2IobnVsbCwgJyArIHRoaXMuYnVmZmVyICsgJyk7Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2xvc2VTY29wZUxldmVscygpO1xuICAgIHRoaXMuX2VtaXRMaW5lKCd9IGNhdGNoIChlKSB7Jyk7XG4gICAgdGhpcy5fZW1pdExpbmUoJyAgY2IocnVudGltZS5oYW5kbGVFcnJvcihlLCBsaW5lbm8sIGNvbG5vKSk7Jyk7XG4gICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcbiAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgfVxuXG4gIF9hZGRTY29wZUxldmVsKCkge1xuICAgIHRoaXMuX3Njb3BlQ2xvc2VycyArPSAnfSknO1xuICB9XG5cbiAgX2Nsb3NlU2NvcGVMZXZlbHMoKSB7XG4gICAgdGhpcy5fZW1pdExpbmUodGhpcy5fc2NvcGVDbG9zZXJzICsgJzsnKTtcbiAgICB0aGlzLl9zY29wZUNsb3NlcnMgPSAnJztcbiAgfVxuXG4gIF93aXRoU2NvcGVkU3ludGF4KGZ1bmMpIHtcbiAgICB2YXIgX3Njb3BlQ2xvc2VycyA9IHRoaXMuX3Njb3BlQ2xvc2VycztcbiAgICB0aGlzLl9zY29wZUNsb3NlcnMgPSAnJztcblxuICAgIGZ1bmMuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX2Nsb3NlU2NvcGVMZXZlbHMoKTtcbiAgICB0aGlzLl9zY29wZUNsb3NlcnMgPSBfc2NvcGVDbG9zZXJzO1xuICB9XG5cbiAgX21ha2VDYWxsYmFjayhyZXMpIHtcbiAgICB2YXIgZXJyID0gdGhpcy5fdG1waWQoKTtcblxuICAgIHJldHVybiAnZnVuY3Rpb24oJyArIGVyciArIChyZXMgPyAnLCcgKyByZXMgOiAnJykgKyAnKSB7XFxuJyArXG4gICAgICAnaWYoJyArIGVyciArICcpIHsgY2IoJyArIGVyciArICcpOyByZXR1cm47IH0nO1xuICB9XG5cbiAgX3RtcGlkKCkge1xuICAgIHRoaXMubGFzdElkKys7XG4gICAgcmV0dXJuICd0XycgKyB0aGlzLmxhc3RJZDtcbiAgfVxuXG4gIF90ZW1wbGF0ZU5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGVtcGxhdGVOYW1lID09IG51bGwgPyAndW5kZWZpbmVkJyA6IEpTT04uc3RyaW5naWZ5KHRoaXMudGVtcGxhdGVOYW1lKTtcbiAgfVxuXG4gIF9jb21waWxlQ2hpbGRyZW4obm9kZSwgZnJhbWUpIHtcbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICB0aGlzLmNvbXBpbGUoY2hpbGQsIGZyYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlQWdncmVnYXRlKG5vZGUsIGZyYW1lLCBzdGFydENoYXIsIGVuZENoYXIpIHtcbiAgICBpZiAoc3RhcnRDaGFyKSB7XG4gICAgICB0aGlzLl9lbWl0KHN0YXJ0Q2hhcik7XG4gICAgfVxuXG4gICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCwgaSkgPT4ge1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHRoaXMuX2VtaXQoJywnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21waWxlKGNoaWxkLCBmcmFtZSk7XG4gICAgfSk7XG5cbiAgICBpZiAoZW5kQ2hhcikge1xuICAgICAgdGhpcy5fZW1pdChlbmRDaGFyKTtcbiAgICB9XG4gIH1cblxuICBfY29tcGlsZUV4cHJlc3Npb24obm9kZSwgZnJhbWUpIHtcbiAgICAvLyBUT0RPOiBJJ20gbm90IHJlYWxseSBzdXJlIGlmIHRoaXMgdHlwZSBjaGVjayBpcyB3b3J0aCBpdCBvclxuICAgIC8vIG5vdC5cbiAgICB0aGlzLmFzc2VydFR5cGUoXG4gICAgICBub2RlLFxuICAgICAgbm9kZXMuTGl0ZXJhbCxcbiAgICAgIG5vZGVzLlN5bWJvbCxcbiAgICAgIG5vZGVzLkdyb3VwLFxuICAgICAgbm9kZXMuQXJyYXksXG4gICAgICBub2Rlcy5EaWN0LFxuICAgICAgbm9kZXMuRnVuQ2FsbCxcbiAgICAgIG5vZGVzLkNhbGxlcixcbiAgICAgIG5vZGVzLkZpbHRlcixcbiAgICAgIG5vZGVzLkxvb2t1cFZhbCxcbiAgICAgIG5vZGVzLkNvbXBhcmUsXG4gICAgICBub2Rlcy5JbmxpbmVJZixcbiAgICAgIG5vZGVzLkluLFxuICAgICAgbm9kZXMuSXMsXG4gICAgICBub2Rlcy5BbmQsXG4gICAgICBub2Rlcy5PcixcbiAgICAgIG5vZGVzLk5vdCxcbiAgICAgIG5vZGVzLkFkZCxcbiAgICAgIG5vZGVzLkNvbmNhdCxcbiAgICAgIG5vZGVzLlN1YixcbiAgICAgIG5vZGVzLk11bCxcbiAgICAgIG5vZGVzLkRpdixcbiAgICAgIG5vZGVzLkZsb29yRGl2LFxuICAgICAgbm9kZXMuTW9kLFxuICAgICAgbm9kZXMuUG93LFxuICAgICAgbm9kZXMuTmVnLFxuICAgICAgbm9kZXMuUG9zLFxuICAgICAgbm9kZXMuQ29tcGFyZSxcbiAgICAgIG5vZGVzLk5vZGVMaXN0XG4gICAgKTtcbiAgICB0aGlzLmNvbXBpbGUobm9kZSwgZnJhbWUpO1xuICB9XG5cbiAgYXNzZXJ0VHlwZShub2RlLCAuLi50eXBlcykge1xuICAgIGlmICghdHlwZXMuc29tZSh0ID0+IG5vZGUgaW5zdGFuY2VvZiB0KSkge1xuICAgICAgdGhpcy5mYWlsKGBhc3NlcnRUeXBlOiBpbnZhbGlkIHR5cGU6ICR7bm9kZS50eXBlbmFtZX1gLCBub2RlLmxpbmVubywgbm9kZS5jb2xubyk7XG4gICAgfVxuICB9XG5cbiAgY29tcGlsZUNhbGxFeHRlbnNpb24obm9kZSwgZnJhbWUsIGFzeW5jKSB7XG4gICAgdmFyIGFyZ3MgPSBub2RlLmFyZ3M7XG4gICAgdmFyIGNvbnRlbnRBcmdzID0gbm9kZS5jb250ZW50QXJncztcbiAgICB2YXIgYXV0b2VzY2FwZSA9IHR5cGVvZiBub2RlLmF1dG9lc2NhcGUgPT09ICdib29sZWFuJyA/IG5vZGUuYXV0b2VzY2FwZSA6IHRydWU7XG5cbiAgICBpZiAoIWFzeW5jKSB7XG4gICAgICB0aGlzLl9lbWl0KGAke3RoaXMuYnVmZmVyfSArPSBydW50aW1lLnN1cHByZXNzVmFsdWUoYCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdChgZW52LmdldEV4dGVuc2lvbihcIiR7bm9kZS5leHROYW1lfVwiKVtcIiR7bm9kZS5wcm9wfVwiXShgKTtcbiAgICB0aGlzLl9lbWl0KCdjb250ZXh0Jyk7XG5cbiAgICBpZiAoYXJncyB8fCBjb250ZW50QXJncykge1xuICAgICAgdGhpcy5fZW1pdCgnLCcpO1xuICAgIH1cblxuICAgIGlmIChhcmdzKSB7XG4gICAgICBpZiAoIShhcmdzIGluc3RhbmNlb2Ygbm9kZXMuTm9kZUxpc3QpKSB7XG4gICAgICAgIHRoaXMuZmFpbCgnY29tcGlsZUNhbGxFeHRlbnNpb246IGFyZ3VtZW50cyBtdXN0IGJlIGEgTm9kZUxpc3QsICcgK1xuICAgICAgICAgICd1c2UgYHBhcnNlci5wYXJzZVNpZ25hdHVyZWAnKTtcbiAgICAgIH1cblxuICAgICAgYXJncy5jaGlsZHJlbi5mb3JFYWNoKChhcmcsIGkpID0+IHtcbiAgICAgICAgLy8gVGFnIGFyZ3VtZW50cyBhcmUgcGFzc2VkIG5vcm1hbGx5IHRvIHRoZSBjYWxsLiBOb3RlXG4gICAgICAgIC8vIHRoYXQga2V5d29yZCBhcmd1bWVudHMgYXJlIHR1cm5lZCBpbnRvIGEgc2luZ2xlIGpzXG4gICAgICAgIC8vIG9iamVjdCBhcyB0aGUgbGFzdCBhcmd1bWVudCwgaWYgdGhleSBleGlzdC5cbiAgICAgICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24oYXJnLCBmcmFtZSk7XG5cbiAgICAgICAgaWYgKGkgIT09IGFyZ3MuY2hpbGRyZW4ubGVuZ3RoIC0gMSB8fCBjb250ZW50QXJncy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0KCcsJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChjb250ZW50QXJncy5sZW5ndGgpIHtcbiAgICAgIGNvbnRlbnRBcmdzLmZvckVhY2goKGFyZywgaSkgPT4ge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICB0aGlzLl9lbWl0KCcsJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdExpbmUoJ2Z1bmN0aW9uKGNiKSB7Jyk7XG4gICAgICAgICAgdGhpcy5fZW1pdExpbmUoJ2lmKCFjYikgeyBjYiA9IGZ1bmN0aW9uKGVycikgeyBpZihlcnIpIHsgdGhyb3cgZXJyOyB9fX0nKTtcbiAgICAgICAgICBjb25zdCBpZCA9IHRoaXMuX3B1c2hCdWZmZXIoKTtcblxuICAgICAgICAgIHRoaXMuX3dpdGhTY29wZWRTeW50YXgoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb21waWxlKGFyZywgZnJhbWUpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdExpbmUoYGNiKG51bGwsICR7aWR9KTtgKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRoaXMuX3BvcEJ1ZmZlcigpO1xuICAgICAgICAgIHRoaXMuX2VtaXRMaW5lKGByZXR1cm4gJHtpZH07YCk7XG4gICAgICAgICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9lbWl0KCdudWxsJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhc3luYykge1xuICAgICAgY29uc3QgcmVzID0gdGhpcy5fdG1waWQoKTtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKCcsICcgKyB0aGlzLl9tYWtlQ2FsbGJhY2socmVzKSk7XG4gICAgICB0aGlzLl9lbWl0TGluZShcbiAgICAgICAgYCR7dGhpcy5idWZmZXJ9ICs9IHJ1bnRpbWUuc3VwcHJlc3NWYWx1ZSgke3Jlc30sICR7YXV0b2VzY2FwZX0gJiYgZW52Lm9wdHMuYXV0b2VzY2FwZSk7YCk7XG4gICAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXQoJyknKTtcbiAgICAgIHRoaXMuX2VtaXQoYCwgJHthdXRvZXNjYXBlfSAmJiBlbnYub3B0cy5hdXRvZXNjYXBlKTtcXG5gKTtcbiAgICB9XG4gIH1cblxuICBjb21waWxlQ2FsbEV4dGVuc2lvbkFzeW5jKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5jb21waWxlQ2FsbEV4dGVuc2lvbihub2RlLCBmcmFtZSwgdHJ1ZSk7XG4gIH1cblxuICBjb21waWxlTm9kZUxpc3Qobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9jb21waWxlQ2hpbGRyZW4obm9kZSwgZnJhbWUpO1xuICB9XG5cbiAgY29tcGlsZUxpdGVyYWwobm9kZSkge1xuICAgIGlmICh0eXBlb2Ygbm9kZS52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCB2YWwgPSBub2RlLnZhbHVlLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJyk7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKTtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJyk7XG4gICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXFx0L2csICdcXFxcdCcpO1xuICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpO1xuICAgICAgdGhpcy5fZW1pdChgXCIke3ZhbH1cImApO1xuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fZW1pdCgnbnVsbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0KG5vZGUudmFsdWUudG9TdHJpbmcoKSk7XG4gICAgfVxuICB9XG5cbiAgY29tcGlsZVN5bWJvbChub2RlLCBmcmFtZSkge1xuICAgIHZhciBuYW1lID0gbm9kZS52YWx1ZTtcbiAgICB2YXIgdiA9IGZyYW1lLmxvb2t1cChuYW1lKTtcblxuICAgIGlmICh2KSB7XG4gICAgICB0aGlzLl9lbWl0KHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbWl0KCdydW50aW1lLmNvbnRleHRPckZyYW1lTG9va3VwKCcgK1xuICAgICAgICAnY29udGV4dCwgZnJhbWUsIFwiJyArIG5hbWUgKyAnXCIpJyk7XG4gICAgfVxuICB9XG5cbiAgY29tcGlsZUdyb3VwKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fY29tcGlsZUFnZ3JlZ2F0ZShub2RlLCBmcmFtZSwgJygnLCAnKScpO1xuICB9XG5cbiAgY29tcGlsZUFycmF5KG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fY29tcGlsZUFnZ3JlZ2F0ZShub2RlLCBmcmFtZSwgJ1snLCAnXScpO1xuICB9XG5cbiAgY29tcGlsZURpY3Qobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9jb21waWxlQWdncmVnYXRlKG5vZGUsIGZyYW1lLCAneycsICd9Jyk7XG4gIH1cblxuICBjb21waWxlUGFpcihub2RlLCBmcmFtZSkge1xuICAgIHZhciBrZXkgPSBub2RlLmtleTtcbiAgICB2YXIgdmFsID0gbm9kZS52YWx1ZTtcblxuICAgIGlmIChrZXkgaW5zdGFuY2VvZiBub2Rlcy5TeW1ib2wpIHtcbiAgICAgIGtleSA9IG5ldyBub2Rlcy5MaXRlcmFsKGtleS5saW5lbm8sIGtleS5jb2xubywga2V5LnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKCEoa2V5IGluc3RhbmNlb2Ygbm9kZXMuTGl0ZXJhbCAmJlxuICAgICAgdHlwZW9mIGtleS52YWx1ZSA9PT0gJ3N0cmluZycpKSB7XG4gICAgICB0aGlzLmZhaWwoJ2NvbXBpbGVQYWlyOiBEaWN0IGtleXMgbXVzdCBiZSBzdHJpbmdzIG9yIG5hbWVzJyxcbiAgICAgICAga2V5LmxpbmVubyxcbiAgICAgICAga2V5LmNvbG5vKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBpbGUoa2V5LCBmcmFtZSk7XG4gICAgdGhpcy5fZW1pdCgnOiAnKTtcbiAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbih2YWwsIGZyYW1lKTtcbiAgfVxuXG4gIGNvbXBpbGVJbmxpbmVJZihub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJygnKTtcbiAgICB0aGlzLmNvbXBpbGUobm9kZS5jb25kLCBmcmFtZSk7XG4gICAgdGhpcy5fZW1pdCgnPycpO1xuICAgIHRoaXMuY29tcGlsZShub2RlLmJvZHksIGZyYW1lKTtcbiAgICB0aGlzLl9lbWl0KCc6Jyk7XG4gICAgaWYgKG5vZGUuZWxzZV8gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuY29tcGlsZShub2RlLmVsc2VfLCBmcmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXQoJ1wiXCInKTtcbiAgICB9XG4gICAgdGhpcy5fZW1pdCgnKScpO1xuICB9XG5cbiAgY29tcGlsZUluKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdCgncnVudGltZS5pbk9wZXJhdG9yKCcpO1xuICAgIHRoaXMuY29tcGlsZShub2RlLmxlZnQsIGZyYW1lKTtcbiAgICB0aGlzLl9lbWl0KCcsJyk7XG4gICAgdGhpcy5jb21waWxlKG5vZGUucmlnaHQsIGZyYW1lKTtcbiAgICB0aGlzLl9lbWl0KCcpJyk7XG4gIH1cblxuICBjb21waWxlSXMobm9kZSwgZnJhbWUpIHtcbiAgICAvLyBmaXJzdCwgd2UgbmVlZCB0byB0cnkgdG8gZ2V0IHRoZSBuYW1lIG9mIHRoZSB0ZXN0IGZ1bmN0aW9uLCBpZiBpdCdzIGFcbiAgICAvLyBjYWxsYWJsZSAoaS5lLiwgaGFzIGFyZ3MpIGFuZCBub3QgYSBzeW1ib2wuXG4gICAgdmFyIHJpZ2h0ID0gbm9kZS5yaWdodC5uYW1lXG4gICAgICA/IG5vZGUucmlnaHQubmFtZS52YWx1ZVxuICAgICAgLy8gb3RoZXJ3aXNlIGdvIHdpdGggdGhlIHN5bWJvbCB2YWx1ZVxuICAgICAgOiBub2RlLnJpZ2h0LnZhbHVlO1xuICAgIHRoaXMuX2VtaXQoJ2Vudi5nZXRUZXN0KFwiJyArIHJpZ2h0ICsgJ1wiKS5jYWxsKGNvbnRleHQsICcpO1xuICAgIHRoaXMuY29tcGlsZShub2RlLmxlZnQsIGZyYW1lKTtcbiAgICAvLyBjb21waWxlIHRoZSBhcmd1bWVudHMgZm9yIHRoZSBjYWxsYWJsZSBpZiB0aGV5IGV4aXN0XG4gICAgaWYgKG5vZGUucmlnaHQuYXJncykge1xuICAgICAgdGhpcy5fZW1pdCgnLCcpO1xuICAgICAgdGhpcy5jb21waWxlKG5vZGUucmlnaHQuYXJncywgZnJhbWUpO1xuICAgIH1cbiAgICB0aGlzLl9lbWl0KCcpID09PSB0cnVlJyk7XG4gIH1cblxuICBfYmluT3BFbWl0dGVyKG5vZGUsIGZyYW1lLCBzdHIpIHtcbiAgICB0aGlzLmNvbXBpbGUobm9kZS5sZWZ0LCBmcmFtZSk7XG4gICAgdGhpcy5fZW1pdChzdHIpO1xuICAgIHRoaXMuY29tcGlsZShub2RlLnJpZ2h0LCBmcmFtZSk7XG4gIH1cblxuICAvLyBlbnN1cmUgY29uY2F0ZW5hdGlvbiBpbnN0ZWFkIG9mIGFkZGl0aW9uXG4gIC8vIGJ5IGFkZGluZyBlbXB0eSBzdHJpbmcgaW4gYmV0d2VlblxuICBjb21waWxlT3Iobm9kZSwgZnJhbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluT3BFbWl0dGVyKG5vZGUsIGZyYW1lLCAnIHx8ICcpO1xuICB9XG5cbiAgY29tcGlsZUFuZChub2RlLCBmcmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9iaW5PcEVtaXR0ZXIobm9kZSwgZnJhbWUsICcgJiYgJyk7XG4gIH1cblxuICBjb21waWxlQWRkKG5vZGUsIGZyYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jpbk9wRW1pdHRlcihub2RlLCBmcmFtZSwgJyArICcpO1xuICB9XG5cbiAgY29tcGlsZUNvbmNhdChub2RlLCBmcmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9iaW5PcEVtaXR0ZXIobm9kZSwgZnJhbWUsICcgKyBcIlwiICsgJyk7XG4gIH1cblxuICBjb21waWxlU3ViKG5vZGUsIGZyYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jpbk9wRW1pdHRlcihub2RlLCBmcmFtZSwgJyAtICcpO1xuICB9XG5cbiAgY29tcGlsZU11bChub2RlLCBmcmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9iaW5PcEVtaXR0ZXIobm9kZSwgZnJhbWUsICcgKiAnKTtcbiAgfVxuXG4gIGNvbXBpbGVEaXYobm9kZSwgZnJhbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluT3BFbWl0dGVyKG5vZGUsIGZyYW1lLCAnIC8gJyk7XG4gIH1cblxuICBjb21waWxlTW9kKG5vZGUsIGZyYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Jpbk9wRW1pdHRlcihub2RlLCBmcmFtZSwgJyAlICcpO1xuICB9XG5cbiAgY29tcGlsZU5vdChub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJyEnKTtcbiAgICB0aGlzLmNvbXBpbGUobm9kZS50YXJnZXQsIGZyYW1lKTtcbiAgfVxuXG4gIGNvbXBpbGVGbG9vckRpdihub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJ01hdGguZmxvb3IoJyk7XG4gICAgdGhpcy5jb21waWxlKG5vZGUubGVmdCwgZnJhbWUpO1xuICAgIHRoaXMuX2VtaXQoJyAvICcpO1xuICAgIHRoaXMuY29tcGlsZShub2RlLnJpZ2h0LCBmcmFtZSk7XG4gICAgdGhpcy5fZW1pdCgnKScpO1xuICB9XG5cbiAgY29tcGlsZVBvdyhub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJ01hdGgucG93KCcpO1xuICAgIHRoaXMuY29tcGlsZShub2RlLmxlZnQsIGZyYW1lKTtcbiAgICB0aGlzLl9lbWl0KCcsICcpO1xuICAgIHRoaXMuY29tcGlsZShub2RlLnJpZ2h0LCBmcmFtZSk7XG4gICAgdGhpcy5fZW1pdCgnKScpO1xuICB9XG5cbiAgY29tcGlsZU5lZyhub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJy0nKTtcbiAgICB0aGlzLmNvbXBpbGUobm9kZS50YXJnZXQsIGZyYW1lKTtcbiAgfVxuXG4gIGNvbXBpbGVQb3Mobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9lbWl0KCcrJyk7XG4gICAgdGhpcy5jb21waWxlKG5vZGUudGFyZ2V0LCBmcmFtZSk7XG4gIH1cblxuICBjb21waWxlQ29tcGFyZShub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuY29tcGlsZShub2RlLmV4cHIsIGZyYW1lKTtcblxuICAgIG5vZGUub3BzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgICB0aGlzLl9lbWl0KGAgJHtjb21wYXJlT3BzW29wLnR5cGVdfSBgKTtcbiAgICAgIHRoaXMuY29tcGlsZShvcC5leHByLCBmcmFtZSk7XG4gICAgfSk7XG4gIH1cblxuICBjb21waWxlTG9va3VwVmFsKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdCgncnVudGltZS5tZW1iZXJMb29rdXAoKCcpO1xuICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUudGFyZ2V0LCBmcmFtZSk7XG4gICAgdGhpcy5fZW1pdCgnKSwnKTtcbiAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbihub2RlLnZhbCwgZnJhbWUpO1xuICAgIHRoaXMuX2VtaXQoJyknKTtcbiAgfVxuXG4gIF9nZXROb2RlTmFtZShub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGVuYW1lKSB7XG4gICAgICBjYXNlICdTeW1ib2wnOlxuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgIGNhc2UgJ0Z1bkNhbGwnOlxuICAgICAgICByZXR1cm4gJ3RoZSByZXR1cm4gdmFsdWUgb2YgKCcgKyB0aGlzLl9nZXROb2RlTmFtZShub2RlLm5hbWUpICsgJyknO1xuICAgICAgY2FzZSAnTG9va3VwVmFsJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE5vZGVOYW1lKG5vZGUudGFyZ2V0KSArICdbXCInICtcbiAgICAgICAgICB0aGlzLl9nZXROb2RlTmFtZShub2RlLnZhbCkgKyAnXCJdJztcbiAgICAgIGNhc2UgJ0xpdGVyYWwnOlxuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZS50b1N0cmluZygpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICctLWV4cHJlc3Npb24tLSc7XG4gICAgfVxuICB9XG5cbiAgY29tcGlsZUZ1bkNhbGwobm9kZSwgZnJhbWUpIHtcbiAgICAvLyBLZWVwIHRyYWNrIG9mIGxpbmUvY29sIGluZm8gYXQgcnVudGltZSBieSBzZXR0aW5nc1xuICAgIC8vIHZhcmlhYmxlcyB3aXRoaW4gYW4gZXhwcmVzc2lvbi4gQW4gZXhwcmVzc2lvbiBpbiBqYXZhc2NyaXB0XG4gICAgLy8gbGlrZSAoeCwgeSwgeikgcmV0dXJucyB0aGUgbGFzdCB2YWx1ZSwgYW5kIHggYW5kIHkgY2FuIGJlXG4gICAgLy8gYW55dGhpbmdcbiAgICB0aGlzLl9lbWl0KCcobGluZW5vID0gJyArIG5vZGUubGluZW5vICtcbiAgICAgICcsIGNvbG5vID0gJyArIG5vZGUuY29sbm8gKyAnLCAnKTtcblxuICAgIHRoaXMuX2VtaXQoJ3J1bnRpbWUuY2FsbFdyYXAoJyk7XG4gICAgLy8gQ29tcGlsZSBpdCBhcyBub3JtYWwuXG4gICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS5uYW1lLCBmcmFtZSk7XG5cbiAgICAvLyBPdXRwdXQgdGhlIG5hbWUgb2Ygd2hhdCB3ZSdyZSBjYWxsaW5nIHNvIHdlIGNhbiBnZXQgZnJpZW5kbHkgZXJyb3JzXG4gICAgLy8gaWYgdGhlIGxvb2t1cCBmYWlscy5cbiAgICB0aGlzLl9lbWl0KCcsIFwiJyArIHRoaXMuX2dldE5vZGVOYW1lKG5vZGUubmFtZSkucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICsgJ1wiLCBjb250ZXh0LCAnKTtcblxuICAgIHRoaXMuX2NvbXBpbGVBZ2dyZWdhdGUobm9kZS5hcmdzLCBmcmFtZSwgJ1snLCAnXSknKTtcblxuICAgIHRoaXMuX2VtaXQoJyknKTtcbiAgfVxuXG4gIGNvbXBpbGVGaWx0ZXIobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgICB0aGlzLmFzc2VydFR5cGUobmFtZSwgbm9kZXMuU3ltYm9sKTtcbiAgICB0aGlzLl9lbWl0KCdlbnYuZ2V0RmlsdGVyKFwiJyArIG5hbWUudmFsdWUgKyAnXCIpLmNhbGwoY29udGV4dCwgJyk7XG4gICAgdGhpcy5fY29tcGlsZUFnZ3JlZ2F0ZShub2RlLmFyZ3MsIGZyYW1lKTtcbiAgICB0aGlzLl9lbWl0KCcpJyk7XG4gIH1cblxuICBjb21waWxlRmlsdGVyQXN5bmMobm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgICB2YXIgc3ltYm9sID0gbm9kZS5zeW1ib2wudmFsdWU7XG5cbiAgICB0aGlzLmFzc2VydFR5cGUobmFtZSwgbm9kZXMuU3ltYm9sKTtcblxuICAgIGZyYW1lLnNldChzeW1ib2wsIHN5bWJvbCk7XG5cbiAgICB0aGlzLl9lbWl0KCdlbnYuZ2V0RmlsdGVyKFwiJyArIG5hbWUudmFsdWUgKyAnXCIpLmNhbGwoY29udGV4dCwgJyk7XG4gICAgdGhpcy5fY29tcGlsZUFnZ3JlZ2F0ZShub2RlLmFyZ3MsIGZyYW1lKTtcbiAgICB0aGlzLl9lbWl0TGluZSgnLCAnICsgdGhpcy5fbWFrZUNhbGxiYWNrKHN5bWJvbCkpO1xuXG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuICB9XG5cbiAgY29tcGlsZUtleXdvcmRBcmdzKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdCgncnVudGltZS5tYWtlS2V5d29yZEFyZ3MoJyk7XG4gICAgdGhpcy5jb21waWxlRGljdChub2RlLCBmcmFtZSk7XG4gICAgdGhpcy5fZW1pdCgnKScpO1xuICB9XG5cbiAgY29tcGlsZVNldChub2RlLCBmcmFtZSkge1xuICAgIHZhciBpZHMgPSBbXTtcblxuICAgIC8vIExvb2t1cCB0aGUgdmFyaWFibGUgbmFtZXMgZm9yIGVhY2ggaWRlbnRpZmllciBhbmQgY3JlYXRlXG4gICAgLy8gbmV3IG9uZXMgaWYgbmVjZXNzYXJ5XG4gICAgbm9kZS50YXJnZXRzLmZvckVhY2goKHRhcmdldCkgPT4ge1xuICAgICAgdmFyIG5hbWUgPSB0YXJnZXQudmFsdWU7XG4gICAgICB2YXIgaWQgPSBmcmFtZS5sb29rdXAobmFtZSk7XG5cbiAgICAgIGlmIChpZCA9PT0gbnVsbCB8fCBpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlkID0gdGhpcy5fdG1waWQoKTtcblxuICAgICAgICAvLyBOb3RlOiBUaGlzIHJlbGllcyBvbiBqcyBhbGxvd2luZyBzY29wZSBhY3Jvc3NcbiAgICAgICAgLy8gYmxvY2tzLCBpbiBjYXNlIHRoaXMgaXMgY3JlYXRlZCBpbnNpZGUgYW4gYGlmYFxuICAgICAgICB0aGlzLl9lbWl0TGluZSgndmFyICcgKyBpZCArICc7Jyk7XG4gICAgICB9XG5cbiAgICAgIGlkcy5wdXNoKGlkKTtcbiAgICB9KTtcblxuICAgIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICB0aGlzLl9lbWl0KGlkcy5qb2luKCcgPSAnKSArICcgPSAnKTtcbiAgICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUudmFsdWUsIGZyYW1lKTtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKCc7Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXQoaWRzLmpvaW4oJyA9ICcpICsgJyA9ICcpO1xuICAgICAgdGhpcy5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuICAgICAgdGhpcy5fZW1pdExpbmUoJzsnKTtcbiAgICB9XG5cbiAgICBub2RlLnRhcmdldHMuZm9yRWFjaCgodGFyZ2V0LCBpKSA9PiB7XG4gICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICB2YXIgbmFtZSA9IHRhcmdldC52YWx1ZTtcblxuICAgICAgLy8gV2UgYXJlIHJ1bm5pbmcgdGhpcyBmb3IgZXZlcnkgdmFyLCBidXQgaXQncyB2ZXJ5XG4gICAgICAvLyB1bmNvbW1vbiB0byBhc3NpZ24gdG8gbXVsdGlwbGUgdmFycyBhbnl3YXlcbiAgICAgIHRoaXMuX2VtaXRMaW5lKGBmcmFtZS5zZXQoXCIke25hbWV9XCIsICR7aWR9LCB0cnVlKTtgKTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoJ2lmKGZyYW1lLnRvcExldmVsKSB7Jyk7XG4gICAgICB0aGlzLl9lbWl0TGluZShgY29udGV4dC5zZXRWYXJpYWJsZShcIiR7bmFtZX1cIiwgJHtpZH0pO2ApO1xuICAgICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcblxuICAgICAgaWYgKG5hbWUuY2hhckF0KDApICE9PSAnXycpIHtcbiAgICAgICAgdGhpcy5fZW1pdExpbmUoJ2lmKGZyYW1lLnRvcExldmVsKSB7Jyk7XG4gICAgICAgIHRoaXMuX2VtaXRMaW5lKGBjb250ZXh0LmFkZEV4cG9ydChcIiR7bmFtZX1cIiwgJHtpZH0pO2ApO1xuICAgICAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29tcGlsZVN3aXRjaChub2RlLCBmcmFtZSkge1xuICAgIHRoaXMuX2VtaXQoJ3N3aXRjaCAoJyk7XG4gICAgdGhpcy5jb21waWxlKG5vZGUuZXhwciwgZnJhbWUpO1xuICAgIHRoaXMuX2VtaXQoJykgeycpO1xuICAgIG5vZGUuY2FzZXMuZm9yRWFjaCgoYywgaSkgPT4ge1xuICAgICAgdGhpcy5fZW1pdCgnY2FzZSAnKTtcbiAgICAgIHRoaXMuY29tcGlsZShjLmNvbmQsIGZyYW1lKTtcbiAgICAgIHRoaXMuX2VtaXQoJzogJyk7XG4gICAgICB0aGlzLmNvbXBpbGUoYy5ib2R5LCBmcmFtZSk7XG4gICAgICAvLyBwcmVzZXJ2ZSBmYWxsLXRocm91Z2hzXG4gICAgICBpZiAoYy5ib2R5LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9lbWl0TGluZSgnYnJlYWs7Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG5vZGUuZGVmYXVsdCkge1xuICAgICAgdGhpcy5fZW1pdCgnZGVmYXVsdDonKTtcbiAgICAgIHRoaXMuY29tcGlsZShub2RlLmRlZmF1bHQsIGZyYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fZW1pdCgnfScpO1xuICB9XG5cbiAgY29tcGlsZUlmKG5vZGUsIGZyYW1lLCBhc3luYykge1xuICAgIHRoaXMuX2VtaXQoJ2lmKCcpO1xuICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUuY29uZCwgZnJhbWUpO1xuICAgIHRoaXMuX2VtaXRMaW5lKCcpIHsnKTtcblxuICAgIHRoaXMuX3dpdGhTY29wZWRTeW50YXgoKCkgPT4ge1xuICAgICAgdGhpcy5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuXG4gICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgdGhpcy5fZW1pdCgnY2IoKScpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG5vZGUuZWxzZV8pIHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKCd9XFxuZWxzZSB7Jyk7XG5cbiAgICAgIHRoaXMuX3dpdGhTY29wZWRTeW50YXgoKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbXBpbGUobm9kZS5lbHNlXywgZnJhbWUpO1xuXG4gICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgIHRoaXMuX2VtaXQoJ2NiKCknKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChhc3luYykge1xuICAgICAgdGhpcy5fZW1pdExpbmUoJ31cXG5lbHNlIHsnKTtcbiAgICAgIHRoaXMuX2VtaXQoJ2NiKCknKTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuICB9XG5cbiAgY29tcGlsZUlmQXN5bmMobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9lbWl0KCcoZnVuY3Rpb24oY2IpIHsnKTtcbiAgICB0aGlzLmNvbXBpbGVJZihub2RlLCBmcmFtZSwgdHJ1ZSk7XG4gICAgdGhpcy5fZW1pdCgnfSkoJyArIHRoaXMuX21ha2VDYWxsYmFjaygpKTtcbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG4gIH1cblxuICBfZW1pdExvb3BCaW5kaW5ncyhub2RlLCBhcnIsIGksIGxlbikge1xuICAgIGNvbnN0IGJpbmRpbmdzID0gW1xuICAgICAge25hbWU6ICdpbmRleCcsIHZhbDogYCR7aX0gKyAxYH0sXG4gICAgICB7bmFtZTogJ2luZGV4MCcsIHZhbDogaX0sXG4gICAgICB7bmFtZTogJ3JldmluZGV4JywgdmFsOiBgJHtsZW59IC0gJHtpfWB9LFxuICAgICAge25hbWU6ICdyZXZpbmRleDAnLCB2YWw6IGAke2xlbn0gLSAke2l9IC0gMWB9LFxuICAgICAge25hbWU6ICdmaXJzdCcsIHZhbDogYCR7aX0gPT09IDBgfSxcbiAgICAgIHtuYW1lOiAnbGFzdCcsIHZhbDogYCR7aX0gPT09ICR7bGVufSAtIDFgfSxcbiAgICAgIHtuYW1lOiAnbGVuZ3RoJywgdmFsOiBsZW59LFxuICAgIF07XG5cbiAgICBiaW5kaW5ncy5mb3JFYWNoKChiKSA9PiB7XG4gICAgICB0aGlzLl9lbWl0TGluZShgZnJhbWUuc2V0KFwibG9vcC4ke2IubmFtZX1cIiwgJHtiLnZhbH0pO2ApO1xuICAgIH0pO1xuICB9XG5cbiAgY29tcGlsZUZvcihub2RlLCBmcmFtZSkge1xuICAgIC8vIFNvbWUgb2YgdGhpcyBjb2RlIGlzIHVnbHksIGJ1dCBpdCBrZWVwcyB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAvLyBhcyBmYXN0IGFzIHBvc3NpYmxlLiBGb3JBc3luYyBhbHNvIHNoYXJlcyBzb21lIG9mIHRoaXMsIGJ1dFxuICAgIC8vIG5vdCBtdWNoLlxuXG4gICAgY29uc3QgaSA9IHRoaXMuX3RtcGlkKCk7XG4gICAgY29uc3QgbGVuID0gdGhpcy5fdG1waWQoKTtcbiAgICBjb25zdCBhcnIgPSB0aGlzLl90bXBpZCgpO1xuICAgIGZyYW1lID0gZnJhbWUucHVzaCgpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2ZyYW1lID0gZnJhbWUucHVzaCgpOycpO1xuXG4gICAgdGhpcy5fZW1pdChgdmFyICR7YXJyfSA9IGApO1xuICAgIHRoaXMuX2NvbXBpbGVFeHByZXNzaW9uKG5vZGUuYXJyLCBmcmFtZSk7XG4gICAgdGhpcy5fZW1pdExpbmUoJzsnKTtcblxuICAgIHRoaXMuX2VtaXQoYGlmKCR7YXJyfSkge2ApO1xuICAgIHRoaXMuX2VtaXRMaW5lKGFyciArICcgPSBydW50aW1lLmZyb21JdGVyYXRvcignICsgYXJyICsgJyk7Jyk7XG5cbiAgICAvLyBJZiBtdWx0aXBsZSBuYW1lcyBhcmUgcGFzc2VkLCB3ZSBuZWVkIHRvIGJpbmQgdGhlbVxuICAgIC8vIGFwcHJvcHJpYXRlbHlcbiAgICBpZiAobm9kZS5uYW1lIGluc3RhbmNlb2Ygbm9kZXMuQXJyYXkpIHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKGB2YXIgJHtpfTtgKTtcblxuICAgICAgLy8gVGhlIG9iamVjdCBjb3VsZCBiZSBhbiBhcnJveSBvciBvYmplY3QuIE5vdGUgdGhhdCB0aGVcbiAgICAgIC8vIGJvZHkgb2YgdGhlIGxvb3AgaXMgZHVwbGljYXRlZCBmb3IgZWFjaCBjb25kaXRpb24sIGJ1dFxuICAgICAgLy8gd2UgYXJlIG9wdGltaXppbmcgZm9yIHNwZWVkIG92ZXIgc2l6ZS5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKGBpZihydW50aW1lLmlzQXJyYXkoJHthcnJ9KSkge2ApO1xuICAgICAgdGhpcy5fZW1pdExpbmUoYHZhciAke2xlbn0gPSAke2Fycn0ubGVuZ3RoO2ApO1xuICAgICAgdGhpcy5fZW1pdExpbmUoYGZvcigke2l9PTA7ICR7aX0gPCAke2Fycn0ubGVuZ3RoOyAke2l9KyspIHtgKTtcblxuICAgICAgLy8gQmluZCBlYWNoIGRlY2xhcmVkIHZhclxuICAgICAgbm9kZS5uYW1lLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkLCB1KSA9PiB7XG4gICAgICAgIHZhciB0aWQgPSB0aGlzLl90bXBpZCgpO1xuICAgICAgICB0aGlzLl9lbWl0TGluZShgdmFyICR7dGlkfSA9ICR7YXJyfVske2l9XVske3V9XTtgKTtcbiAgICAgICAgdGhpcy5fZW1pdExpbmUoYGZyYW1lLnNldChcIiR7Y2hpbGR9XCIsICR7YXJyfVske2l9XVske3V9XSk7YCk7XG4gICAgICAgIGZyYW1lLnNldChub2RlLm5hbWUuY2hpbGRyZW5bdV0udmFsdWUsIHRpZCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZW1pdExvb3BCaW5kaW5ncyhub2RlLCBhcnIsIGksIGxlbik7XG4gICAgICB0aGlzLl93aXRoU2NvcGVkU3ludGF4KCgpID0+IHtcbiAgICAgICAgdGhpcy5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSgnfSBlbHNlIHsnKTtcbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUga2V5L3ZhbHVlcyBvZiBhbiBvYmplY3RcbiAgICAgIGNvbnN0IFtrZXksIHZhbF0gPSBub2RlLm5hbWUuY2hpbGRyZW47XG4gICAgICBjb25zdCBrID0gdGhpcy5fdG1waWQoKTtcbiAgICAgIGNvbnN0IHYgPSB0aGlzLl90bXBpZCgpO1xuICAgICAgZnJhbWUuc2V0KGtleS52YWx1ZSwgayk7XG4gICAgICBmcmFtZS5zZXQodmFsLnZhbHVlLCB2KTtcblxuICAgICAgdGhpcy5fZW1pdExpbmUoYCR7aX0gPSAtMTtgKTtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKGB2YXIgJHtsZW59ID0gcnVudGltZS5rZXlzKCR7YXJyfSkubGVuZ3RoO2ApO1xuICAgICAgdGhpcy5fZW1pdExpbmUoYGZvcih2YXIgJHtrfSBpbiAke2Fycn0pIHtgKTtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKGAke2l9Kys7YCk7XG4gICAgICB0aGlzLl9lbWl0TGluZShgdmFyICR7dn0gPSAke2Fycn1bJHtrfV07YCk7XG4gICAgICB0aGlzLl9lbWl0TGluZShgZnJhbWUuc2V0KFwiJHtrZXkudmFsdWV9XCIsICR7a30pO2ApO1xuICAgICAgdGhpcy5fZW1pdExpbmUoYGZyYW1lLnNldChcIiR7dmFsLnZhbHVlfVwiLCAke3Z9KTtgKTtcblxuICAgICAgdGhpcy5fZW1pdExvb3BCaW5kaW5ncyhub2RlLCBhcnIsIGksIGxlbik7XG4gICAgICB0aGlzLl93aXRoU2NvcGVkU3ludGF4KCgpID0+IHtcbiAgICAgICAgdGhpcy5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBHZW5lcmF0ZSBhIHR5cGljYWwgYXJyYXkgaXRlcmF0aW9uXG4gICAgICBjb25zdCB2ID0gdGhpcy5fdG1waWQoKTtcbiAgICAgIGZyYW1lLnNldChub2RlLm5hbWUudmFsdWUsIHYpO1xuXG4gICAgICB0aGlzLl9lbWl0TGluZShgdmFyICR7bGVufSA9ICR7YXJyfS5sZW5ndGg7YCk7XG4gICAgICB0aGlzLl9lbWl0TGluZShgZm9yKHZhciAke2l9PTA7ICR7aX0gPCAke2Fycn0ubGVuZ3RoOyAke2l9KyspIHtgKTtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKGB2YXIgJHt2fSA9ICR7YXJyfVske2l9XTtgKTtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKGBmcmFtZS5zZXQoXCIke25vZGUubmFtZS52YWx1ZX1cIiwgJHt2fSk7YCk7XG5cbiAgICAgIHRoaXMuX2VtaXRMb29wQmluZGluZ3Mobm9kZSwgYXJyLCBpLCBsZW4pO1xuXG4gICAgICB0aGlzLl93aXRoU2NvcGVkU3ludGF4KCgpID0+IHtcbiAgICAgICAgdGhpcy5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcbiAgICBpZiAobm9kZS5lbHNlXykge1xuICAgICAgdGhpcy5fZW1pdExpbmUoJ2lmICghJyArIGxlbiArICcpIHsnKTtcbiAgICAgIHRoaXMuY29tcGlsZShub2RlLmVsc2VfLCBmcmFtZSk7XG4gICAgICB0aGlzLl9lbWl0TGluZSgnfScpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXRMaW5lKCdmcmFtZSA9IGZyYW1lLnBvcCgpOycpO1xuICB9XG5cbiAgX2NvbXBpbGVBc3luY0xvb3Aobm9kZSwgZnJhbWUsIHBhcmFsbGVsKSB7XG4gICAgLy8gVGhpcyBzaGFyZXMgc29tZSBjb2RlIHdpdGggdGhlIEZvciB0YWcsIGJ1dCBub3QgZW5vdWdoIHRvXG4gICAgLy8gd29ycnkgYWJvdXQuIFRoaXMgaXRlcmF0ZXMgYWNyb3NzIGFuIG9iamVjdCBhc3luY2hyb25vdXNseSxcbiAgICAvLyBidXQgbm90IGluIHBhcmFsbGVsLlxuXG4gICAgdmFyIGkgPSB0aGlzLl90bXBpZCgpO1xuICAgIHZhciBsZW4gPSB0aGlzLl90bXBpZCgpO1xuICAgIHZhciBhcnIgPSB0aGlzLl90bXBpZCgpO1xuICAgIHZhciBhc3luY01ldGhvZCA9IHBhcmFsbGVsID8gJ2FzeW5jQWxsJyA6ICdhc3luY0VhY2gnO1xuICAgIGZyYW1lID0gZnJhbWUucHVzaCgpO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2ZyYW1lID0gZnJhbWUucHVzaCgpOycpO1xuXG4gICAgdGhpcy5fZW1pdCgndmFyICcgKyBhcnIgKyAnID0gcnVudGltZS5mcm9tSXRlcmF0b3IoJyk7XG4gICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS5hcnIsIGZyYW1lKTtcbiAgICB0aGlzLl9lbWl0TGluZSgnKTsnKTtcblxuICAgIGlmIChub2RlLm5hbWUgaW5zdGFuY2VvZiBub2Rlcy5BcnJheSkge1xuICAgICAgY29uc3QgYXJyYXlMZW4gPSBub2RlLm5hbWUuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgdGhpcy5fZW1pdChgcnVudGltZS4ke2FzeW5jTWV0aG9kfSgke2Fycn0sICR7YXJyYXlMZW59LCBmdW5jdGlvbihgKTtcblxuICAgICAgbm9kZS5uYW1lLmNoaWxkcmVuLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgdGhpcy5fZW1pdChgJHtuYW1lLnZhbHVlfSxgKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9lbWl0KGkgKyAnLCcgKyBsZW4gKyAnLG5leHQpIHsnKTtcblxuICAgICAgbm9kZS5uYW1lLmNoaWxkcmVuLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBuYW1lLnZhbHVlO1xuICAgICAgICBmcmFtZS5zZXQoaWQsIGlkKTtcbiAgICAgICAgdGhpcy5fZW1pdExpbmUoYGZyYW1lLnNldChcIiR7aWR9XCIsICR7aWR9KTtgKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpZCA9IG5vZGUubmFtZS52YWx1ZTtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKGBydW50aW1lLiR7YXN5bmNNZXRob2R9KCR7YXJyfSwgMSwgZnVuY3Rpb24oJHtpZH0sICR7aX0sICR7bGVufSxuZXh0KSB7YCk7XG4gICAgICB0aGlzLl9lbWl0TGluZSgnZnJhbWUuc2V0KFwiJyArIGlkICsgJ1wiLCAnICsgaWQgKyAnKTsnKTtcbiAgICAgIGZyYW1lLnNldChpZCwgaWQpO1xuICAgIH1cblxuICAgIHRoaXMuX2VtaXRMb29wQmluZGluZ3Mobm9kZSwgYXJyLCBpLCBsZW4pO1xuXG4gICAgdGhpcy5fd2l0aFNjb3BlZFN5bnRheCgoKSA9PiB7XG4gICAgICBsZXQgYnVmO1xuICAgICAgaWYgKHBhcmFsbGVsKSB7XG4gICAgICAgIGJ1ZiA9IHRoaXMuX3B1c2hCdWZmZXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb21waWxlKG5vZGUuYm9keSwgZnJhbWUpO1xuICAgICAgdGhpcy5fZW1pdExpbmUoJ25leHQoJyArIGkgKyAoYnVmID8gJywnICsgYnVmIDogJycpICsgJyk7Jyk7XG5cbiAgICAgIGlmIChwYXJhbGxlbCkge1xuICAgICAgICB0aGlzLl9wb3BCdWZmZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG91dHB1dCA9IHRoaXMuX3RtcGlkKCk7XG4gICAgdGhpcy5fZW1pdExpbmUoJ30sICcgKyB0aGlzLl9tYWtlQ2FsbGJhY2sob3V0cHV0KSk7XG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuXG4gICAgaWYgKHBhcmFsbGVsKSB7XG4gICAgICB0aGlzLl9lbWl0TGluZSh0aGlzLmJ1ZmZlciArICcgKz0gJyArIG91dHB1dCArICc7Jyk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuZWxzZV8pIHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKCdpZiAoIScgKyBhcnIgKyAnLmxlbmd0aCkgeycpO1xuICAgICAgdGhpcy5jb21waWxlKG5vZGUuZWxzZV8sIGZyYW1lKTtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2ZyYW1lID0gZnJhbWUucG9wKCk7Jyk7XG4gIH1cblxuICBjb21waWxlQXN5bmNFYWNoKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fY29tcGlsZUFzeW5jTG9vcChub2RlLCBmcmFtZSk7XG4gIH1cblxuICBjb21waWxlQXN5bmNBbGwobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLl9jb21waWxlQXN5bmNMb29wKG5vZGUsIGZyYW1lLCB0cnVlKTtcbiAgfVxuXG4gIF9jb21waWxlTWFjcm8obm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBrd2FyZ3MgPSBudWxsO1xuICAgIHZhciBmdW5jSWQgPSAnbWFjcm9fJyArIHRoaXMuX3RtcGlkKCk7XG4gICAgdmFyIGtlZXBGcmFtZSA9IChmcmFtZSAhPT0gdW5kZWZpbmVkKTtcblxuICAgIC8vIFR5cGUgY2hlY2sgdGhlIGRlZmluaXRpb24gb2YgdGhlIGFyZ3NcbiAgICBub2RlLmFyZ3MuY2hpbGRyZW4uZm9yRWFjaCgoYXJnLCBpKSA9PiB7XG4gICAgICBpZiAoaSA9PT0gbm9kZS5hcmdzLmNoaWxkcmVuLmxlbmd0aCAtIDEgJiYgYXJnIGluc3RhbmNlb2Ygbm9kZXMuRGljdCkge1xuICAgICAgICBrd2FyZ3MgPSBhcmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFzc2VydFR5cGUoYXJnLCBub2Rlcy5TeW1ib2wpO1xuICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHJlYWxOYW1lcyA9IFsuLi5hcmdzLm1hcCgobikgPT4gYGxfJHtuLnZhbHVlfWApLCAna3dhcmdzJ107XG5cbiAgICAvLyBRdW90ZWQgYXJndW1lbnQgbmFtZXNcbiAgICBjb25zdCBhcmdOYW1lcyA9IGFyZ3MubWFwKChuKSA9PiBgXCIke24udmFsdWV9XCJgKTtcbiAgICBjb25zdCBrd2FyZ05hbWVzID0gKChrd2FyZ3MgJiYga3dhcmdzLmNoaWxkcmVuKSB8fCBbXSkubWFwKChuKSA9PiBgXCIke24ua2V5LnZhbHVlfVwiYCk7XG5cbiAgICAvLyBXZSBwYXNzIGEgZnVuY3Rpb24gdG8gbWFrZU1hY3JvIHdoaWNoIGRlc3RydWN0dXJlcyB0aGVcbiAgICAvLyBhcmd1bWVudHMgc28gc3VwcG9ydCBzZXR0aW5nIHBvc2l0aW9uYWwgYXJncyB3aXRoIGtleXdvcmRzXG4gICAgLy8gYXJncyBhbmQgcGFzc2luZyBrZXl3b3JkIGFyZ3MgYXMgcG9zaXRpb25hbCBhcmdzXG4gICAgLy8gKGVzc2VudGlhbGx5IGRlZmF1bHQgdmFsdWVzKS4gU2VlIHJ1bnRpbWUuanMuXG4gICAgbGV0IGN1cnJGcmFtZTtcbiAgICBpZiAoa2VlcEZyYW1lKSB7XG4gICAgICBjdXJyRnJhbWUgPSBmcmFtZS5wdXNoKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyRnJhbWUgPSBuZXcgRnJhbWUoKTtcbiAgICB9XG4gICAgdGhpcy5fZW1pdExpbmVzKFxuICAgICAgYHZhciAke2Z1bmNJZH0gPSBydW50aW1lLm1ha2VNYWNybyhgLFxuICAgICAgYFske2FyZ05hbWVzLmpvaW4oJywgJyl9XSwgYCxcbiAgICAgIGBbJHtrd2FyZ05hbWVzLmpvaW4oJywgJyl9XSwgYCxcbiAgICAgIGBmdW5jdGlvbiAoJHtyZWFsTmFtZXMuam9pbignLCAnKX0pIHtgLFxuICAgICAgJ3ZhciBjYWxsZXJGcmFtZSA9IGZyYW1lOycsXG4gICAgICAnZnJhbWUgPSAnICsgKChrZWVwRnJhbWUpID8gJ2ZyYW1lLnB1c2godHJ1ZSk7JyA6ICduZXcgcnVudGltZS5GcmFtZSgpOycpLFxuICAgICAgJ2t3YXJncyA9IGt3YXJncyB8fCB7fTsnLFxuICAgICAgJ2lmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoa3dhcmdzLCBcImNhbGxlclwiKSkgeycsXG4gICAgICAnZnJhbWUuc2V0KFwiY2FsbGVyXCIsIGt3YXJncy5jYWxsZXIpOyB9Jyk7XG5cbiAgICAvLyBFeHBvc2UgdGhlIGFyZ3VtZW50cyB0byB0aGUgdGVtcGxhdGUuIERvbid0IG5lZWQgdG8gdXNlXG4gICAgLy8gcmFuZG9tIG5hbWVzIGJlY2F1c2UgdGhlIGZ1bmN0aW9uXG4gICAgLy8gd2lsbCBjcmVhdGUgYSBuZXcgcnVuLXRpbWUgc2NvcGUgZm9yIHVzXG4gICAgYXJncy5mb3JFYWNoKChhcmcpID0+IHtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKGBmcmFtZS5zZXQoXCIke2FyZy52YWx1ZX1cIiwgbF8ke2FyZy52YWx1ZX0pO2ApO1xuICAgICAgY3VyckZyYW1lLnNldChhcmcudmFsdWUsIGBsXyR7YXJnLnZhbHVlfWApO1xuICAgIH0pO1xuXG4gICAgLy8gRXhwb3NlIHRoZSBrZXl3b3JkIGFyZ3VtZW50c1xuICAgIGlmIChrd2FyZ3MpIHtcbiAgICAgIGt3YXJncy5jaGlsZHJlbi5mb3JFYWNoKChwYWlyKSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYWlyLmtleS52YWx1ZTtcbiAgICAgICAgdGhpcy5fZW1pdChgZnJhbWUuc2V0KFwiJHtuYW1lfVwiLCBgKTtcbiAgICAgICAgdGhpcy5fZW1pdChgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGt3YXJncywgXCIke25hbWV9XCIpYCk7XG4gICAgICAgIHRoaXMuX2VtaXQoYCA/IGt3YXJnc1tcIiR7bmFtZX1cIl0gOiBgKTtcbiAgICAgICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24ocGFpci52YWx1ZSwgY3VyckZyYW1lKTtcbiAgICAgICAgdGhpcy5fZW1pdCgnKTsnKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlcklkID0gdGhpcy5fcHVzaEJ1ZmZlcigpO1xuXG4gICAgdGhpcy5fd2l0aFNjb3BlZFN5bnRheCgoKSA9PiB7XG4gICAgICB0aGlzLmNvbXBpbGUobm9kZS5ib2R5LCBjdXJyRnJhbWUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ2ZyYW1lID0gJyArICgoa2VlcEZyYW1lKSA/ICdmcmFtZS5wb3AoKTsnIDogJ2NhbGxlckZyYW1lOycpKTtcbiAgICB0aGlzLl9lbWl0TGluZShgcmV0dXJuIG5ldyBydW50aW1lLlNhZmVTdHJpbmcoJHtidWZmZXJJZH0pO2ApO1xuICAgIHRoaXMuX2VtaXRMaW5lKCd9KTsnKTtcbiAgICB0aGlzLl9wb3BCdWZmZXIoKTtcblxuICAgIHJldHVybiBmdW5jSWQ7XG4gIH1cblxuICBjb21waWxlTWFjcm8obm9kZSwgZnJhbWUpIHtcbiAgICB2YXIgZnVuY0lkID0gdGhpcy5fY29tcGlsZU1hY3JvKG5vZGUpO1xuXG4gICAgLy8gRXhwb3NlIHRoZSBtYWNybyB0byB0aGUgdGVtcGxhdGVzXG4gICAgdmFyIG5hbWUgPSBub2RlLm5hbWUudmFsdWU7XG4gICAgZnJhbWUuc2V0KG5hbWUsIGZ1bmNJZCk7XG5cbiAgICBpZiAoZnJhbWUucGFyZW50KSB7XG4gICAgICB0aGlzLl9lbWl0TGluZShgZnJhbWUuc2V0KFwiJHtuYW1lfVwiLCAke2Z1bmNJZH0pO2ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobm9kZS5uYW1lLnZhbHVlLmNoYXJBdCgwKSAhPT0gJ18nKSB7XG4gICAgICAgIHRoaXMuX2VtaXRMaW5lKGBjb250ZXh0LmFkZEV4cG9ydChcIiR7bmFtZX1cIik7YCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbWl0TGluZShgY29udGV4dC5zZXRWYXJpYWJsZShcIiR7bmFtZX1cIiwgJHtmdW5jSWR9KTtgKTtcbiAgICB9XG4gIH1cblxuICBjb21waWxlQ2FsbGVyKG5vZGUsIGZyYW1lKSB7XG4gICAgLy8gYmFzaWNhbGx5IGFuIGFub255bW91cyBcIm1hY3JvIGV4cHJlc3Npb25cIlxuICAgIHRoaXMuX2VtaXQoJyhmdW5jdGlvbiAoKXsnKTtcbiAgICBjb25zdCBmdW5jSWQgPSB0aGlzLl9jb21waWxlTWFjcm8obm9kZSwgZnJhbWUpO1xuICAgIHRoaXMuX2VtaXQoYHJldHVybiAke2Z1bmNJZH07fSkoKWApO1xuICB9XG5cbiAgX2NvbXBpbGVHZXRUZW1wbGF0ZShub2RlLCBmcmFtZSwgZWFnZXJDb21waWxlLCBpZ25vcmVNaXNzaW5nKSB7XG4gICAgY29uc3QgcGFyZW50VGVtcGxhdGVJZCA9IHRoaXMuX3RtcGlkKCk7XG4gICAgY29uc3QgcGFyZW50TmFtZSA9IHRoaXMuX3RlbXBsYXRlTmFtZSgpO1xuICAgIGNvbnN0IGNiID0gdGhpcy5fbWFrZUNhbGxiYWNrKHBhcmVudFRlbXBsYXRlSWQpO1xuICAgIGNvbnN0IGVhZ2VyQ29tcGlsZUFyZyA9IChlYWdlckNvbXBpbGUpID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICBjb25zdCBpZ25vcmVNaXNzaW5nQXJnID0gKGlnbm9yZU1pc3NpbmcpID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICB0aGlzLl9lbWl0KCdlbnYuZ2V0VGVtcGxhdGUoJyk7XG4gICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS50ZW1wbGF0ZSwgZnJhbWUpO1xuICAgIHRoaXMuX2VtaXRMaW5lKGAsICR7ZWFnZXJDb21waWxlQXJnfSwgJHtwYXJlbnROYW1lfSwgJHtpZ25vcmVNaXNzaW5nQXJnfSwgJHtjYn1gKTtcbiAgICByZXR1cm4gcGFyZW50VGVtcGxhdGVJZDtcbiAgfVxuXG4gIGNvbXBpbGVJbXBvcnQobm9kZSwgZnJhbWUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBub2RlLnRhcmdldC52YWx1ZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuX2NvbXBpbGVHZXRUZW1wbGF0ZShub2RlLCBmcmFtZSwgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG5cbiAgICB0aGlzLl9lbWl0TGluZShpZCArICcuZ2V0RXhwb3J0ZWQoJyArXG4gICAgICAobm9kZS53aXRoQ29udGV4dCA/ICdjb250ZXh0LmdldFZhcmlhYmxlcygpLCBmcmFtZSwgJyA6ICcnKSArXG4gICAgICB0aGlzLl9tYWtlQ2FsbGJhY2soaWQpKTtcbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG5cbiAgICBmcmFtZS5zZXQodGFyZ2V0LCBpZCk7XG5cbiAgICBpZiAoZnJhbWUucGFyZW50KSB7XG4gICAgICB0aGlzLl9lbWl0TGluZShgZnJhbWUuc2V0KFwiJHt0YXJnZXR9XCIsICR7aWR9KTtgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZW1pdExpbmUoYGNvbnRleHQuc2V0VmFyaWFibGUoXCIke3RhcmdldH1cIiwgJHtpZH0pO2ApO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBpbGVGcm9tSW1wb3J0KG5vZGUsIGZyYW1lKSB7XG4gICAgY29uc3QgaW1wb3J0ZWRJZCA9IHRoaXMuX2NvbXBpbGVHZXRUZW1wbGF0ZShub2RlLCBmcmFtZSwgZmFsc2UsIGZhbHNlKTtcbiAgICB0aGlzLl9hZGRTY29wZUxldmVsKCk7XG5cbiAgICB0aGlzLl9lbWl0TGluZShpbXBvcnRlZElkICsgJy5nZXRFeHBvcnRlZCgnICtcbiAgICAgIChub2RlLndpdGhDb250ZXh0ID8gJ2NvbnRleHQuZ2V0VmFyaWFibGVzKCksIGZyYW1lLCAnIDogJycpICtcbiAgICAgIHRoaXMuX21ha2VDYWxsYmFjayhpbXBvcnRlZElkKSk7XG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuXG4gICAgbm9kZS5uYW1lcy5jaGlsZHJlbi5mb3JFYWNoKChuYW1lTm9kZSkgPT4ge1xuICAgICAgdmFyIG5hbWU7XG4gICAgICB2YXIgYWxpYXM7XG4gICAgICB2YXIgaWQgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgICBpZiAobmFtZU5vZGUgaW5zdGFuY2VvZiBub2Rlcy5QYWlyKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lTm9kZS5rZXkudmFsdWU7XG4gICAgICAgIGFsaWFzID0gbmFtZU5vZGUudmFsdWUudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gbmFtZU5vZGUudmFsdWU7XG4gICAgICAgIGFsaWFzID0gbmFtZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZW1pdExpbmUoYGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCgke2ltcG9ydGVkSWR9LCBcIiR7bmFtZX1cIikpIHtgKTtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKGB2YXIgJHtpZH0gPSAke2ltcG9ydGVkSWR9LiR7bmFtZX07YCk7XG4gICAgICB0aGlzLl9lbWl0TGluZSgnfSBlbHNlIHsnKTtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKGBjYihuZXcgRXJyb3IoXCJjYW5ub3QgaW1wb3J0ICcke25hbWV9J1wiKSk7IHJldHVybjtgKTtcbiAgICAgIHRoaXMuX2VtaXRMaW5lKCd9Jyk7XG5cbiAgICAgIGZyYW1lLnNldChhbGlhcywgaWQpO1xuXG4gICAgICBpZiAoZnJhbWUucGFyZW50KSB7XG4gICAgICAgIHRoaXMuX2VtaXRMaW5lKGBmcmFtZS5zZXQoXCIke2FsaWFzfVwiLCAke2lkfSk7YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lbWl0TGluZShgY29udGV4dC5zZXRWYXJpYWJsZShcIiR7YWxpYXN9XCIsICR7aWR9KTtgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbXBpbGVCbG9jayhub2RlKSB7XG4gICAgdmFyIGlkID0gdGhpcy5fdG1waWQoKTtcblxuICAgIC8vIElmIHdlIGFyZSBleGVjdXRpbmcgb3V0c2lkZSBhIGJsb2NrIChjcmVhdGluZyBhIHRvcC1sZXZlbFxuICAgIC8vIGJsb2NrKSwgd2UgcmVhbGx5IGRvbid0IHdhbnQgdG8gZXhlY3V0ZSBpdHMgY29kZSBiZWNhdXNlIGl0XG4gICAgLy8gd2lsbCBleGVjdXRlIHR3aWNlOiBvbmNlIHdoZW4gdGhlIGNoaWxkIHRlbXBsYXRlIHJ1bnMgYW5kXG4gICAgLy8gYWdhaW4gd2hlbiB0aGUgcGFyZW50IHRlbXBsYXRlIHJ1bnMuIE5vdGUgdGhhdCBibG9ja3NcbiAgICAvLyB3aXRoaW4gYmxvY2tzIHdpbGwgKmFsd2F5cyogZXhlY3V0ZSBpbW1lZGlhdGVseSAqYW5kKlxuICAgIC8vIHdoZXJldmVyIGVsc2UgdGhleSBhcmUgaW52b2tlZCAobGlrZSB1c2VkIGluIGEgcGFyZW50XG4gICAgLy8gdGVtcGxhdGUpLiBUaGlzIG1heSBoYXZlIGJlaGF2aW9yYWwgZGlmZmVyZW5jZXMgZnJvbSBqaW5qYVxuICAgIC8vIGJlY2F1c2UgYmxvY2tzIGNhbiBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGl0IHNlZW1zIGxpa2UgYVxuICAgIC8vIHdhc3RlIG9mIHBlcmZvcm1hbmNlIHRvIGFsd2F5cyBleGVjdXRlIGh1Z2UgdG9wLWxldmVsXG4gICAgLy8gYmxvY2tzIHR3aWNlXG4gICAgaWYgKCF0aGlzLmluQmxvY2spIHtcbiAgICAgIHRoaXMuX2VtaXQoJyhwYXJlbnRUZW1wbGF0ZSA/IGZ1bmN0aW9uKGUsIGMsIGYsIHIsIGNiKSB7IGNiKFwiXCIpOyB9IDogJyk7XG4gICAgfVxuICAgIHRoaXMuX2VtaXQoYGNvbnRleHQuZ2V0QmxvY2soXCIke25vZGUubmFtZS52YWx1ZX1cIilgKTtcbiAgICBpZiAoIXRoaXMuaW5CbG9jaykge1xuICAgICAgdGhpcy5fZW1pdCgnKScpO1xuICAgIH1cbiAgICB0aGlzLl9lbWl0TGluZSgnKGVudiwgY29udGV4dCwgZnJhbWUsIHJ1bnRpbWUsICcgKyB0aGlzLl9tYWtlQ2FsbGJhY2soaWQpKTtcbiAgICB0aGlzLl9lbWl0TGluZShgJHt0aGlzLmJ1ZmZlcn0gKz0gJHtpZH07YCk7XG4gICAgdGhpcy5fYWRkU2NvcGVMZXZlbCgpO1xuICB9XG5cbiAgY29tcGlsZVN1cGVyKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIG5hbWUgPSBub2RlLmJsb2NrTmFtZS52YWx1ZTtcbiAgICB2YXIgaWQgPSBub2RlLnN5bWJvbC52YWx1ZTtcblxuICAgIGNvbnN0IGNiID0gdGhpcy5fbWFrZUNhbGxiYWNrKGlkKTtcbiAgICB0aGlzLl9lbWl0TGluZShgY29udGV4dC5nZXRTdXBlcihlbnYsIFwiJHtuYW1lfVwiLCBiXyR7bmFtZX0sIGZyYW1lLCBydW50aW1lLCAke2NifWApO1xuICAgIHRoaXMuX2VtaXRMaW5lKGAke2lkfSA9IHJ1bnRpbWUubWFya1NhZmUoJHtpZH0pO2ApO1xuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcbiAgICBmcmFtZS5zZXQoaWQsIGlkKTtcbiAgfVxuXG4gIGNvbXBpbGVFeHRlbmRzKG5vZGUsIGZyYW1lKSB7XG4gICAgdmFyIGsgPSB0aGlzLl90bXBpZCgpO1xuXG4gICAgY29uc3QgcGFyZW50VGVtcGxhdGVJZCA9IHRoaXMuX2NvbXBpbGVHZXRUZW1wbGF0ZShub2RlLCBmcmFtZSwgdHJ1ZSwgZmFsc2UpO1xuXG4gICAgLy8gZXh0ZW5kcyBpcyBhIGR5bmFtaWMgdGFnIGFuZCBjYW4gb2NjdXIgd2l0aGluIGEgYmxvY2sgbGlrZVxuICAgIC8vIGBpZmAsIHNvIGlmIHRoaXMgaGFwcGVucyB3ZSBuZWVkIHRvIGNhcHR1cmUgdGhlIHBhcmVudFxuICAgIC8vIHRlbXBsYXRlIGluIHRoZSB0b3AtbGV2ZWwgc2NvcGVcbiAgICB0aGlzLl9lbWl0TGluZShgcGFyZW50VGVtcGxhdGUgPSAke3BhcmVudFRlbXBsYXRlSWR9YCk7XG5cbiAgICB0aGlzLl9lbWl0TGluZShgZm9yKHZhciAke2t9IGluIHBhcmVudFRlbXBsYXRlLmJsb2Nrcykge2ApO1xuICAgIHRoaXMuX2VtaXRMaW5lKGBjb250ZXh0LmFkZEJsb2NrKCR7a30sIHBhcmVudFRlbXBsYXRlLmJsb2Nrc1ske2t9XSk7YCk7XG4gICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcblxuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcbiAgfVxuXG4gIGNvbXBpbGVJbmNsdWRlKG5vZGUsIGZyYW1lKSB7XG4gICAgdGhpcy5fZW1pdExpbmUoJ3ZhciB0YXNrcyA9IFtdOycpO1xuICAgIHRoaXMuX2VtaXRMaW5lKCd0YXNrcy5wdXNoKCcpO1xuICAgIHRoaXMuX2VtaXRMaW5lKCdmdW5jdGlvbihjYWxsYmFjaykgeycpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5fY29tcGlsZUdldFRlbXBsYXRlKG5vZGUsIGZyYW1lLCBmYWxzZSwgbm9kZS5pZ25vcmVNaXNzaW5nKTtcbiAgICB0aGlzLl9lbWl0TGluZShgY2FsbGJhY2sobnVsbCwke2lkfSk7fSk7YCk7XG4gICAgdGhpcy5fZW1pdExpbmUoJ30pOycpO1xuXG4gICAgY29uc3QgaWQyID0gdGhpcy5fdG1waWQoKTtcbiAgICB0aGlzLl9lbWl0TGluZSgndGFza3MucHVzaCgnKTtcbiAgICB0aGlzLl9lbWl0TGluZSgnZnVuY3Rpb24odGVtcGxhdGUsIGNhbGxiYWNrKXsnKTtcbiAgICB0aGlzLl9lbWl0TGluZSgndGVtcGxhdGUucmVuZGVyKGNvbnRleHQuZ2V0VmFyaWFibGVzKCksIGZyYW1lLCAnICsgdGhpcy5fbWFrZUNhbGxiYWNrKGlkMikpO1xuICAgIHRoaXMuX2VtaXRMaW5lKCdjYWxsYmFjayhudWxsLCcgKyBpZDIgKyAnKTt9KTsnKTtcbiAgICB0aGlzLl9lbWl0TGluZSgnfSk7Jyk7XG5cbiAgICB0aGlzLl9lbWl0TGluZSgndGFza3MucHVzaCgnKTtcbiAgICB0aGlzLl9lbWl0TGluZSgnZnVuY3Rpb24ocmVzdWx0LCBjYWxsYmFjayl7Jyk7XG4gICAgdGhpcy5fZW1pdExpbmUoYCR7dGhpcy5idWZmZXJ9ICs9IHJlc3VsdDtgKTtcbiAgICB0aGlzLl9lbWl0TGluZSgnY2FsbGJhY2sobnVsbCk7Jyk7XG4gICAgdGhpcy5fZW1pdExpbmUoJ30pOycpO1xuICAgIHRoaXMuX2VtaXRMaW5lKCdlbnYud2F0ZXJmYWxsKHRhc2tzLCBmdW5jdGlvbigpeycpO1xuICAgIHRoaXMuX2FkZFNjb3BlTGV2ZWwoKTtcbiAgfVxuXG4gIGNvbXBpbGVUZW1wbGF0ZURhdGEobm9kZSwgZnJhbWUpIHtcbiAgICB0aGlzLmNvbXBpbGVMaXRlcmFsKG5vZGUsIGZyYW1lKTtcbiAgfVxuXG4gIGNvbXBpbGVDYXB0dXJlKG5vZGUsIGZyYW1lKSB7XG4gICAgLy8gd2UgbmVlZCB0byB0ZW1wb3JhcmlseSBvdmVycmlkZSB0aGUgY3VycmVudCBidWZmZXIgaWQgYXMgJ291dHB1dCdcbiAgICAvLyBzbyB0aGUgc2V0IGJsb2NrIHdyaXRlcyB0byB0aGUgY2FwdHVyZSBvdXRwdXQgaW5zdGVhZCBvZiB0aGUgYnVmZmVyXG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgIHRoaXMuYnVmZmVyID0gJ291dHB1dCc7XG4gICAgdGhpcy5fZW1pdExpbmUoJyhmdW5jdGlvbigpIHsnKTtcbiAgICB0aGlzLl9lbWl0TGluZSgndmFyIG91dHB1dCA9IFwiXCI7Jyk7XG4gICAgdGhpcy5fd2l0aFNjb3BlZFN5bnRheCgoKSA9PiB7XG4gICAgICB0aGlzLmNvbXBpbGUobm9kZS5ib2R5LCBmcmFtZSk7XG4gICAgfSk7XG4gICAgdGhpcy5fZW1pdExpbmUoJ3JldHVybiBvdXRwdXQ7Jyk7XG4gICAgdGhpcy5fZW1pdExpbmUoJ30pKCknKTtcbiAgICAvLyBhbmQgb2YgY291cnNlLCByZXZlcnQgYmFjayB0byB0aGUgb2xkIGJ1ZmZlciBpZFxuICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICB9XG5cbiAgY29tcGlsZU91dHB1dChub2RlLCBmcmFtZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIC8vIFRlbXBsYXRlRGF0YSBpcyBhIHNwZWNpYWwgY2FzZSBiZWNhdXNlIGl0IGlzIG5ldmVyXG4gICAgICAvLyBhdXRvZXNjYXBlZCwgc28gc2ltcGx5IG91dHB1dCBpdCBmb3Igb3B0aW1pemF0aW9uXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBub2Rlcy5UZW1wbGF0ZURhdGEpIHtcbiAgICAgICAgaWYgKGNoaWxkLnZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fZW1pdChgJHt0aGlzLmJ1ZmZlcn0gKz0gYCk7XG4gICAgICAgICAgdGhpcy5jb21waWxlTGl0ZXJhbChjaGlsZCwgZnJhbWUpO1xuICAgICAgICAgIHRoaXMuX2VtaXRMaW5lKCc7Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2VtaXQoYCR7dGhpcy5idWZmZXJ9ICs9IHJ1bnRpbWUuc3VwcHJlc3NWYWx1ZShgKTtcbiAgICAgICAgaWYgKHRoaXMudGhyb3dPblVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX2VtaXQoJ3J1bnRpbWUuZW5zdXJlRGVmaW5lZCgnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBpbGUoY2hpbGQsIGZyYW1lKTtcbiAgICAgICAgaWYgKHRoaXMudGhyb3dPblVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuX2VtaXQoYCwke25vZGUubGluZW5vfSwke25vZGUuY29sbm99KWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VtaXQoJywgZW52Lm9wdHMuYXV0b2VzY2FwZSk7XFxuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb21waWxlUm9vdChub2RlLCBmcmFtZSkge1xuICAgIGlmIChmcmFtZSkge1xuICAgICAgdGhpcy5mYWlsKCdjb21waWxlUm9vdDogcm9vdCBub2RlIGNhblxcJ3QgaGF2ZSBmcmFtZScpO1xuICAgIH1cblxuICAgIGZyYW1lID0gbmV3IEZyYW1lKCk7XG5cbiAgICB0aGlzLl9lbWl0RnVuY0JlZ2luKG5vZGUsICdyb290Jyk7XG4gICAgdGhpcy5fZW1pdExpbmUoJ3ZhciBwYXJlbnRUZW1wbGF0ZSA9IG51bGw7Jyk7XG4gICAgdGhpcy5fY29tcGlsZUNoaWxkcmVuKG5vZGUsIGZyYW1lKTtcbiAgICB0aGlzLl9lbWl0TGluZSgnaWYocGFyZW50VGVtcGxhdGUpIHsnKTtcbiAgICB0aGlzLl9lbWl0TGluZSgncGFyZW50VGVtcGxhdGUucm9vdFJlbmRlckZ1bmMoZW52LCBjb250ZXh0LCBmcmFtZSwgcnVudGltZSwgY2IpOycpO1xuICAgIHRoaXMuX2VtaXRMaW5lKCd9IGVsc2UgeycpO1xuICAgIHRoaXMuX2VtaXRMaW5lKGBjYihudWxsLCAke3RoaXMuYnVmZmVyfSk7YCk7XG4gICAgdGhpcy5fZW1pdExpbmUoJ30nKTtcbiAgICB0aGlzLl9lbWl0RnVuY0VuZCh0cnVlKTtcblxuICAgIHRoaXMuaW5CbG9jayA9IHRydWU7XG5cbiAgICBjb25zdCBibG9ja05hbWVzID0gW107XG5cbiAgICBjb25zdCBibG9ja3MgPSBub2RlLmZpbmRBbGwobm9kZXMuQmxvY2spO1xuXG4gICAgYmxvY2tzLmZvckVhY2goKGJsb2NrLCBpKSA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gYmxvY2submFtZS52YWx1ZTtcblxuICAgICAgaWYgKGJsb2NrTmFtZXMuaW5kZXhPZihuYW1lKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCbG9jayBcIiR7bmFtZX1cIiBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLmApO1xuICAgICAgfVxuICAgICAgYmxvY2tOYW1lcy5wdXNoKG5hbWUpO1xuXG4gICAgICB0aGlzLl9lbWl0RnVuY0JlZ2luKGJsb2NrLCBgYl8ke25hbWV9YCk7XG5cbiAgICAgIGNvbnN0IHRtcEZyYW1lID0gbmV3IEZyYW1lKCk7XG4gICAgICB0aGlzLl9lbWl0TGluZSgndmFyIGZyYW1lID0gZnJhbWUucHVzaCh0cnVlKTsnKTtcbiAgICAgIHRoaXMuY29tcGlsZShibG9jay5ib2R5LCB0bXBGcmFtZSk7XG4gICAgICB0aGlzLl9lbWl0RnVuY0VuZCgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ3JldHVybiB7Jyk7XG5cbiAgICBibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGkpID0+IHtcbiAgICAgIGNvbnN0IGJsb2NrTmFtZSA9IGBiXyR7YmxvY2submFtZS52YWx1ZX1gO1xuICAgICAgdGhpcy5fZW1pdExpbmUoYCR7YmxvY2tOYW1lfTogJHtibG9ja05hbWV9LGApO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZW1pdExpbmUoJ3Jvb3Q6IHJvb3RcXG59OycpO1xuICB9XG5cbiAgY29tcGlsZShub2RlLCBmcmFtZSkge1xuICAgIHZhciBfY29tcGlsZSA9IHRoaXNbJ2NvbXBpbGUnICsgbm9kZS50eXBlbmFtZV07XG4gICAgaWYgKF9jb21waWxlKSB7XG4gICAgICBfY29tcGlsZS5jYWxsKHRoaXMsIG5vZGUsIGZyYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mYWlsKGBjb21waWxlOiBDYW5ub3QgY29tcGlsZSBub2RlOiAke25vZGUudHlwZW5hbWV9YCwgbm9kZS5saW5lbm8sIG5vZGUuY29sbm8pO1xuICAgIH1cbiAgfVxuXG4gIGdldENvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29kZWJ1Zi5qb2luKCcnKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29tcGlsZTogZnVuY3Rpb24gY29tcGlsZShzcmMsIGFzeW5jRmlsdGVycywgZXh0ZW5zaW9ucywgbmFtZSwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgYyA9IG5ldyBDb21waWxlcihuYW1lLCBvcHRzLnRocm93T25VbmRlZmluZWQpO1xuXG4gICAgLy8gUnVuIHRoZSBleHRlbnNpb24gcHJlcHJvY2Vzc29ycyBhZ2FpbnN0IHRoZSBzb3VyY2UuXG4gICAgY29uc3QgcHJlcHJvY2Vzc29ycyA9IChleHRlbnNpb25zIHx8IFtdKS5tYXAoZXh0ID0+IGV4dC5wcmVwcm9jZXNzKS5maWx0ZXIoZiA9PiAhIWYpO1xuXG4gICAgY29uc3QgcHJvY2Vzc2VkU3JjID0gcHJlcHJvY2Vzc29ycy5yZWR1Y2UoKHMsIHByb2Nlc3NvcikgPT4gcHJvY2Vzc29yKHMpLCBzcmMpO1xuXG4gICAgYy5jb21waWxlKHRyYW5zZm9ybWVyLnRyYW5zZm9ybShcbiAgICAgIHBhcnNlci5wYXJzZShwcm9jZXNzZWRTcmMsIGV4dGVuc2lvbnMsIG9wdHMpLFxuICAgICAgYXN5bmNGaWx0ZXJzLFxuICAgICAgbmFtZVxuICAgICkpO1xuICAgIHJldHVybiBjLmdldENvZGUoKTtcbiAgfSxcblxuICBDb21waWxlcjogQ29tcGlsZXJcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9udW5qdWNrcy9zcmMvY29tcGlsZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCB7RW1pdHRlck9ian0gPSByZXF1aXJlKCcuL29iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIExvYWRlciBleHRlbmRzIEVtaXR0ZXJPYmoge1xuICByZXNvbHZlKGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZShwYXRoLmRpcm5hbWUoZnJvbSksIHRvKTtcbiAgfVxuXG4gIGlzUmVsYXRpdmUoZmlsZW5hbWUpIHtcbiAgICByZXR1cm4gKGZpbGVuYW1lLmluZGV4T2YoJy4vJykgPT09IDAgfHwgZmlsZW5hbWUuaW5kZXhPZignLi4vJykgPT09IDApO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbnVuanVja3Mvc3JjL2xvYWRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgYXNhcCA9IHJlcXVpcmUoJ2FzYXAnKTtcbmNvbnN0IHdhdGVyZmFsbCA9IHJlcXVpcmUoJ2Etc3luYy13YXRlcmZhbGwnKTtcbmNvbnN0IGxpYiA9IHJlcXVpcmUoJy4vbGliJyk7XG5jb25zdCBjb21waWxlciA9IHJlcXVpcmUoJy4vY29tcGlsZXInKTtcbmNvbnN0IGZpbHRlcnMgPSByZXF1aXJlKCcuL2ZpbHRlcnMnKTtcbmNvbnN0IHtGaWxlU3lzdGVtTG9hZGVyLCBXZWJMb2FkZXIsIFByZWNvbXBpbGVkTG9hZGVyfSA9IHJlcXVpcmUoJy4vbG9hZGVycycpO1xuY29uc3QgdGVzdHMgPSByZXF1aXJlKCcuL3Rlc3RzJyk7XG5jb25zdCBnbG9iYWxzID0gcmVxdWlyZSgnLi9nbG9iYWxzJyk7XG5jb25zdCB7T2JqLCBFbWl0dGVyT2JqfSA9IHJlcXVpcmUoJy4vb2JqZWN0Jyk7XG5jb25zdCBnbG9iYWxSdW50aW1lID0gcmVxdWlyZSgnLi9ydW50aW1lJyk7XG5jb25zdCB7aGFuZGxlRXJyb3IsIEZyYW1lfSA9IGdsb2JhbFJ1bnRpbWU7XG5jb25zdCBleHByZXNzQXBwID0gcmVxdWlyZSgnLi9leHByZXNzLWFwcCcpO1xuXG4vLyBJZiB0aGUgdXNlciBpcyB1c2luZyB0aGUgYXN5bmMgQVBJLCAqYWx3YXlzKiBjYWxsIGl0XG4vLyBhc3luY2hyb25vdXNseSBldmVuIGlmIHRoZSB0ZW1wbGF0ZSB3YXMgc3luY2hyb25vdXMuXG5mdW5jdGlvbiBjYWxsYmFja0FzYXAoY2IsIGVyciwgcmVzKSB7XG4gIGFzYXAoKCkgPT4ge1xuICAgIGNiKGVyciwgcmVzKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQSBuby1vcCB0ZW1wbGF0ZSwgZm9yIHVzZSB3aXRoIHslIGluY2x1ZGUgaWdub3JlIG1pc3NpbmcgJX1cbiAqL1xuY29uc3Qgbm9vcFRtcGxTcmMgPSB7XG4gIHR5cGU6ICdjb2RlJyxcbiAgb2JqOiB7XG4gICAgcm9vdChlbnYsIGNvbnRleHQsIGZyYW1lLCBydW50aW1lLCBjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IobnVsbCwgJycpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYihoYW5kbGVFcnJvcihlLCBudWxsLCBudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBFbnZpcm9ubWVudCBleHRlbmRzIEVtaXR0ZXJPYmoge1xuICBpbml0KGxvYWRlcnMsIG9wdHMpIHtcbiAgICAvLyBUaGUgZGV2IGZsYWcgZGV0ZXJtaW5lcyB0aGUgdHJhY2UgdGhhdCdsbCBiZSBzaG93biBvbiBlcnJvcnMuXG4gICAgLy8gSWYgc2V0IHRvIHRydWUsIHJldHVybnMgdGhlIGZ1bGwgdHJhY2UgZnJvbSB0aGUgZXJyb3IgcG9pbnQsXG4gICAgLy8gb3RoZXJ3aXNlIHdpbGwgcmV0dXJuIHRyYWNlIHN0YXJ0aW5nIGZyb20gVGVtcGxhdGUucmVuZGVyXG4gICAgLy8gKHRoZSBmdWxsIHRyYWNlIGZyb20gd2l0aGluIG51bmp1Y2tzIG1heSBjb25mdXNlIGRldmVsb3BlcnMgdXNpbmdcbiAgICAvLyAgdGhlIGxpYnJhcnkpXG4gICAgLy8gZGVmYXVsdHMgdG8gZmFsc2VcbiAgICBvcHRzID0gdGhpcy5vcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLm9wdHMuZGV2ID0gISFvcHRzLmRldjtcblxuICAgIC8vIFRoZSBhdXRvZXNjYXBlIGZsYWcgc2V0cyBnbG9iYWwgYXV0b2VzY2FwaW5nLiBJZiB0cnVlLFxuICAgIC8vIGV2ZXJ5IHN0cmluZyB2YXJpYWJsZSB3aWxsIGJlIGVzY2FwZWQgYnkgZGVmYXVsdC5cbiAgICAvLyBJZiBmYWxzZSwgc3RyaW5ncyBjYW4gYmUgbWFudWFsbHkgZXNjYXBlZCB1c2luZyB0aGUgYGVzY2FwZWAgZmlsdGVyLlxuICAgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICB0aGlzLm9wdHMuYXV0b2VzY2FwZSA9IG9wdHMuYXV0b2VzY2FwZSAhPSBudWxsID8gb3B0cy5hdXRvZXNjYXBlIDogdHJ1ZTtcblxuICAgIC8vIElmIHRydWUsIHRoaXMgd2lsbCBtYWtlIHRoZSBzeXN0ZW0gdGhyb3cgZXJyb3JzIGlmIHRyeWluZ1xuICAgIC8vIHRvIG91dHB1dCBhIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlXG4gICAgdGhpcy5vcHRzLnRocm93T25VbmRlZmluZWQgPSAhIW9wdHMudGhyb3dPblVuZGVmaW5lZDtcbiAgICB0aGlzLm9wdHMudHJpbUJsb2NrcyA9ICEhb3B0cy50cmltQmxvY2tzO1xuICAgIHRoaXMub3B0cy5sc3RyaXBCbG9ja3MgPSAhIW9wdHMubHN0cmlwQmxvY2tzO1xuXG4gICAgdGhpcy5sb2FkZXJzID0gW107XG5cbiAgICBpZiAoIWxvYWRlcnMpIHtcbiAgICAgIC8vIFRoZSBmaWxlc3lzdGVtIGxvYWRlciBpcyBvbmx5IGF2YWlsYWJsZSBzZXJ2ZXItc2lkZVxuICAgICAgaWYgKEZpbGVTeXN0ZW1Mb2FkZXIpIHtcbiAgICAgICAgdGhpcy5sb2FkZXJzID0gW25ldyBGaWxlU3lzdGVtTG9hZGVyKCd2aWV3cycpXTtcbiAgICAgIH0gZWxzZSBpZiAoV2ViTG9hZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZGVycyA9IFtuZXcgV2ViTG9hZGVyKCcvdmlld3MnKV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9hZGVycyA9IGxpYi5pc0FycmF5KGxvYWRlcnMpID8gbG9hZGVycyA6IFtsb2FkZXJzXTtcbiAgICB9XG5cbiAgICAvLyBJdCdzIGVhc3kgdG8gdXNlIHByZWNvbXBpbGVkIHRlbXBsYXRlczoganVzdCBpbmNsdWRlIHRoZW1cbiAgICAvLyBiZWZvcmUgeW91IGNvbmZpZ3VyZSBudW5qdWNrcyBhbmQgdGhpcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAvLyBwaWNrIGl0IHVwIGFuZCB1c2UgaXRcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lm51bmp1Y2tzUHJlY29tcGlsZWQpIHtcbiAgICAgIHRoaXMubG9hZGVycy51bnNoaWZ0KFxuICAgICAgICBuZXcgUHJlY29tcGlsZWRMb2FkZXIod2luZG93Lm51bmp1Y2tzUHJlY29tcGlsZWQpXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuX2luaXRMb2FkZXJzKCk7XG5cbiAgICB0aGlzLmdsb2JhbHMgPSBnbG9iYWxzKCk7XG4gICAgdGhpcy5maWx0ZXJzID0ge307XG4gICAgdGhpcy50ZXN0cyA9IHt9O1xuICAgIHRoaXMuYXN5bmNGaWx0ZXJzID0gW107XG4gICAgdGhpcy5leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5leHRlbnNpb25zTGlzdCA9IFtdO1xuXG4gICAgbGliLl9lbnRyaWVzKGZpbHRlcnMpLmZvckVhY2goKFtuYW1lLCBmaWx0ZXJdKSA9PiB0aGlzLmFkZEZpbHRlcihuYW1lLCBmaWx0ZXIpKTtcbiAgICBsaWIuX2VudHJpZXModGVzdHMpLmZvckVhY2goKFtuYW1lLCB0ZXN0XSkgPT4gdGhpcy5hZGRUZXN0KG5hbWUsIHRlc3QpKTtcbiAgfVxuXG4gIF9pbml0TG9hZGVycygpIHtcbiAgICB0aGlzLmxvYWRlcnMuZm9yRWFjaCgobG9hZGVyKSA9PiB7XG4gICAgICAvLyBDYWNoaW5nIGFuZCBjYWNoZSBidXN0aW5nXG4gICAgICBsb2FkZXIuY2FjaGUgPSB7fTtcbiAgICAgIGlmICh0eXBlb2YgbG9hZGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGxvYWRlci5vbigndXBkYXRlJywgKG5hbWUsIGZ1bGxuYW1lKSA9PiB7XG4gICAgICAgICAgbG9hZGVyLmNhY2hlW25hbWVdID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIG5hbWUsIGZ1bGxuYW1lLCBsb2FkZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgbG9hZGVyLm9uKCdsb2FkJywgKG5hbWUsIHNvdXJjZSkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdCgnbG9hZCcsIG5hbWUsIHNvdXJjZSwgbG9hZGVyKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpbnZhbGlkYXRlQ2FjaGUoKSB7XG4gICAgdGhpcy5sb2FkZXJzLmZvckVhY2goKGxvYWRlcikgPT4ge1xuICAgICAgbG9hZGVyLmNhY2hlID0ge307XG4gICAgfSk7XG4gIH1cblxuICBhZGRFeHRlbnNpb24obmFtZSwgZXh0ZW5zaW9uKSB7XG4gICAgZXh0ZW5zaW9uLl9fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5leHRlbnNpb25zW25hbWVdID0gZXh0ZW5zaW9uO1xuICAgIHRoaXMuZXh0ZW5zaW9uc0xpc3QucHVzaChleHRlbnNpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVtb3ZlRXh0ZW5zaW9uKG5hbWUpIHtcbiAgICB2YXIgZXh0ZW5zaW9uID0gdGhpcy5nZXRFeHRlbnNpb24obmFtZSk7XG4gICAgaWYgKCFleHRlbnNpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmV4dGVuc2lvbnNMaXN0ID0gbGliLndpdGhvdXQodGhpcy5leHRlbnNpb25zTGlzdCwgZXh0ZW5zaW9uKTtcbiAgICBkZWxldGUgdGhpcy5leHRlbnNpb25zW25hbWVdO1xuICB9XG5cbiAgZ2V0RXh0ZW5zaW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25zW25hbWVdO1xuICB9XG5cbiAgaGFzRXh0ZW5zaW9uKG5hbWUpIHtcbiAgICByZXR1cm4gISF0aGlzLmV4dGVuc2lvbnNbbmFtZV07XG4gIH1cblxuICBhZGRHbG9iYWwobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmdsb2JhbHNbbmFtZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldEdsb2JhbChuYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmdsb2JhbHNbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsb2JhbCBub3QgZm91bmQ6ICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsc1tuYW1lXTtcbiAgfVxuXG4gIGFkZEZpbHRlcihuYW1lLCBmdW5jLCBhc3luYykge1xuICAgIHZhciB3cmFwcGVkID0gZnVuYztcblxuICAgIGlmIChhc3luYykge1xuICAgICAgdGhpcy5hc3luY0ZpbHRlcnMucHVzaChuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5maWx0ZXJzW25hbWVdID0gd3JhcHBlZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldEZpbHRlcihuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmZpbHRlcnNbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmlsdGVyIG5vdCBmb3VuZDogJyArIG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maWx0ZXJzW25hbWVdO1xuICB9XG5cbiAgYWRkVGVzdChuYW1lLCBmdW5jKSB7XG4gICAgdGhpcy50ZXN0c1tuYW1lXSA9IGZ1bmM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRUZXN0KG5hbWUpIHtcbiAgICBpZiAoIXRoaXMudGVzdHNbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGVzdCBub3QgZm91bmQ6ICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGVzdHNbbmFtZV07XG4gIH1cblxuICByZXNvbHZlVGVtcGxhdGUobG9hZGVyLCBwYXJlbnROYW1lLCBmaWxlbmFtZSkge1xuICAgIHZhciBpc1JlbGF0aXZlID0gKGxvYWRlci5pc1JlbGF0aXZlICYmIHBhcmVudE5hbWUpID8gbG9hZGVyLmlzUmVsYXRpdmUoZmlsZW5hbWUpIDogZmFsc2U7XG4gICAgcmV0dXJuIChpc1JlbGF0aXZlICYmIGxvYWRlci5yZXNvbHZlKSA/IGxvYWRlci5yZXNvbHZlKHBhcmVudE5hbWUsIGZpbGVuYW1lKSA6IGZpbGVuYW1lO1xuICB9XG5cbiAgZ2V0VGVtcGxhdGUobmFtZSwgZWFnZXJDb21waWxlLCBwYXJlbnROYW1lLCBpZ25vcmVNaXNzaW5nLCBjYikge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgdG1wbCA9IG51bGw7XG4gICAgaWYgKG5hbWUgJiYgbmFtZS5yYXcpIHtcbiAgICAgIC8vIHRoaXMgZml4ZXMgYXV0b2VzY2FwZSBmb3IgdGVtcGxhdGVzIHJlZmVyZW5jZWQgaW4gc3ltYm9sc1xuICAgICAgbmFtZSA9IG5hbWUucmF3O1xuICAgIH1cblxuICAgIGlmIChsaWIuaXNGdW5jdGlvbihwYXJlbnROYW1lKSkge1xuICAgICAgY2IgPSBwYXJlbnROYW1lO1xuICAgICAgcGFyZW50TmFtZSA9IG51bGw7XG4gICAgICBlYWdlckNvbXBpbGUgPSBlYWdlckNvbXBpbGUgfHwgZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxpYi5pc0Z1bmN0aW9uKGVhZ2VyQ29tcGlsZSkpIHtcbiAgICAgIGNiID0gZWFnZXJDb21waWxlO1xuICAgICAgZWFnZXJDb21waWxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBUZW1wbGF0ZSkge1xuICAgICAgdG1wbCA9IG5hbWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndGVtcGxhdGUgbmFtZXMgbXVzdCBiZSBhIHN0cmluZzogJyArIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9hZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsb2FkZXIgPSB0aGlzLmxvYWRlcnNbaV07XG4gICAgICAgIHRtcGwgPSBsb2FkZXIuY2FjaGVbdGhpcy5yZXNvbHZlVGVtcGxhdGUobG9hZGVyLCBwYXJlbnROYW1lLCBuYW1lKV07XG4gICAgICAgIGlmICh0bXBsKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG1wbCkge1xuICAgICAgaWYgKGVhZ2VyQ29tcGlsZSkge1xuICAgICAgICB0bXBsLmNvbXBpbGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiKG51bGwsIHRtcGwpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRtcGw7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBzeW5jUmVzdWx0O1xuXG4gICAgY29uc3QgY3JlYXRlVGVtcGxhdGUgPSAoZXJyLCBpbmZvKSA9PiB7XG4gICAgICBpZiAoIWluZm8gJiYgIWVyciAmJiAhaWdub3JlTWlzc2luZykge1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IoJ3RlbXBsYXRlIG5vdCBmb3VuZDogJyArIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IG5ld1RtcGw7XG4gICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgbmV3VG1wbCA9IG5ldyBUZW1wbGF0ZShub29wVG1wbFNyYywgdGhpcywgJycsIGVhZ2VyQ29tcGlsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdUbXBsID0gbmV3IFRlbXBsYXRlKGluZm8uc3JjLCB0aGlzLCBpbmZvLnBhdGgsIGVhZ2VyQ29tcGlsZSk7XG4gICAgICAgIGlmICghaW5mby5ub0NhY2hlKSB7XG4gICAgICAgICAgaW5mby5sb2FkZXIuY2FjaGVbbmFtZV0gPSBuZXdUbXBsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgY2IobnVsbCwgbmV3VG1wbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzeW5jUmVzdWx0ID0gbmV3VG1wbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGliLmFzeW5jSXRlcih0aGlzLmxvYWRlcnMsIChsb2FkZXIsIGksIG5leHQsIGRvbmUpID0+IHtcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShlcnIsIHNyYykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZG9uZShlcnIpO1xuICAgICAgICB9IGVsc2UgaWYgKHNyYykge1xuICAgICAgICAgIHNyYy5sb2FkZXIgPSBsb2FkZXI7XG4gICAgICAgICAgZG9uZShudWxsLCBzcmMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZXNvbHZlIG5hbWUgcmVsYXRpdmUgdG8gcGFyZW50TmFtZVxuICAgICAgbmFtZSA9IHRoYXQucmVzb2x2ZVRlbXBsYXRlKGxvYWRlciwgcGFyZW50TmFtZSwgbmFtZSk7XG5cbiAgICAgIGlmIChsb2FkZXIuYXN5bmMpIHtcbiAgICAgICAgbG9hZGVyLmdldFNvdXJjZShuYW1lLCBoYW5kbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlKG51bGwsIGxvYWRlci5nZXRTb3VyY2UobmFtZSkpO1xuICAgICAgfVxuICAgIH0sIGNyZWF0ZVRlbXBsYXRlKTtcblxuICAgIHJldHVybiBzeW5jUmVzdWx0O1xuICB9XG5cbiAgZXhwcmVzcyhhcHApIHtcbiAgICByZXR1cm4gZXhwcmVzc0FwcCh0aGlzLCBhcHApO1xuICB9XG5cbiAgcmVuZGVyKG5hbWUsIGN0eCwgY2IpIHtcbiAgICBpZiAobGliLmlzRnVuY3Rpb24oY3R4KSkge1xuICAgICAgY2IgPSBjdHg7XG4gICAgICBjdHggPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFdlIHN1cHBvcnQgYSBzeW5jaHJvbm91cyBBUEkgdG8gbWFrZSBpdCBlYXNpZXIgdG8gbWlncmF0ZVxuICAgIC8vIGV4aXN0aW5nIGNvZGUgdG8gYXN5bmMuIFRoaXMgd29ya3MgYmVjYXVzZSBpZiB5b3UgZG9uJ3QgZG9cbiAgICAvLyBhbnl0aGluZyBhc3luYyB3b3JrLCB0aGUgd2hvbGUgdGhpbmcgaXMgYWN0dWFsbHkgcnVuXG4gICAgLy8gc3luY2hyb25vdXNseS5cbiAgICBsZXQgc3luY1Jlc3VsdCA9IG51bGw7XG5cbiAgICB0aGlzLmdldFRlbXBsYXRlKG5hbWUsIChlcnIsIHRtcGwpID0+IHtcbiAgICAgIGlmIChlcnIgJiYgY2IpIHtcbiAgICAgICAgY2FsbGJhY2tBc2FwKGNiLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3luY1Jlc3VsdCA9IHRtcGwucmVuZGVyKGN0eCwgY2IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN5bmNSZXN1bHQ7XG4gIH1cblxuICByZW5kZXJTdHJpbmcoc3JjLCBjdHgsIG9wdHMsIGNiKSB7XG4gICAgaWYgKGxpYi5pc0Z1bmN0aW9uKG9wdHMpKSB7XG4gICAgICBjYiA9IG9wdHM7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgY29uc3QgdG1wbCA9IG5ldyBUZW1wbGF0ZShzcmMsIHRoaXMsIG9wdHMucGF0aCk7XG4gICAgcmV0dXJuIHRtcGwucmVuZGVyKGN0eCwgY2IpO1xuICB9XG5cbiAgd2F0ZXJmYWxsKHRhc2tzLCBjYWxsYmFjaywgZm9yY2VBc3luYykge1xuICAgIHJldHVybiB3YXRlcmZhbGwodGFza3MsIGNhbGxiYWNrLCBmb3JjZUFzeW5jKTtcbiAgfVxufVxuXG5jbGFzcyBDb250ZXh0IGV4dGVuZHMgT2JqIHtcbiAgaW5pdChjdHgsIGJsb2NrcywgZW52KSB7XG4gICAgLy8gSGFzIHRvIGJlIHRpZWQgdG8gYW4gZW52aXJvbm1lbnQgc28gd2UgY2FuIHRhcCBpbnRvIGl0cyBnbG9iYWxzLlxuICAgIHRoaXMuZW52ID0gZW52IHx8IG5ldyBFbnZpcm9ubWVudCgpO1xuXG4gICAgLy8gTWFrZSBhIGR1cGxpY2F0ZSBvZiBjdHhcbiAgICB0aGlzLmN0eCA9IGxpYi5leHRlbmQoe30sIGN0eCk7XG5cbiAgICB0aGlzLmJsb2NrcyA9IHt9O1xuICAgIHRoaXMuZXhwb3J0ZWQgPSBbXTtcblxuICAgIGxpYi5rZXlzKGJsb2NrcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIHRoaXMuYWRkQmxvY2sobmFtZSwgYmxvY2tzW25hbWVdKTtcbiAgICB9KTtcbiAgfVxuXG4gIGxvb2t1cChuYW1lKSB7XG4gICAgLy8gVGhpcyBpcyBvbmUgb2YgdGhlIG1vc3QgY2FsbGVkIGZ1bmN0aW9ucywgc28gb3B0aW1pemUgZm9yXG4gICAgLy8gdGhlIHR5cGljYWwgY2FzZSB3aGVyZSB0aGUgbmFtZSBpc24ndCBpbiB0aGUgZ2xvYmFsc1xuICAgIGlmIChuYW1lIGluIHRoaXMuZW52Lmdsb2JhbHMgJiYgIShuYW1lIGluIHRoaXMuY3R4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZW52Lmdsb2JhbHNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmN0eFtuYW1lXTtcbiAgICB9XG4gIH1cblxuICBzZXRWYXJpYWJsZShuYW1lLCB2YWwpIHtcbiAgICB0aGlzLmN0eFtuYW1lXSA9IHZhbDtcbiAgfVxuXG4gIGdldFZhcmlhYmxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5jdHg7XG4gIH1cblxuICBhZGRCbG9jayhuYW1lLCBibG9jaykge1xuICAgIHRoaXMuYmxvY2tzW25hbWVdID0gdGhpcy5ibG9ja3NbbmFtZV0gfHwgW107XG4gICAgdGhpcy5ibG9ja3NbbmFtZV0ucHVzaChibG9jayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRCbG9jayhuYW1lKSB7XG4gICAgaWYgKCF0aGlzLmJsb2Nrc1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGJsb2NrIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ibG9ja3NbbmFtZV1bMF07XG4gIH1cblxuICBnZXRTdXBlcihlbnYsIG5hbWUsIGJsb2NrLCBmcmFtZSwgcnVudGltZSwgY2IpIHtcbiAgICB2YXIgaWR4ID0gbGliLmluZGV4T2YodGhpcy5ibG9ja3NbbmFtZV0gfHwgW10sIGJsb2NrKTtcbiAgICB2YXIgYmxrID0gdGhpcy5ibG9ja3NbbmFtZV1baWR4ICsgMV07XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgaWYgKGlkeCA9PT0gLTEgfHwgIWJsaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBzdXBlciBibG9jayBhdmFpbGFibGUgZm9yIFwiJyArIG5hbWUgKyAnXCInKTtcbiAgICB9XG5cbiAgICBibGsoZW52LCBjb250ZXh0LCBmcmFtZSwgcnVudGltZSwgY2IpO1xuICB9XG5cbiAgYWRkRXhwb3J0KG5hbWUpIHtcbiAgICB0aGlzLmV4cG9ydGVkLnB1c2gobmFtZSk7XG4gIH1cblxuICBnZXRFeHBvcnRlZCgpIHtcbiAgICB2YXIgZXhwb3J0ZWQgPSB7fTtcbiAgICB0aGlzLmV4cG9ydGVkLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGV4cG9ydGVkW25hbWVdID0gdGhpcy5jdHhbbmFtZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIGV4cG9ydGVkO1xuICB9XG59XG5cbmNsYXNzIFRlbXBsYXRlIGV4dGVuZHMgT2JqIHtcbiAgaW5pdChzcmMsIGVudiwgcGF0aCwgZWFnZXJDb21waWxlKSB7XG4gICAgdGhpcy5lbnYgPSBlbnYgfHwgbmV3IEVudmlyb25tZW50KCk7XG5cbiAgICBpZiAobGliLmlzT2JqZWN0KHNyYykpIHtcbiAgICAgIHN3aXRjaCAoc3JjLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgICAgdGhpcy50bXBsUHJvcHMgPSBzcmMub2JqO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIHRoaXMudG1wbFN0ciA9IHNyYy5vYmo7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFVuZXhwZWN0ZWQgdGVtcGxhdGUgb2JqZWN0IHR5cGUgJHtzcmMudHlwZX07IGV4cGVjdGVkICdjb2RlJywgb3IgJ3N0cmluZydgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxpYi5pc1N0cmluZyhzcmMpKSB7XG4gICAgICB0aGlzLnRtcGxTdHIgPSBzcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc3JjIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIHNvdXJjZScpO1xuICAgIH1cblxuICAgIHRoaXMucGF0aCA9IHBhdGg7XG5cbiAgICBpZiAoZWFnZXJDb21waWxlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbGliLl9wcmV0dGlmeUVycm9yKHRoaXMucGF0aCwgdGhpcy5lbnYub3B0cy5kZXYsIGVycik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tcGlsZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoY3R4LCBwYXJlbnRGcmFtZSwgY2IpIHtcbiAgICBpZiAodHlwZW9mIGN0eCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBjdHg7XG4gICAgICBjdHggPSB7fTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXJlbnRGcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBwYXJlbnRGcmFtZTtcbiAgICAgIHBhcmVudEZyYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHBhcmVudCBmcmFtZSwgd2UgYXJlIGJlaW5nIGNhbGxlZCBmcm9tIGludGVybmFsXG4gICAgLy8gY29kZSBvZiBhbm90aGVyIHRlbXBsYXRlLCBhbmQgdGhlIGludGVybmFsIHN5c3RlbVxuICAgIC8vIGRlcGVuZHMgb24gdGhlIHN5bmMvYXN5bmMgbmF0dXJlIG9mIHRoZSBwYXJlbnQgdGVtcGxhdGVcbiAgICAvLyB0byBiZSBpbmhlcml0ZWQsIHNvIGZvcmNlIGFuIGFzeW5jIGNhbGxiYWNrXG4gICAgY29uc3QgZm9yY2VBc3luYyA9ICFwYXJlbnRGcmFtZTtcblxuICAgIC8vIENhdGNoIGNvbXBpbGUgZXJyb3JzIGZvciBhc3luYyByZW5kZXJpbmdcbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21waWxlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3QgZXJyID0gbGliLl9wcmV0dGlmeUVycm9yKHRoaXMucGF0aCwgdGhpcy5lbnYub3B0cy5kZXYsIGUpO1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFja0FzYXAoY2IsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY29udGV4dCA9IG5ldyBDb250ZXh0KGN0eCB8fCB7fSwgdGhpcy5ibG9ja3MsIHRoaXMuZW52KTtcbiAgICBjb25zdCBmcmFtZSA9IHBhcmVudEZyYW1lID8gcGFyZW50RnJhbWUucHVzaCh0cnVlKSA6IG5ldyBGcmFtZSgpO1xuICAgIGZyYW1lLnRvcExldmVsID0gdHJ1ZTtcbiAgICBsZXQgc3luY1Jlc3VsdCA9IG51bGw7XG4gICAgbGV0IGRpZEVycm9yID0gZmFsc2U7XG5cbiAgICB0aGlzLnJvb3RSZW5kZXJGdW5jKHRoaXMuZW52LCBjb250ZXh0LCBmcmFtZSwgZ2xvYmFsUnVudGltZSwgKGVyciwgcmVzKSA9PiB7XG4gICAgICAvLyBUT0RPOiB0aGlzIGlzIGFjdHVhbGx5IGEgYnVnIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSAoYmVjYXVzZSB3YXRlcmZhbGxcbiAgICAgIC8vIHRhc2tzIGFyZSBib3RoIG5vdCBwYXNzaW5nIGVycm9ycyB1cCB0aGUgY2hhaW4gb2YgY2FsbGJhY2tzIEFORCBhcmUgbm90XG4gICAgICAvLyBjYXVzaW5nIGEgcmV0dXJuIGZyb20gdGhlIHRvcC1tb3N0IHJlbmRlciBmdW5jdGlvbikuIEJ1dCBmaXhpbmcgdGhhdFxuICAgICAgLy8gd2lsbCByZXF1aXJlIGEgbW9yZSBzdWJzdGFudGlhbCBjaGFuZ2UgdG8gdGhlIGNvbXBpbGVyLlxuICAgICAgaWYgKGRpZEVycm9yICYmIGNiICYmIHR5cGVvZiByZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHByZXZlbnQgbXVsdGlwbGUgY2FsbHMgdG8gY2JcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGVyciA9IGxpYi5fcHJldHRpZnlFcnJvcih0aGlzLnBhdGgsIHRoaXMuZW52Lm9wdHMuZGV2LCBlcnIpO1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYikge1xuICAgICAgICBpZiAoZm9yY2VBc3luYykge1xuICAgICAgICAgIGNhbGxiYWNrQXNhcChjYiwgZXJyLCByZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKGVyciwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBzeW5jUmVzdWx0ID0gcmVzO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHN5bmNSZXN1bHQ7XG4gIH1cblxuXG4gIGdldEV4cG9ydGVkKGN0eCwgcGFyZW50RnJhbWUsIGNiKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICBpZiAodHlwZW9mIGN0eCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBjdHg7XG4gICAgICBjdHggPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHBhcmVudEZyYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IHBhcmVudEZyYW1lO1xuICAgICAgcGFyZW50RnJhbWUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIENhdGNoIGNvbXBpbGUgZXJyb3JzIGZvciBhc3luYyByZW5kZXJpbmdcbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21waWxlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHJldHVybiBjYihlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZnJhbWUgPSBwYXJlbnRGcmFtZSA/IHBhcmVudEZyYW1lLnB1c2goKSA6IG5ldyBGcmFtZSgpO1xuICAgIGZyYW1lLnRvcExldmVsID0gdHJ1ZTtcblxuICAgIC8vIFJ1biB0aGUgcm9vdFJlbmRlckZ1bmMgdG8gcG9wdWxhdGUgdGhlIGNvbnRleHQgd2l0aCBleHBvcnRlZCB2YXJzXG4gICAgY29uc3QgY29udGV4dCA9IG5ldyBDb250ZXh0KGN0eCB8fCB7fSwgdGhpcy5ibG9ja3MsIHRoaXMuZW52KTtcbiAgICB0aGlzLnJvb3RSZW5kZXJGdW5jKHRoaXMuZW52LCBjb250ZXh0LCBmcmFtZSwgZ2xvYmFsUnVudGltZSwgKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYihlcnIsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2IobnVsbCwgY29udGV4dC5nZXRFeHBvcnRlZCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbXBpbGUoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXBpbGVkKSB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfVxuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgdmFyIHByb3BzO1xuXG4gICAgaWYgKHRoaXMudG1wbFByb3BzKSB7XG4gICAgICBwcm9wcyA9IHRoaXMudG1wbFByb3BzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBjb21waWxlci5jb21waWxlKHRoaXMudG1wbFN0cixcbiAgICAgICAgdGhpcy5lbnYuYXN5bmNGaWx0ZXJzLFxuICAgICAgICB0aGlzLmVudi5leHRlbnNpb25zTGlzdCxcbiAgICAgICAgdGhpcy5wYXRoLFxuICAgICAgICB0aGlzLmVudi5vcHRzKTtcblxuICAgICAgY29uc3QgZnVuYyA9IG5ldyBGdW5jdGlvbihzb3VyY2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy1mdW5jXG4gICAgICBwcm9wcyA9IGZ1bmMoKTtcbiAgICB9XG5cbiAgICB0aGlzLmJsb2NrcyA9IHRoaXMuX2dldEJsb2Nrcyhwcm9wcyk7XG4gICAgdGhpcy5yb290UmVuZGVyRnVuYyA9IHByb3BzLnJvb3Q7XG4gICAgdGhpcy5jb21waWxlZCA9IHRydWU7XG4gIH1cblxuICBfZ2V0QmxvY2tzKHByb3BzKSB7XG4gICAgdmFyIGJsb2NrcyA9IHt9O1xuXG4gICAgbGliLmtleXMocHJvcHMpLmZvckVhY2goKGspID0+IHtcbiAgICAgIGlmIChrLnNsaWNlKDAsIDIpID09PSAnYl8nKSB7XG4gICAgICAgIGJsb2Nrc1trLnNsaWNlKDIpXSA9IHByb3BzW2tdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJsb2NrcztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRW52aXJvbm1lbnQ6IEVudmlyb25tZW50LFxuICBUZW1wbGF0ZTogVGVtcGxhdGVcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9udW5qdWNrcy9zcmMvZW52aXJvbm1lbnQuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBsZXhlciA9IHJlcXVpcmUoJy4vbGV4ZXInKTtcbnZhciBub2RlcyA9IHJlcXVpcmUoJy4vbm9kZXMnKTtcbnZhciBPYmogPSByZXF1aXJlKCcuL29iamVjdCcpLk9iajtcbnZhciBsaWIgPSByZXF1aXJlKCcuL2xpYicpO1xuXG5jbGFzcyBQYXJzZXIgZXh0ZW5kcyBPYmoge1xuICBpbml0KHRva2Vucykge1xuICAgIHRoaXMudG9rZW5zID0gdG9rZW5zO1xuICAgIHRoaXMucGVla2VkID0gbnVsbDtcbiAgICB0aGlzLmJyZWFrT25CbG9ja3MgPSBudWxsO1xuICAgIHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlID0gZmFsc2U7XG5cbiAgICB0aGlzLmV4dGVuc2lvbnMgPSBbXTtcbiAgfVxuXG4gIG5leHRUb2tlbih3aXRoV2hpdGVzcGFjZSkge1xuICAgIHZhciB0b2s7XG5cbiAgICBpZiAodGhpcy5wZWVrZWQpIHtcbiAgICAgIGlmICghd2l0aFdoaXRlc3BhY2UgJiYgdGhpcy5wZWVrZWQudHlwZSA9PT0gbGV4ZXIuVE9LRU5fV0hJVEVTUEFDRSkge1xuICAgICAgICB0aGlzLnBlZWtlZCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b2sgPSB0aGlzLnBlZWtlZDtcbiAgICAgICAgdGhpcy5wZWVrZWQgPSBudWxsO1xuICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRvayA9IHRoaXMudG9rZW5zLm5leHRUb2tlbigpO1xuXG4gICAgaWYgKCF3aXRoV2hpdGVzcGFjZSkge1xuICAgICAgd2hpbGUgKHRvayAmJiB0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fV0hJVEVTUEFDRSkge1xuICAgICAgICB0b2sgPSB0aGlzLnRva2Vucy5uZXh0VG9rZW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9rO1xuICB9XG5cbiAgcGVla1Rva2VuKCkge1xuICAgIHRoaXMucGVla2VkID0gdGhpcy5wZWVrZWQgfHwgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICByZXR1cm4gdGhpcy5wZWVrZWQ7XG4gIH1cblxuICBwdXNoVG9rZW4odG9rKSB7XG4gICAgaWYgKHRoaXMucGVla2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B1c2hUb2tlbjogY2FuIG9ubHkgcHVzaCBvbmUgdG9rZW4gb24gYmV0d2VlbiByZWFkcycpO1xuICAgIH1cbiAgICB0aGlzLnBlZWtlZCA9IHRvaztcbiAgfVxuXG4gIGVycm9yKG1zZywgbGluZW5vLCBjb2xubykge1xuICAgIGlmIChsaW5lbm8gPT09IHVuZGVmaW5lZCB8fCBjb2xubyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB0b2sgPSB0aGlzLnBlZWtUb2tlbigpIHx8IHt9O1xuICAgICAgbGluZW5vID0gdG9rLmxpbmVubztcbiAgICAgIGNvbG5vID0gdG9rLmNvbG5vO1xuICAgIH1cbiAgICBpZiAobGluZW5vICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxpbmVubyArPSAxO1xuICAgIH1cbiAgICBpZiAoY29sbm8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29sbm8gKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBsaWIuVGVtcGxhdGVFcnJvcihtc2csIGxpbmVubywgY29sbm8pO1xuICB9XG5cbiAgZmFpbChtc2csIGxpbmVubywgY29sbm8pIHtcbiAgICB0aHJvdyB0aGlzLmVycm9yKG1zZywgbGluZW5vLCBjb2xubyk7XG4gIH1cblxuICBza2lwKHR5cGUpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICBpZiAoIXRvayB8fCB0b2sudHlwZSAhPT0gdHlwZSkge1xuICAgICAgdGhpcy5wdXNoVG9rZW4odG9rKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBleHBlY3QodHlwZSkge1xuICAgIHZhciB0b2sgPSB0aGlzLm5leHRUb2tlbigpO1xuICAgIGlmICh0b2sudHlwZSAhPT0gdHlwZSkge1xuICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCAnICsgdHlwZSArICcsIGdvdCAnICsgdG9rLnR5cGUsXG4gICAgICAgIHRvay5saW5lbm8sXG4gICAgICAgIHRvay5jb2xubyk7XG4gICAgfVxuICAgIHJldHVybiB0b2s7XG4gIH1cblxuICBza2lwVmFsdWUodHlwZSwgdmFsKSB7XG4gICAgdmFyIHRvayA9IHRoaXMubmV4dFRva2VuKCk7XG4gICAgaWYgKCF0b2sgfHwgdG9rLnR5cGUgIT09IHR5cGUgfHwgdG9rLnZhbHVlICE9PSB2YWwpIHtcbiAgICAgIHRoaXMucHVzaFRva2VuKHRvayk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc2tpcFN5bWJvbCh2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fU1lNQk9MLCB2YWwpO1xuICB9XG5cbiAgYWR2YW5jZUFmdGVyQmxvY2tFbmQobmFtZSkge1xuICAgIHZhciB0b2s7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgICBpZiAoIXRvaykge1xuICAgICAgICB0aGlzLmZhaWwoJ3VuZXhwZWN0ZWQgZW5kIG9mIGZpbGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvay50eXBlICE9PSBsZXhlci5UT0tFTl9TWU1CT0wpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdhZHZhbmNlQWZ0ZXJCbG9ja0VuZDogZXhwZWN0ZWQgc3ltYm9sIHRva2VuIG9yICcgK1xuICAgICAgICAgICdleHBsaWNpdCBuYW1lIHRvIGJlIHBhc3NlZCcpO1xuICAgICAgfVxuXG4gICAgICBuYW1lID0gdGhpcy5uZXh0VG9rZW4oKS52YWx1ZTtcbiAgICB9XG5cbiAgICB0b2sgPSB0aGlzLm5leHRUb2tlbigpO1xuXG4gICAgaWYgKHRvayAmJiB0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fQkxPQ0tfRU5EKSB7XG4gICAgICBpZiAodG9rLnZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgIHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCBibG9jayBlbmQgaW4gJyArIG5hbWUgKyAnIHN0YXRlbWVudCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0b2s7XG4gIH1cblxuICBhZHZhbmNlQWZ0ZXJWYXJpYWJsZUVuZCgpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcblxuICAgIGlmICh0b2sgJiYgdG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX1ZBUklBQkxFX0VORCkge1xuICAgICAgdGhpcy5kcm9wTGVhZGluZ1doaXRlc3BhY2UgPSB0b2sudmFsdWUuY2hhckF0KFxuICAgICAgICB0b2sudmFsdWUubGVuZ3RoIC0gdGhpcy50b2tlbnMudGFncy5WQVJJQUJMRV9FTkQubGVuZ3RoIC0gMVxuICAgICAgKSA9PT0gJy0nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnB1c2hUb2tlbih0b2spO1xuICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCB2YXJpYWJsZSBlbmQnKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUZvcigpIHtcbiAgICB2YXIgZm9yVG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgZW5kQmxvY2s7XG5cbiAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdmb3InKSkge1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Gb3IoZm9yVG9rLmxpbmVubywgZm9yVG9rLmNvbG5vKTtcbiAgICAgIGVuZEJsb2NrID0gJ2VuZGZvcic7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNraXBTeW1ib2woJ2FzeW5jRWFjaCcpKSB7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLkFzeW5jRWFjaChmb3JUb2subGluZW5vLCBmb3JUb2suY29sbm8pO1xuICAgICAgZW5kQmxvY2sgPSAnZW5kZWFjaCc7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNraXBTeW1ib2woJ2FzeW5jQWxsJykpIHtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuQXN5bmNBbGwoZm9yVG9rLmxpbmVubywgZm9yVG9rLmNvbG5vKTtcbiAgICAgIGVuZEJsb2NrID0gJ2VuZGFsbCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VGb3I6IGV4cGVjdGVkIGZvcntBc3luY30nLCBmb3JUb2subGluZW5vLCBmb3JUb2suY29sbm8pO1xuICAgIH1cblxuICAgIG5vZGUubmFtZSA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG5cbiAgICBpZiAoIShub2RlLm5hbWUgaW5zdGFuY2VvZiBub2Rlcy5TeW1ib2wpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlRm9yOiB2YXJpYWJsZSBuYW1lIGV4cGVjdGVkIGZvciBsb29wJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IHRoaXMucGVla1Rva2VuKCkudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gbGV4ZXIuVE9LRU5fQ09NTUEpIHtcbiAgICAgIC8vIGtleS92YWx1ZSBpdGVyYXRpb25cbiAgICAgIGNvbnN0IGtleSA9IG5vZGUubmFtZTtcbiAgICAgIG5vZGUubmFtZSA9IG5ldyBub2Rlcy5BcnJheShrZXkubGluZW5vLCBrZXkuY29sbm8pO1xuICAgICAgbm9kZS5uYW1lLmFkZENoaWxkKGtleSk7XG5cbiAgICAgIHdoaWxlICh0aGlzLnNraXAobGV4ZXIuVE9LRU5fQ09NTUEpKSB7XG4gICAgICAgIGNvbnN0IHByaW0gPSB0aGlzLnBhcnNlUHJpbWFyeSgpO1xuICAgICAgICBub2RlLm5hbWUuYWRkQ2hpbGQocHJpbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ2luJykpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VGb3I6IGV4cGVjdGVkIFwiaW5cIiBrZXl3b3JkIGZvciBsb29wJyxcbiAgICAgICAgZm9yVG9rLmxpbmVubyxcbiAgICAgICAgZm9yVG9rLmNvbG5vKTtcbiAgICB9XG5cbiAgICBub2RlLmFyciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZChmb3JUb2sudmFsdWUpO1xuXG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVVudGlsQmxvY2tzKGVuZEJsb2NrLCAnZWxzZScpO1xuXG4gICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnZWxzZScpKSB7XG4gICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCdlbHNlJyk7XG4gICAgICBub2RlLmVsc2VfID0gdGhpcy5wYXJzZVVudGlsQmxvY2tzKGVuZEJsb2NrKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlTWFjcm8oKSB7XG4gICAgY29uc3QgbWFjcm9Ub2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdtYWNybycpKSB7XG4gICAgICB0aGlzLmZhaWwoJ2V4cGVjdGVkIG1hY3JvJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VQcmltYXJ5KHRydWUpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnBhcnNlU2lnbmF0dXJlKCk7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBub2Rlcy5NYWNybyhtYWNyb1Rvay5saW5lbm8sIG1hY3JvVG9rLmNvbG5vLCBuYW1lLCBhcmdzKTtcblxuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQobWFjcm9Ub2sudmFsdWUpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VVbnRpbEJsb2NrcygnZW5kbWFjcm8nKTtcbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlQ2FsbCgpIHtcbiAgICAvLyBhIGNhbGwgYmxvY2sgaXMgcGFyc2VkIGFzIGEgbm9ybWFsIEZ1bkNhbGwsIGJ1dCB3aXRoIGFuIGFkZGVkXG4gICAgLy8gJ2NhbGxlcicga3dhcmcgd2hpY2ggaXMgYSBDYWxsZXIgbm9kZS5cbiAgICB2YXIgY2FsbFRvayA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ2NhbGwnKSkge1xuICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCBjYWxsJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY2FsbGVyQXJncyA9IHRoaXMucGFyc2VTaWduYXR1cmUodHJ1ZSkgfHwgbmV3IG5vZGVzLk5vZGVMaXN0KCk7XG4gICAgY29uc3QgbWFjcm9DYWxsID0gdGhpcy5wYXJzZVByaW1hcnkoKTtcblxuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoY2FsbFRvay52YWx1ZSk7XG4gICAgY29uc3QgYm9keSA9IHRoaXMucGFyc2VVbnRpbEJsb2NrcygnZW5kY2FsbCcpO1xuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcblxuICAgIGNvbnN0IGNhbGxlck5hbWUgPSBuZXcgbm9kZXMuU3ltYm9sKGNhbGxUb2subGluZW5vLFxuICAgICAgY2FsbFRvay5jb2xubyxcbiAgICAgICdjYWxsZXInKTtcbiAgICBjb25zdCBjYWxsZXJOb2RlID0gbmV3IG5vZGVzLkNhbGxlcihjYWxsVG9rLmxpbmVubyxcbiAgICAgIGNhbGxUb2suY29sbm8sXG4gICAgICBjYWxsZXJOYW1lLFxuICAgICAgY2FsbGVyQXJncyxcbiAgICAgIGJvZHkpO1xuXG4gICAgLy8gYWRkIHRoZSBhZGRpdGlvbmFsIGNhbGxlciBrd2FyZywgYWRkaW5nIGt3YXJncyBpZiBuZWNlc3NhcnlcbiAgICBjb25zdCBhcmdzID0gbWFjcm9DYWxsLmFyZ3MuY2hpbGRyZW47XG4gICAgaWYgKCEoYXJnc1thcmdzLmxlbmd0aCAtIDFdIGluc3RhbmNlb2Ygbm9kZXMuS2V5d29yZEFyZ3MpKSB7XG4gICAgICBhcmdzLnB1c2gobmV3IG5vZGVzLktleXdvcmRBcmdzKCkpO1xuICAgIH1cbiAgICBjb25zdCBrd2FyZ3MgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAga3dhcmdzLmFkZENoaWxkKG5ldyBub2Rlcy5QYWlyKGNhbGxUb2subGluZW5vLFxuICAgICAgY2FsbFRvay5jb2xubyxcbiAgICAgIGNhbGxlck5hbWUsXG4gICAgICBjYWxsZXJOb2RlKSk7XG5cbiAgICByZXR1cm4gbmV3IG5vZGVzLk91dHB1dChjYWxsVG9rLmxpbmVubyxcbiAgICAgIGNhbGxUb2suY29sbm8sXG4gICAgICBbbWFjcm9DYWxsXSk7XG4gIH1cblxuICBwYXJzZVdpdGhDb250ZXh0KCkge1xuICAgIHZhciB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgdmFyIHdpdGhDb250ZXh0ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLnNraXBTeW1ib2woJ3dpdGgnKSkge1xuICAgICAgd2l0aENvbnRleHQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5za2lwU3ltYm9sKCd3aXRob3V0JykpIHtcbiAgICAgIHdpdGhDb250ZXh0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHdpdGhDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnY29udGV4dCcpKSB7XG4gICAgICAgIHRoaXMuZmFpbCgncGFyc2VGcm9tOiBleHBlY3RlZCBjb250ZXh0IGFmdGVyIHdpdGgvd2l0aG91dCcsXG4gICAgICAgICAgdG9rLmxpbmVubyxcbiAgICAgICAgICB0b2suY29sbm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3aXRoQ29udGV4dDtcbiAgfVxuXG4gIHBhcnNlSW1wb3J0KCkge1xuICAgIHZhciBpbXBvcnRUb2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdpbXBvcnQnKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUltcG9ydDogZXhwZWN0ZWQgaW1wb3J0JyxcbiAgICAgICAgaW1wb3J0VG9rLmxpbmVubyxcbiAgICAgICAgaW1wb3J0VG9rLmNvbG5vKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnYXMnKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUltcG9ydDogZXhwZWN0ZWQgXCJhc1wiIGtleXdvcmQnLFxuICAgICAgICBpbXBvcnRUb2subGluZW5vLFxuICAgICAgICBpbXBvcnRUb2suY29sbm8pO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgY29uc3Qgd2l0aENvbnRleHQgPSB0aGlzLnBhcnNlV2l0aENvbnRleHQoKTtcbiAgICBjb25zdCBub2RlID0gbmV3IG5vZGVzLkltcG9ydChpbXBvcnRUb2subGluZW5vLFxuICAgICAgaW1wb3J0VG9rLmNvbG5vLFxuICAgICAgdGVtcGxhdGUsXG4gICAgICB0YXJnZXQsXG4gICAgICB3aXRoQ29udGV4dCk7XG5cbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKGltcG9ydFRvay52YWx1ZSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlRnJvbSgpIHtcbiAgICBjb25zdCBmcm9tVG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICBpZiAoIXRoaXMuc2tpcFN5bWJvbCgnZnJvbScpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlRnJvbTogZXhwZWN0ZWQgZnJvbScpO1xuICAgIH1cblxuICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblxuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdpbXBvcnQnKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUZyb206IGV4cGVjdGVkIGltcG9ydCcsXG4gICAgICAgIGZyb21Ub2subGluZW5vLFxuICAgICAgICBmcm9tVG9rLmNvbG5vKTtcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lcyA9IG5ldyBub2Rlcy5Ob2RlTGlzdCgpO1xuICAgIGxldCB3aXRoQ29udGV4dDtcblxuICAgIHdoaWxlICgxKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICBjb25zdCBuZXh0VG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICAgIGlmIChuZXh0VG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0JMT0NLX0VORCkge1xuICAgICAgICBpZiAoIW5hbWVzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZmFpbCgncGFyc2VGcm9tOiBFeHBlY3RlZCBhdCBsZWFzdCBvbmUgaW1wb3J0IG5hbWUnLFxuICAgICAgICAgICAgZnJvbVRvay5saW5lbm8sXG4gICAgICAgICAgICBmcm9tVG9rLmNvbG5vKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmNlIHdlIGFyZSBtYW51YWxseSBhZHZhbmNpbmcgcGFzdCB0aGUgYmxvY2sgZW5kLFxuICAgICAgICAvLyBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygd2hpdGVzcGFjZSBjb250cm9sIChub3JtYWxseVxuICAgICAgICAvLyB0aGlzIGlzIGRvbmUgaW4gYGFkdmFuY2VBZnRlckJsb2NrRW5kYFxuICAgICAgICBpZiAobmV4dFRvay52YWx1ZS5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgIHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZXMuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAhdGhpcy5za2lwKGxleGVyLlRPS0VOX0NPTU1BKSkge1xuICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlRnJvbTogZXhwZWN0ZWQgY29tbWEnLFxuICAgICAgICAgIGZyb21Ub2subGluZW5vLFxuICAgICAgICAgIGZyb21Ub2suY29sbm8pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZVByaW1hcnkoKTtcbiAgICAgIGlmIChuYW1lLnZhbHVlLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgIHRoaXMuZmFpbCgncGFyc2VGcm9tOiBuYW1lcyBzdGFydGluZyB3aXRoIGFuIHVuZGVyc2NvcmUgY2Fubm90IGJlIGltcG9ydGVkJyxcbiAgICAgICAgICBuYW1lLmxpbmVubyxcbiAgICAgICAgICBuYW1lLmNvbG5vKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnYXMnKSkge1xuICAgICAgICBjb25zdCBhbGlhcyA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgICAgIG5hbWVzLmFkZENoaWxkKG5ldyBub2Rlcy5QYWlyKG5hbWUubGluZW5vLFxuICAgICAgICAgIG5hbWUuY29sbm8sXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBhbGlhcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZXMuYWRkQ2hpbGQobmFtZSk7XG4gICAgICB9XG5cbiAgICAgIHdpdGhDb250ZXh0ID0gdGhpcy5wYXJzZVdpdGhDb250ZXh0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBub2Rlcy5Gcm9tSW1wb3J0KGZyb21Ub2subGluZW5vLFxuICAgICAgZnJvbVRvay5jb2xubyxcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgbmFtZXMsXG4gICAgICB3aXRoQ29udGV4dCk7XG4gIH1cblxuICBwYXJzZUJsb2NrKCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ2Jsb2NrJykpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VCbG9jazogZXhwZWN0ZWQgYmxvY2snLCB0YWcubGluZW5vLCB0YWcuY29sbm8pO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBuZXcgbm9kZXMuQmxvY2sodGFnLmxpbmVubywgdGFnLmNvbG5vKTtcblxuICAgIG5vZGUubmFtZSA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgaWYgKCEobm9kZS5uYW1lIGluc3RhbmNlb2Ygbm9kZXMuU3ltYm9sKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUJsb2NrOiB2YXJpYWJsZSBuYW1lIGV4cGVjdGVkJyxcbiAgICAgICAgdGFnLmxpbmVubyxcbiAgICAgICAgdGFnLmNvbG5vKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKHRhZy52YWx1ZSk7XG5cbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlVW50aWxCbG9ja3MoJ2VuZGJsb2NrJyk7XG4gICAgdGhpcy5za2lwU3ltYm9sKCdlbmRibG9jaycpO1xuICAgIHRoaXMuc2tpcFN5bWJvbChub2RlLm5hbWUudmFsdWUpO1xuXG4gICAgY29uc3QgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICBpZiAoIXRvaykge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUJsb2NrOiBleHBlY3RlZCBlbmRibG9jaywgZ290IGVuZCBvZiBmaWxlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCh0b2sudmFsdWUpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZUV4dGVuZHMoKSB7XG4gICAgY29uc3QgdGFnTmFtZSA9ICdleHRlbmRzJztcbiAgICBjb25zdCB0YWcgPSB0aGlzLnBlZWtUb2tlbigpO1xuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKHRhZ05hbWUpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlVGVtcGxhdGVSZWY6IGV4cGVjdGVkICcgKyB0YWdOYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gbmV3IG5vZGVzLkV4dGVuZHModGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICBub2RlLnRlbXBsYXRlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcblxuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQodGFnLnZhbHVlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlSW5jbHVkZSgpIHtcbiAgICBjb25zdCB0YWdOYW1lID0gJ2luY2x1ZGUnO1xuICAgIGNvbnN0IHRhZyA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2wodGFnTmFtZSkpIHtcbiAgICAgIHRoaXMuZmFpbCgncGFyc2VJbmNsdWRlOiBleHBlY3RlZCAnICsgdGFnTmFtZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBub2Rlcy5JbmNsdWRlKHRhZy5saW5lbm8sIHRhZy5jb2xubyk7XG4gICAgbm9kZS50ZW1wbGF0ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdpZ25vcmUnKSAmJiB0aGlzLnNraXBTeW1ib2woJ21pc3NpbmcnKSkge1xuICAgICAgbm9kZS5pZ25vcmVNaXNzaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKHRhZy52YWx1ZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZUlmKCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgbGV0IG5vZGU7XG5cbiAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdpZicpIHx8IHRoaXMuc2tpcFN5bWJvbCgnZWxpZicpIHx8IHRoaXMuc2tpcFN5bWJvbCgnZWxzZWlmJykpIHtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuSWYodGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2tpcFN5bWJvbCgnaWZBc3luYycpKSB7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLklmQXN5bmModGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZUlmOiBleHBlY3RlZCBpZiwgZWxpZiwgb3IgZWxzZWlmJyxcbiAgICAgICAgdGFnLmxpbmVubyxcbiAgICAgICAgdGFnLmNvbG5vKTtcbiAgICB9XG5cbiAgICBub2RlLmNvbmQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQodGFnLnZhbHVlKTtcblxuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VVbnRpbEJsb2NrcygnZWxpZicsICdlbHNlaWYnLCAnZWxzZScsICdlbmRpZicpO1xuICAgIGNvbnN0IHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICBzd2l0Y2ggKHRvayAmJiB0b2sudmFsdWUpIHtcbiAgICAgIGNhc2UgJ2Vsc2VpZic6XG4gICAgICBjYXNlICdlbGlmJzpcbiAgICAgICAgbm9kZS5lbHNlXyA9IHRoaXMucGFyc2VJZigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2Vsc2UnOlxuICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgICAgIG5vZGUuZWxzZV8gPSB0aGlzLnBhcnNlVW50aWxCbG9ja3MoJ2VuZGlmJyk7XG4gICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdlbmRpZic6XG4gICAgICAgIG5vZGUuZWxzZV8gPSBudWxsO1xuICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5mYWlsKCdwYXJzZUlmOiBleHBlY3RlZCBlbGlmLCBlbHNlLCBvciBlbmRpZiwgZ290IGVuZCBvZiBmaWxlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZVNldCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnBlZWtUb2tlbigpO1xuICAgIGlmICghdGhpcy5za2lwU3ltYm9sKCdzZXQnKSkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZVNldDogZXhwZWN0ZWQgc2V0JywgdGFnLmxpbmVubywgdGFnLmNvbG5vKTtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gbmV3IG5vZGVzLlNldCh0YWcubGluZW5vLCB0YWcuY29sbm8sIFtdKTtcblxuICAgIGxldCB0YXJnZXQ7XG4gICAgd2hpbGUgKCh0YXJnZXQgPSB0aGlzLnBhcnNlUHJpbWFyeSgpKSkge1xuICAgICAgbm9kZS50YXJnZXRzLnB1c2godGFyZ2V0KTtcblxuICAgICAgaWYgKCF0aGlzLnNraXAobGV4ZXIuVE9LRU5fQ09NTUEpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICc9JykpIHtcbiAgICAgIGlmICghdGhpcy5za2lwKGxleGVyLlRPS0VOX0JMT0NLX0VORCkpIHtcbiAgICAgICAgdGhpcy5mYWlsKCdwYXJzZVNldDogZXhwZWN0ZWQgPSBvciBibG9jayBlbmQgaW4gc2V0IHRhZycsXG4gICAgICAgICAgdGFnLmxpbmVubyxcbiAgICAgICAgICB0YWcuY29sbm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5ib2R5ID0gbmV3IG5vZGVzLkNhcHR1cmUoXG4gICAgICAgICAgdGFnLmxpbmVubyxcbiAgICAgICAgICB0YWcuY29sbm8sXG4gICAgICAgICAgdGhpcy5wYXJzZVVudGlsQmxvY2tzKCdlbmRzZXQnKVxuICAgICAgICApO1xuICAgICAgICBub2RlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQodGFnLnZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlU3dpdGNoKCkge1xuICAgIC8qXG4gICAgICogU3RvcmUgdGhlIHRhZyBuYW1lcyBpbiB2YXJpYWJsZXMgaW4gY2FzZSBzb21lb25lIGV2ZXIgd2FudHMgdG9cbiAgICAgKiBjdXN0b21pemUgdGhpcy5cbiAgICAgKi9cbiAgICBjb25zdCBzd2l0Y2hTdGFydCA9ICdzd2l0Y2gnO1xuICAgIGNvbnN0IHN3aXRjaEVuZCA9ICdlbmRzd2l0Y2gnO1xuICAgIGNvbnN0IGNhc2VTdGFydCA9ICdjYXNlJztcbiAgICBjb25zdCBjYXNlRGVmYXVsdCA9ICdkZWZhdWx0JztcblxuICAgIC8vIEdldCB0aGUgc3dpdGNoIHRhZy5cbiAgICBjb25zdCB0YWcgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgLy8gZmFpbCBlYXJseSBpZiB3ZSBnZXQgc29tZSB1bmV4cGVjdGVkIHRhZy5cbiAgICBpZiAoXG4gICAgICAhdGhpcy5za2lwU3ltYm9sKHN3aXRjaFN0YXJ0KVxuICAgICAgJiYgIXRoaXMuc2tpcFN5bWJvbChjYXNlU3RhcnQpXG4gICAgICAmJiAhdGhpcy5za2lwU3ltYm9sKGNhc2VEZWZhdWx0KVxuICAgICkge1xuICAgICAgdGhpcy5mYWlsKCdwYXJzZVN3aXRjaDogZXhwZWN0ZWQgXCJzd2l0Y2gsXCIgXCJjYXNlXCIgb3IgXCJkZWZhdWx0XCInLCB0YWcubGluZW5vLCB0YWcuY29sbm8pO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIHRoZSBzd2l0Y2ggZXhwcmVzc2lvblxuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgLy8gYWR2YW5jZSB1bnRpbCBhIHN0YXJ0IG9mIGEgY2FzZSwgYSBkZWZhdWx0IGNhc2Ugb3IgYW4gZW5kc3dpdGNoLlxuICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoc3dpdGNoU3RhcnQpO1xuICAgIHRoaXMucGFyc2VVbnRpbEJsb2NrcyhjYXNlU3RhcnQsIGNhc2VEZWZhdWx0LCBzd2l0Y2hFbmQpO1xuXG4gICAgLy8gdGhpcyBpcyB0aGUgZmlyc3QgY2FzZS4gaXQgY291bGQgYWxzbyBiZSBhbiBlbmRzd2l0Y2gsIHdlJ2xsIGNoZWNrLlxuICAgIGxldCB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuXG4gICAgLy8gY3JlYXRlIG5ldyB2YXJpYWJsZXMgZm9yIG91ciBjYXNlcyBhbmQgZGVmYXVsdCBjYXNlLlxuICAgIGNvbnN0IGNhc2VzID0gW107XG4gICAgbGV0IGRlZmF1bHRDYXNlO1xuXG4gICAgLy8gd2hpbGUgd2UncmUgZGVhbGluZyB3aXRoIG5ldyBjYXNlcyBub2Rlcy4uLlxuICAgIGRvIHtcbiAgICAgIC8vIHNraXAgdGhlIHN0YXJ0IHN5bWJvbCBhbmQgZ2V0IHRoZSBjYXNlIGV4cHJlc3Npb25cbiAgICAgIHRoaXMuc2tpcFN5bWJvbChjYXNlU3RhcnQpO1xuICAgICAgY29uc3QgY29uZCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKHN3aXRjaFN0YXJ0KTtcbiAgICAgIC8vIGdldCB0aGUgYm9keSBvZiB0aGUgY2FzZSBub2RlIGFuZCBhZGQgaXQgdG8gdGhlIGFycmF5IG9mIGNhc2VzLlxuICAgICAgY29uc3QgYm9keSA9IHRoaXMucGFyc2VVbnRpbEJsb2NrcyhjYXNlU3RhcnQsIGNhc2VEZWZhdWx0LCBzd2l0Y2hFbmQpO1xuICAgICAgY2FzZXMucHVzaChuZXcgbm9kZXMuQ2FzZSh0b2subGluZSwgdG9rLmNvbCwgY29uZCwgYm9keSkpO1xuICAgICAgLy8gZ2V0IG91ciBuZXh0IGNhc2VcbiAgICAgIHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgfSB3aGlsZSAodG9rICYmIHRvay52YWx1ZSA9PT0gY2FzZVN0YXJ0KTtcblxuICAgIC8vIHdlIGVpdGhlciBoYXZlIGEgZGVmYXVsdCBjYXNlIG9yIGEgc3dpdGNoIGVuZC5cbiAgICBzd2l0Y2ggKHRvay52YWx1ZSkge1xuICAgICAgY2FzZSBjYXNlRGVmYXVsdDpcbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuICAgICAgICBkZWZhdWx0Q2FzZSA9IHRoaXMucGFyc2VVbnRpbEJsb2Nrcyhzd2l0Y2hFbmQpO1xuICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzd2l0Y2hFbmQ6XG4gICAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQmxvY2tFbmQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBvdGhlcndpc2UgYmFpbCBiZWNhdXNlIEVPRlxuICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlU3dpdGNoOiBleHBlY3RlZCBcImNhc2UsXCIgXCJkZWZhdWx0XCIgb3IgXCJlbmRzd2l0Y2gsXCIgZ290IEVPRi4nKTtcbiAgICB9XG5cbiAgICAvLyBhbmQgcmV0dXJuIHRoZSBzd2l0Y2ggbm9kZS5cbiAgICByZXR1cm4gbmV3IG5vZGVzLlN3aXRjaCh0YWcubGluZW5vLCB0YWcuY29sbm8sIGV4cHIsIGNhc2VzLCBkZWZhdWx0Q2FzZSk7XG4gIH1cblxuICBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICB2YXIgbm9kZTtcblxuICAgIGlmICh0b2sudHlwZSAhPT0gbGV4ZXIuVE9LRU5fU1lNQk9MKSB7XG4gICAgICB0aGlzLmZhaWwoJ3RhZyBuYW1lIGV4cGVjdGVkJywgdG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5icmVha09uQmxvY2tzICYmXG4gICAgICBsaWIuaW5kZXhPZih0aGlzLmJyZWFrT25CbG9ja3MsIHRvay52YWx1ZSkgIT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRvay52YWx1ZSkge1xuICAgICAgY2FzZSAncmF3JzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSYXcoKTtcbiAgICAgIGNhc2UgJ3ZlcmJhdGltJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSYXcoJ3ZlcmJhdGltJyk7XG4gICAgICBjYXNlICdpZic6XG4gICAgICBjYXNlICdpZkFzeW5jJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJZigpO1xuICAgICAgY2FzZSAnZm9yJzpcbiAgICAgIGNhc2UgJ2FzeW5jRWFjaCc6XG4gICAgICBjYXNlICdhc3luY0FsbCc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKCk7XG4gICAgICBjYXNlICdibG9jayc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmxvY2soKTtcbiAgICAgIGNhc2UgJ2V4dGVuZHMnOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4dGVuZHMoKTtcbiAgICAgIGNhc2UgJ2luY2x1ZGUnOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUluY2x1ZGUoKTtcbiAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2V0KCk7XG4gICAgICBjYXNlICdtYWNybyc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTWFjcm8oKTtcbiAgICAgIGNhc2UgJ2NhbGwnOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNhbGwoKTtcbiAgICAgIGNhc2UgJ2ltcG9ydCc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0KCk7XG4gICAgICBjYXNlICdmcm9tJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGcm9tKCk7XG4gICAgICBjYXNlICdmaWx0ZXInOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZpbHRlclN0YXRlbWVudCgpO1xuICAgICAgY2FzZSAnc3dpdGNoJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2goKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0aGlzLmV4dGVuc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmV4dGVuc2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dCA9IHRoaXMuZXh0ZW5zaW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChsaWIuaW5kZXhPZihleHQudGFncyB8fCBbXSwgdG9rLnZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4dC5wYXJzZSh0aGlzLCBub2RlcywgbGV4ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZhaWwoJ3Vua25vd24gYmxvY2sgdGFnOiAnICsgdG9rLnZhbHVlLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VSYXcodGFnTmFtZSkge1xuICAgIHRhZ05hbWUgPSB0YWdOYW1lIHx8ICdyYXcnO1xuICAgIGNvbnN0IGVuZFRhZ05hbWUgPSAnZW5kJyArIHRhZ05hbWU7XG4gICAgLy8gTG9vayBmb3IgdXBjb21pbmcgcmF3IGJsb2NrcyAoaWdub3JlIGFsbCBvdGhlciBraW5kcyBvZiBibG9ja3MpXG4gICAgY29uc3QgcmF3QmxvY2tSZWdleCA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPyl7JVxcXFxzKignICsgdGFnTmFtZSArICd8JyArIGVuZFRhZ05hbWUgKyAnKVxcXFxzKig/PSV9KSV9Jyk7XG4gICAgbGV0IHJhd0xldmVsID0gMTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IG1hdGNoZXMgPSBudWxsO1xuXG4gICAgLy8gU2tpcCBvcGVuaW5nIHJhdyB0b2tlblxuICAgIC8vIEtlZXAgdGhpcyB0b2tlbiB0byB0cmFjayBsaW5lIGFuZCBjb2x1bW4gbnVtYmVyc1xuICAgIGNvbnN0IGJlZ3VuID0gdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuXG4gICAgLy8gRXhpdCB3aGVuIHRoZXJlJ3Mgbm90aGluZyB0byBtYXRjaFxuICAgIC8vIG9yIHdoZW4gd2UndmUgZm91bmQgdGhlIG1hdGNoaW5nIFwiZW5kcmF3XCIgYmxvY2tcbiAgICB3aGlsZSAoKG1hdGNoZXMgPSB0aGlzLnRva2Vucy5fZXh0cmFjdFJlZ2V4KHJhd0Jsb2NrUmVnZXgpKSAmJiByYXdMZXZlbCA+IDApIHtcbiAgICAgIGNvbnN0IGFsbCA9IG1hdGNoZXNbMF07XG4gICAgICBjb25zdCBwcmUgPSBtYXRjaGVzWzFdO1xuICAgICAgY29uc3QgYmxvY2tOYW1lID0gbWF0Y2hlc1syXTtcblxuICAgICAgLy8gQWRqdXN0IHJhd2xldmVsXG4gICAgICBpZiAoYmxvY2tOYW1lID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHJhd0xldmVsICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKGJsb2NrTmFtZSA9PT0gZW5kVGFnTmFtZSkge1xuICAgICAgICByYXdMZXZlbCAtPSAxO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdG8gc3RyXG4gICAgICBpZiAocmF3TGV2ZWwgPT09IDApIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBleGNsdWRlIHRoZSBsYXN0IFwiZW5kcmF3XCJcbiAgICAgICAgc3RyICs9IHByZTtcbiAgICAgICAgLy8gTW92ZSB0b2tlbml6ZXIgdG8gYmVnaW5uaW5nIG9mIGVuZHJhdyBibG9ja1xuICAgICAgICB0aGlzLnRva2Vucy5iYWNrTihhbGwubGVuZ3RoIC0gcHJlLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgKz0gYWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgbm9kZXMuT3V0cHV0KFxuICAgICAgYmVndW4ubGluZW5vLFxuICAgICAgYmVndW4uY29sbm8sXG4gICAgICBbbmV3IG5vZGVzLlRlbXBsYXRlRGF0YShiZWd1bi5saW5lbm8sIGJlZ3VuLmNvbG5vLCBzdHIpXVxuICAgICk7XG4gIH1cblxuICBwYXJzZVBvc3RmaXgobm9kZSkge1xuICAgIGxldCBsb29rdXA7XG4gICAgbGV0IHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG5cbiAgICB3aGlsZSAodG9rKSB7XG4gICAgICBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0xFRlRfUEFSRU4pIHtcbiAgICAgICAgLy8gRnVuY3Rpb24gY2FsbFxuICAgICAgICBub2RlID0gbmV3IG5vZGVzLkZ1bkNhbGwodG9rLmxpbmVubyxcbiAgICAgICAgICB0b2suY29sbm8sXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICB0aGlzLnBhcnNlU2lnbmF0dXJlKCkpO1xuICAgICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fTEVGVF9CUkFDS0VUKSB7XG4gICAgICAgIC8vIFJlZmVyZW5jZVxuICAgICAgICBsb29rdXAgPSB0aGlzLnBhcnNlQWdncmVnYXRlKCk7XG4gICAgICAgIGlmIChsb29rdXAuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMuZmFpbCgnaW52YWxpZCBpbmRleCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Mb29rdXBWYWwodG9rLmxpbmVubyxcbiAgICAgICAgICB0b2suY29sbm8sXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBsb29rdXAuY2hpbGRyZW5bMF0pO1xuICAgICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fT1BFUkFUT1IgJiYgdG9rLnZhbHVlID09PSAnLicpIHtcbiAgICAgICAgLy8gUmVmZXJlbmNlXG4gICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMubmV4dFRva2VuKCk7XG5cbiAgICAgICAgaWYgKHZhbC50eXBlICE9PSBsZXhlci5UT0tFTl9TWU1CT0wpIHtcbiAgICAgICAgICB0aGlzLmZhaWwoJ2V4cGVjdGVkIG5hbWUgYXMgbG9va3VwIHZhbHVlLCBnb3QgJyArIHZhbC52YWx1ZSxcbiAgICAgICAgICAgIHZhbC5saW5lbm8sXG4gICAgICAgICAgICB2YWwuY29sbm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBhIGxpdGVyYWwgc3RyaW5nIGJlY2F1c2UgaXQncyBub3QgYSB2YXJpYWJsZVxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgbG9va3VwID0gbmV3IG5vZGVzLkxpdGVyYWwodmFsLmxpbmVubyxcbiAgICAgICAgICB2YWwuY29sbm8sXG4gICAgICAgICAgdmFsLnZhbHVlKTtcblxuICAgICAgICBub2RlID0gbmV3IG5vZGVzLkxvb2t1cFZhbCh0b2subGluZW5vLFxuICAgICAgICAgIHRvay5jb2xubyxcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGxvb2t1cCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMucGFyc2VJbmxpbmVJZigpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VJbmxpbmVJZigpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMucGFyc2VPcigpO1xuICAgIGlmICh0aGlzLnNraXBTeW1ib2woJ2lmJykpIHtcbiAgICAgIGNvbnN0IGNvbmROb2RlID0gdGhpcy5wYXJzZU9yKCk7XG4gICAgICBjb25zdCBib2R5Tm9kZSA9IG5vZGU7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLklubGluZUlmKG5vZGUubGluZW5vLCBub2RlLmNvbG5vKTtcbiAgICAgIG5vZGUuYm9keSA9IGJvZHlOb2RlO1xuICAgICAgbm9kZS5jb25kID0gY29uZE5vZGU7XG4gICAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdlbHNlJykpIHtcbiAgICAgICAgbm9kZS5lbHNlXyA9IHRoaXMucGFyc2VPcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5lbHNlXyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZU9yKCkge1xuICAgIGxldCBub2RlID0gdGhpcy5wYXJzZUFuZCgpO1xuICAgIHdoaWxlICh0aGlzLnNraXBTeW1ib2woJ29yJykpIHtcbiAgICAgIGNvbnN0IG5vZGUyID0gdGhpcy5wYXJzZUFuZCgpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Pcihub2RlLmxpbmVubyxcbiAgICAgICAgbm9kZS5jb2xubyxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZTIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlQW5kKCkge1xuICAgIGxldCBub2RlID0gdGhpcy5wYXJzZU5vdCgpO1xuICAgIHdoaWxlICh0aGlzLnNraXBTeW1ib2woJ2FuZCcpKSB7XG4gICAgICBjb25zdCBub2RlMiA9IHRoaXMucGFyc2VOb3QoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuQW5kKG5vZGUubGluZW5vLFxuICAgICAgICBub2RlLmNvbG5vLFxuICAgICAgICBub2RlLFxuICAgICAgICBub2RlMik7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VOb3QoKSB7XG4gICAgY29uc3QgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdub3QnKSkge1xuICAgICAgcmV0dXJuIG5ldyBub2Rlcy5Ob3QodG9rLmxpbmVubyxcbiAgICAgICAgdG9rLmNvbG5vLFxuICAgICAgICB0aGlzLnBhcnNlTm90KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUluKCk7XG4gIH1cblxuICBwYXJzZUluKCkge1xuICAgIGxldCBub2RlID0gdGhpcy5wYXJzZUlzKCk7XG4gICAgd2hpbGUgKDEpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBuZXh0IHRva2VuIGlzICdub3QnXG4gICAgICBjb25zdCB0b2sgPSB0aGlzLm5leHRUb2tlbigpO1xuICAgICAgaWYgKCF0b2spIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBpbnZlcnQgPSB0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fU1lNQk9MICYmIHRvay52YWx1ZSA9PT0gJ25vdCc7XG4gICAgICAvLyBpZiBpdCB3YXNuJ3QgJ25vdCcsIHB1dCBpdCBiYWNrXG4gICAgICBpZiAoIWludmVydCkge1xuICAgICAgICB0aGlzLnB1c2hUb2tlbih0b2spO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2tpcFN5bWJvbCgnaW4nKSkge1xuICAgICAgICBjb25zdCBub2RlMiA9IHRoaXMucGFyc2VJcygpO1xuICAgICAgICBub2RlID0gbmV3IG5vZGVzLkluKG5vZGUubGluZW5vLFxuICAgICAgICAgIG5vZGUuY29sbm8sXG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBub2RlMik7XG4gICAgICAgIGlmIChpbnZlcnQpIHtcbiAgICAgICAgICBub2RlID0gbmV3IG5vZGVzLk5vdChub2RlLmxpbmVubyxcbiAgICAgICAgICAgIG5vZGUuY29sbm8sXG4gICAgICAgICAgICBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgd2UnZCBmb3VuZCBhICdub3QnIGJ1dCB0aGlzIHdhc24ndCBhbiAnaW4nLCBwdXQgYmFjayB0aGUgJ25vdCdcbiAgICAgICAgaWYgKGludmVydCkge1xuICAgICAgICAgIHRoaXMucHVzaFRva2VuKHRvayk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLy8gSSBwdXQgdGhpcyByaWdodCBhZnRlciBcImluXCIgaW4gdGhlIG9wZXJhdG9yIHByZWNlZGVuY2Ugc3RhY2suIFRoYXQgY2FuXG4gIC8vIG9idmlvdXNseSBiZSBjaGFuZ2VkIHRvIGJlIGNsb3NlciB0byBKaW5qYS5cbiAgcGFyc2VJcygpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMucGFyc2VDb21wYXJlKCk7XG4gICAgLy8gbG9vayBmb3IgYW4gaXNcbiAgICBpZiAodGhpcy5za2lwU3ltYm9sKCdpcycpKSB7XG4gICAgICAvLyBsb29rIGZvciBhIG5vdFxuICAgICAgY29uc3Qgbm90ID0gdGhpcy5za2lwU3ltYm9sKCdub3QnKTtcbiAgICAgIC8vIGdldCB0aGUgbmV4dCBub2RlXG4gICAgICBjb25zdCBub2RlMiA9IHRoaXMucGFyc2VDb21wYXJlKCk7XG4gICAgICAvLyBjcmVhdGUgYW4gSXMgbm9kZSB1c2luZyB0aGUgbmV4dCBub2RlIGFuZCB0aGUgaW5mbyBmcm9tIG91ciBJcyBub2RlLlxuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Jcyhub2RlLmxpbmVubywgbm9kZS5jb2xubywgbm9kZSwgbm9kZTIpO1xuICAgICAgLy8gaWYgd2UgaGF2ZSBhIE5vdCwgY3JlYXRlIGEgTm90IG5vZGUgZnJvbSBvdXIgSXMgbm9kZS5cbiAgICAgIGlmIChub3QpIHtcbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Ob3Qobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gdGhlIG5vZGUuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZUNvbXBhcmUoKSB7XG4gICAgY29uc3QgY29tcGFyZU9wcyA9IFsnPT0nLCAnPT09JywgJyE9JywgJyE9PScsICc8JywgJz4nLCAnPD0nLCAnPj0nXTtcbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZUNvbmNhdCgpO1xuICAgIGNvbnN0IG9wcyA9IFtdO1xuXG4gICAgd2hpbGUgKDEpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIGNvbnN0IHRvayA9IHRoaXMubmV4dFRva2VuKCk7XG5cbiAgICAgIGlmICghdG9rKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChjb21wYXJlT3BzLmluZGV4T2YodG9rLnZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgb3BzLnB1c2gobmV3IG5vZGVzLkNvbXBhcmVPcGVyYW5kKHRvay5saW5lbm8sXG4gICAgICAgICAgdG9rLmNvbG5vLFxuICAgICAgICAgIHRoaXMucGFyc2VDb25jYXQoKSxcbiAgICAgICAgICB0b2sudmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHVzaFRva2VuKHRvayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IG5vZGVzLkNvbXBhcmUob3BzWzBdLmxpbmVubyxcbiAgICAgICAgb3BzWzBdLmNvbG5vLFxuICAgICAgICBleHByLFxuICAgICAgICBvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gIH1cblxuICAvLyBmaW5kcyB0aGUgJ34nIGZvciBzdHJpbmcgY29uY2F0ZW5hdGlvblxuICBwYXJzZUNvbmNhdCgpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMucGFyc2VBZGQoKTtcbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fVElMREUsICd+JykpIHtcbiAgICAgIGNvbnN0IG5vZGUyID0gdGhpcy5wYXJzZUFkZCgpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Db25jYXQobm9kZS5saW5lbm8sXG4gICAgICAgIG5vZGUuY29sbm8sXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGUyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZUFkZCgpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMucGFyc2VTdWIoKTtcbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICcrJykpIHtcbiAgICAgIGNvbnN0IG5vZGUyID0gdGhpcy5wYXJzZVN1YigpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5BZGQobm9kZS5saW5lbm8sXG4gICAgICAgIG5vZGUuY29sbm8sXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGUyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZVN1YigpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMucGFyc2VNdWwoKTtcbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICctJykpIHtcbiAgICAgIGNvbnN0IG5vZGUyID0gdGhpcy5wYXJzZU11bCgpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5TdWIobm9kZS5saW5lbm8sXG4gICAgICAgIG5vZGUuY29sbm8sXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGUyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZU11bCgpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMucGFyc2VEaXYoKTtcbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICcqJykpIHtcbiAgICAgIGNvbnN0IG5vZGUyID0gdGhpcy5wYXJzZURpdigpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5NdWwobm9kZS5saW5lbm8sXG4gICAgICAgIG5vZGUuY29sbm8sXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGUyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZURpdigpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMucGFyc2VGbG9vckRpdigpO1xuICAgIHdoaWxlICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJy8nKSkge1xuICAgICAgY29uc3Qgbm9kZTIgPSB0aGlzLnBhcnNlRmxvb3JEaXYoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuRGl2KG5vZGUubGluZW5vLFxuICAgICAgICBub2RlLmNvbG5vLFxuICAgICAgICBub2RlLFxuICAgICAgICBub2RlMik7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VGbG9vckRpdigpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMucGFyc2VNb2QoKTtcbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICcvLycpKSB7XG4gICAgICBjb25zdCBub2RlMiA9IHRoaXMucGFyc2VNb2QoKTtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuRmxvb3JEaXYobm9kZS5saW5lbm8sXG4gICAgICAgIG5vZGUuY29sbm8sXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGUyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZU1vZCgpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMucGFyc2VQb3coKTtcbiAgICB3aGlsZSAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICclJykpIHtcbiAgICAgIGNvbnN0IG5vZGUyID0gdGhpcy5wYXJzZVBvdygpO1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Nb2Qobm9kZS5saW5lbm8sXG4gICAgICAgIG5vZGUuY29sbm8sXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGUyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBwYXJzZVBvdygpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMucGFyc2VVbmFyeSgpO1xuICAgIHdoaWxlICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJyoqJykpIHtcbiAgICAgIGNvbnN0IG5vZGUyID0gdGhpcy5wYXJzZVVuYXJ5KCk7XG4gICAgICBub2RlID0gbmV3IG5vZGVzLlBvdyhub2RlLmxpbmVubyxcbiAgICAgICAgbm9kZS5jb2xubyxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZTIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHBhcnNlVW5hcnkobm9GaWx0ZXJzKSB7XG4gICAgY29uc3QgdG9rID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICBsZXQgbm9kZTtcblxuICAgIGlmICh0aGlzLnNraXBWYWx1ZShsZXhlci5UT0tFTl9PUEVSQVRPUiwgJy0nKSkge1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5OZWcodG9rLmxpbmVubyxcbiAgICAgICAgdG9rLmNvbG5vLFxuICAgICAgICB0aGlzLnBhcnNlVW5hcnkodHJ1ZSkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5za2lwVmFsdWUobGV4ZXIuVE9LRU5fT1BFUkFUT1IsICcrJykpIHtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuUG9zKHRvay5saW5lbm8sXG4gICAgICAgIHRvay5jb2xubyxcbiAgICAgICAgdGhpcy5wYXJzZVVuYXJ5KHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IHRoaXMucGFyc2VQcmltYXJ5KCk7XG4gICAgfVxuXG4gICAgaWYgKCFub0ZpbHRlcnMpIHtcbiAgICAgIG5vZGUgPSB0aGlzLnBhcnNlRmlsdGVyKG5vZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VQcmltYXJ5KG5vUG9zdGZpeCkge1xuICAgIGNvbnN0IHRvayA9IHRoaXMubmV4dFRva2VuKCk7XG4gICAgbGV0IHZhbDtcbiAgICBsZXQgbm9kZSA9IG51bGw7XG5cbiAgICBpZiAoIXRvaykge1xuICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCBleHByZXNzaW9uLCBnb3QgZW5kIG9mIGZpbGUnKTtcbiAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9TVFJJTkcpIHtcbiAgICAgIHZhbCA9IHRvay52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9JTlQpIHtcbiAgICAgIHZhbCA9IHBhcnNlSW50KHRvay52YWx1ZSwgMTApO1xuICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX0ZMT0FUKSB7XG4gICAgICB2YWwgPSBwYXJzZUZsb2F0KHRvay52YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fQk9PTEVBTikge1xuICAgICAgaWYgKHRvay52YWx1ZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgIHZhbCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRvay52YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICB2YWwgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmFpbCgnaW52YWxpZCBib29sZWFuOiAnICsgdG9rLnZhbHVlLFxuICAgICAgICAgIHRvay5saW5lbm8sXG4gICAgICAgICAgdG9rLmNvbG5vKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9OT05FKSB7XG4gICAgICB2YWwgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAodG9rLnR5cGUgPT09IGxleGVyLlRPS0VOX1JFR0VYKSB7XG4gICAgICB2YWwgPSBuZXcgUmVnRXhwKHRvay52YWx1ZS5ib2R5LCB0b2sudmFsdWUuZmxhZ3MpO1xuICAgIH1cblxuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5MaXRlcmFsKHRvay5saW5lbm8sIHRvay5jb2xubywgdmFsKTtcbiAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9TWU1CT0wpIHtcbiAgICAgIG5vZGUgPSBuZXcgbm9kZXMuU3ltYm9sKHRvay5saW5lbm8sIHRvay5jb2xubywgdG9rLnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VlIGlmIGl0J3MgYW4gYWdncmVnYXRlIHR5cGUsIHdlIG5lZWQgdG8gcHVzaCB0aGVcbiAgICAgIC8vIGN1cnJlbnQgZGVsaW1pdGVyIHRva2VuIGJhY2sgb25cbiAgICAgIHRoaXMucHVzaFRva2VuKHRvayk7XG4gICAgICBub2RlID0gdGhpcy5wYXJzZUFnZ3JlZ2F0ZSgpO1xuICAgIH1cblxuICAgIGlmICghbm9Qb3N0Zml4KSB7XG4gICAgICBub2RlID0gdGhpcy5wYXJzZVBvc3RmaXgobm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyB0aGlzLmVycm9yKGB1bmV4cGVjdGVkIHRva2VuOiAke3Rvay52YWx1ZX1gLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlRmlsdGVyTmFtZSgpIHtcbiAgICBjb25zdCB0b2sgPSB0aGlzLmV4cGVjdChsZXhlci5UT0tFTl9TWU1CT0wpO1xuICAgIGxldCBuYW1lID0gdG9rLnZhbHVlO1xuXG4gICAgd2hpbGUgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnLicpKSB7XG4gICAgICBuYW1lICs9ICcuJyArIHRoaXMuZXhwZWN0KGxleGVyLlRPS0VOX1NZTUJPTCkudmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBub2Rlcy5TeW1ib2wodG9rLmxpbmVubywgdG9rLmNvbG5vLCBuYW1lKTtcbiAgfVxuXG4gIHBhcnNlRmlsdGVyQXJncyhub2RlKSB7XG4gICAgaWYgKHRoaXMucGVla1Rva2VuKCkudHlwZSA9PT0gbGV4ZXIuVE9LRU5fTEVGVF9QQVJFTikge1xuICAgICAgLy8gR2V0IGEgRnVuQ2FsbCBub2RlIGFuZCBhZGQgdGhlIHBhcmFtZXRlcnMgdG8gdGhlXG4gICAgICAvLyBmaWx0ZXJcbiAgICAgIGNvbnN0IGNhbGwgPSB0aGlzLnBhcnNlUG9zdGZpeChub2RlKTtcbiAgICAgIHJldHVybiBjYWxsLmFyZ3MuY2hpbGRyZW47XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHBhcnNlRmlsdGVyKG5vZGUpIHtcbiAgICB3aGlsZSAodGhpcy5za2lwKGxleGVyLlRPS0VOX1BJUEUpKSB7XG4gICAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZUZpbHRlck5hbWUoKTtcblxuICAgICAgbm9kZSA9IG5ldyBub2Rlcy5GaWx0ZXIoXG4gICAgICAgIG5hbWUubGluZW5vLFxuICAgICAgICBuYW1lLmNvbG5vLFxuICAgICAgICBuYW1lLFxuICAgICAgICBuZXcgbm9kZXMuTm9kZUxpc3QoXG4gICAgICAgICAgbmFtZS5saW5lbm8sXG4gICAgICAgICAgbmFtZS5jb2xubyxcbiAgICAgICAgICBbbm9kZV0uY29uY2F0KHRoaXMucGFyc2VGaWx0ZXJBcmdzKG5vZGUpKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VGaWx0ZXJTdGF0ZW1lbnQoKSB7XG4gICAgdmFyIGZpbHRlclRvayA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgaWYgKCF0aGlzLnNraXBTeW1ib2woJ2ZpbHRlcicpKSB7XG4gICAgICB0aGlzLmZhaWwoJ3BhcnNlRmlsdGVyU3RhdGVtZW50OiBleHBlY3RlZCBmaWx0ZXInKTtcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gdGhpcy5wYXJzZUZpbHRlck5hbWUoKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5wYXJzZUZpbHRlckFyZ3MobmFtZSk7XG5cbiAgICB0aGlzLmFkdmFuY2VBZnRlckJsb2NrRW5kKGZpbHRlclRvay52YWx1ZSk7XG4gICAgY29uc3QgYm9keSA9IG5ldyBub2Rlcy5DYXB0dXJlKFxuICAgICAgbmFtZS5saW5lbm8sXG4gICAgICBuYW1lLmNvbG5vLFxuICAgICAgdGhpcy5wYXJzZVVudGlsQmxvY2tzKCdlbmRmaWx0ZXInKVxuICAgICk7XG4gICAgdGhpcy5hZHZhbmNlQWZ0ZXJCbG9ja0VuZCgpO1xuXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBub2Rlcy5GaWx0ZXIoXG4gICAgICBuYW1lLmxpbmVubyxcbiAgICAgIG5hbWUuY29sbm8sXG4gICAgICBuYW1lLFxuICAgICAgbmV3IG5vZGVzLk5vZGVMaXN0KFxuICAgICAgICBuYW1lLmxpbmVubyxcbiAgICAgICAgbmFtZS5jb2xubyxcbiAgICAgICAgW2JvZHldLmNvbmNhdChhcmdzKVxuICAgICAgKVxuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IG5vZGVzLk91dHB1dChcbiAgICAgIG5hbWUubGluZW5vLFxuICAgICAgbmFtZS5jb2xubyxcbiAgICAgIFtub2RlXVxuICAgICk7XG4gIH1cblxuICBwYXJzZUFnZ3JlZ2F0ZSgpIHtcbiAgICB2YXIgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICB2YXIgbm9kZTtcblxuICAgIHN3aXRjaCAodG9rLnR5cGUpIHtcbiAgICAgIGNhc2UgbGV4ZXIuVE9LRU5fTEVGVF9QQVJFTjpcbiAgICAgICAgbm9kZSA9IG5ldyBub2Rlcy5Hcm91cCh0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbGV4ZXIuVE9LRU5fTEVGVF9CUkFDS0VUOlxuICAgICAgICBub2RlID0gbmV3IG5vZGVzLkFycmF5KHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBsZXhlci5UT0tFTl9MRUZUX0NVUkxZOlxuICAgICAgICBub2RlID0gbmV3IG5vZGVzLkRpY3QodG9rLmxpbmVubywgdG9rLmNvbG5vKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZSAoMSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgY29uc3QgdHlwZSA9IHRoaXMucGVla1Rva2VuKCkudHlwZTtcbiAgICAgIGlmICh0eXBlID09PSBsZXhlci5UT0tFTl9SSUdIVF9QQVJFTiB8fFxuICAgICAgICB0eXBlID09PSBsZXhlci5UT0tFTl9SSUdIVF9CUkFDS0VUIHx8XG4gICAgICAgIHR5cGUgPT09IGxleGVyLlRPS0VOX1JJR0hUX0NVUkxZKSB7XG4gICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICghdGhpcy5za2lwKGxleGVyLlRPS0VOX0NPTU1BKSkge1xuICAgICAgICAgIHRoaXMuZmFpbCgncGFyc2VBZ2dyZWdhdGU6IGV4cGVjdGVkIGNvbW1hIGFmdGVyIGV4cHJlc3Npb24nLFxuICAgICAgICAgICAgdG9rLmxpbmVubyxcbiAgICAgICAgICAgIHRvay5jb2xubyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5EaWN0KSB7XG4gICAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBlcnJvcnNcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5wYXJzZVByaW1hcnkoKTtcblxuICAgICAgICAvLyBXZSBleHBlY3QgYSBrZXkvdmFsdWUgcGFpciBmb3IgZGljdHMsIHNlcGFyYXRlZCBieSBhXG4gICAgICAgIC8vIGNvbG9uXG4gICAgICAgIGlmICghdGhpcy5za2lwKGxleGVyLlRPS0VOX0NPTE9OKSkge1xuICAgICAgICAgIHRoaXMuZmFpbCgncGFyc2VBZ2dyZWdhdGU6IGV4cGVjdGVkIGNvbG9uIGFmdGVyIGRpY3Qga2V5JyxcbiAgICAgICAgICAgIHRvay5saW5lbm8sXG4gICAgICAgICAgICB0b2suY29sbm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIGVycm9yc1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIG5vZGUuYWRkQ2hpbGQobmV3IG5vZGVzLlBhaXIoa2V5LmxpbmVubyxcbiAgICAgICAgICBrZXkuY29sbm8sXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBjaGVjayBmb3IgZXJyb3JzXG4gICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICBub2RlLmFkZENoaWxkKGV4cHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcGFyc2VTaWduYXR1cmUodG9sZXJhbnQsIG5vUGFyZW5zKSB7XG4gICAgbGV0IHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgaWYgKCFub1BhcmVucyAmJiB0b2sudHlwZSAhPT0gbGV4ZXIuVE9LRU5fTEVGVF9QQVJFTikge1xuICAgICAgaWYgKHRvbGVyYW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mYWlsKCdleHBlY3RlZCBhcmd1bWVudHMnLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fTEVGVF9QQVJFTikge1xuICAgICAgdG9rID0gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICB9XG5cbiAgICBjb25zdCBhcmdzID0gbmV3IG5vZGVzLk5vZGVMaXN0KHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgY29uc3Qga3dhcmdzID0gbmV3IG5vZGVzLktleXdvcmRBcmdzKHRvay5saW5lbm8sIHRvay5jb2xubyk7XG4gICAgbGV0IGNoZWNrQ29tbWEgPSBmYWxzZTtcblxuICAgIHdoaWxlICgxKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICB0b2sgPSB0aGlzLnBlZWtUb2tlbigpO1xuICAgICAgaWYgKCFub1BhcmVucyAmJiB0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fUklHSFRfUEFSRU4pIHtcbiAgICAgICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKG5vUGFyZW5zICYmIHRvay50eXBlID09PSBsZXhlci5UT0tFTl9CTE9DS19FTkQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0NvbW1hICYmICF0aGlzLnNraXAobGV4ZXIuVE9LRU5fQ09NTUEpKSB7XG4gICAgICAgIHRoaXMuZmFpbCgncGFyc2VTaWduYXR1cmU6IGV4cGVjdGVkIGNvbW1hIGFmdGVyIGV4cHJlc3Npb24nLFxuICAgICAgICAgIHRvay5saW5lbm8sXG4gICAgICAgICAgdG9rLmNvbG5vKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2tpcFZhbHVlKGxleGVyLlRPS0VOX09QRVJBVE9SLCAnPScpKSB7XG4gICAgICAgICAga3dhcmdzLmFkZENoaWxkKFxuICAgICAgICAgICAgbmV3IG5vZGVzLlBhaXIoYXJnLmxpbmVubyxcbiAgICAgICAgICAgICAgYXJnLmNvbG5vLFxuICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgIHRoaXMucGFyc2VFeHByZXNzaW9uKCkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmdzLmFkZENoaWxkKGFyZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hlY2tDb21tYSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGt3YXJncy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGFyZ3MuYWRkQ2hpbGQoa3dhcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIHBhcnNlVW50aWxCbG9ja3MoLi4uYmxvY2tOYW1lcykge1xuICAgIGNvbnN0IHByZXYgPSB0aGlzLmJyZWFrT25CbG9ja3M7XG4gICAgdGhpcy5icmVha09uQmxvY2tzID0gYmxvY2tOYW1lcztcblxuICAgIGNvbnN0IHJldCA9IHRoaXMucGFyc2UoKTtcblxuICAgIHRoaXMuYnJlYWtPbkJsb2NrcyA9IHByZXY7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHBhcnNlTm9kZXMoKSB7XG4gICAgbGV0IHRvaztcbiAgICBjb25zdCBidWYgPSBbXTtcblxuICAgIHdoaWxlICgodG9rID0gdGhpcy5uZXh0VG9rZW4oKSkpIHtcbiAgICAgIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fREFUQSkge1xuICAgICAgICBsZXQgZGF0YSA9IHRvay52YWx1ZTtcbiAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5wZWVrVG9rZW4oKTtcbiAgICAgICAgY29uc3QgbmV4dFZhbCA9IG5leHRUb2tlbiAmJiBuZXh0VG9rZW4udmFsdWU7XG5cbiAgICAgICAgLy8gSWYgdGhlIGxhc3QgdG9rZW4gaGFzIFwiLVwiIHdlIG5lZWQgdG8gdHJpbSB0aGVcbiAgICAgICAgLy8gbGVhZGluZyB3aGl0ZXNwYWNlIG9mIHRoZSBkYXRhLiBUaGlzIGlzIG1hcmtlZCB3aXRoXG4gICAgICAgIC8vIHRoZSBgZHJvcExlYWRpbmdXaGl0ZXNwYWNlYCB2YXJpYWJsZS5cbiAgICAgICAgaWYgKHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgLy8gVE9ETzogdGhpcyBjb3VsZCBiZSBvcHRpbWl6ZWQgKGRvbid0IHVzZSByZWdleClcbiAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC9eXFxzKi8sICcnKTtcbiAgICAgICAgICB0aGlzLmRyb3BMZWFkaW5nV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2FtZSBmb3IgdGhlIHN1Y2NlZWRpbmcgYmxvY2sgc3RhcnQgdG9rZW5cbiAgICAgICAgaWYgKG5leHRUb2tlbiAmJlxuICAgICAgICAgICgobmV4dFRva2VuLnR5cGUgPT09IGxleGVyLlRPS0VOX0JMT0NLX1NUQVJUICYmXG4gICAgICAgICAgbmV4dFZhbC5jaGFyQXQobmV4dFZhbC5sZW5ndGggLSAxKSA9PT0gJy0nKSB8fFxuICAgICAgICAgIChuZXh0VG9rZW4udHlwZSA9PT0gbGV4ZXIuVE9LRU5fVkFSSUFCTEVfU1RBUlQgJiZcbiAgICAgICAgICBuZXh0VmFsLmNoYXJBdCh0aGlzLnRva2Vucy50YWdzLlZBUklBQkxFX1NUQVJULmxlbmd0aClcbiAgICAgICAgICA9PT0gJy0nKSB8fFxuICAgICAgICAgIChuZXh0VG9rZW4udHlwZSA9PT0gbGV4ZXIuVE9LRU5fQ09NTUVOVCAmJlxuICAgICAgICAgIG5leHRWYWwuY2hhckF0KHRoaXMudG9rZW5zLnRhZ3MuQ09NTUVOVF9TVEFSVC5sZW5ndGgpXG4gICAgICAgICAgPT09ICctJykpKSB7XG4gICAgICAgICAgLy8gVE9ETzogdGhpcyBjb3VsZCBiZSBvcHRpbWl6ZWQgKGRvbid0IHVzZSByZWdleClcbiAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1Zi5wdXNoKG5ldyBub2Rlcy5PdXRwdXQodG9rLmxpbmVubyxcbiAgICAgICAgICB0b2suY29sbm8sXG4gICAgICAgICAgW25ldyBub2Rlcy5UZW1wbGF0ZURhdGEodG9rLmxpbmVubyxcbiAgICAgICAgICAgIHRvay5jb2xubyxcbiAgICAgICAgICAgIGRhdGEpXSkpO1xuICAgICAgfSBlbHNlIGlmICh0b2sudHlwZSA9PT0gbGV4ZXIuVE9LRU5fQkxPQ0tfU1RBUlQpIHtcbiAgICAgICAgdGhpcy5kcm9wTGVhZGluZ1doaXRlc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnVmLnB1c2gobik7XG4gICAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9WQVJJQUJMRV9TVEFSVCkge1xuICAgICAgICBjb25zdCBlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgdGhpcy5kcm9wTGVhZGluZ1doaXRlc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJWYXJpYWJsZUVuZCgpO1xuICAgICAgICBidWYucHVzaChuZXcgbm9kZXMuT3V0cHV0KHRvay5saW5lbm8sIHRvay5jb2xubywgW2VdKSk7XG4gICAgICB9IGVsc2UgaWYgKHRvay50eXBlID09PSBsZXhlci5UT0tFTl9DT01NRU5UKSB7XG4gICAgICAgIHRoaXMuZHJvcExlYWRpbmdXaGl0ZXNwYWNlID0gdG9rLnZhbHVlLmNoYXJBdChcbiAgICAgICAgICB0b2sudmFsdWUubGVuZ3RoIC0gdGhpcy50b2tlbnMudGFncy5DT01NRU5UX0VORC5sZW5ndGggLSAxXG4gICAgICAgICkgPT09ICctJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElnbm9yZSBjb21tZW50cywgb3RoZXJ3aXNlIHRoaXMgc2hvdWxkIGJlIGFuIGVycm9yXG4gICAgICAgIHRoaXMuZmFpbCgnVW5leHBlY3RlZCB0b2tlbiBhdCB0b3AtbGV2ZWw6ICcgK1xuICAgICAgICAgIHRvay50eXBlLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICBwYXJzZSgpIHtcbiAgICByZXR1cm4gbmV3IG5vZGVzLk5vZGVMaXN0KDAsIDAsIHRoaXMucGFyc2VOb2RlcygpKTtcbiAgfVxuXG4gIHBhcnNlQXNSb290KCkge1xuICAgIHJldHVybiBuZXcgbm9kZXMuUm9vdCgwLCAwLCB0aGlzLnBhcnNlTm9kZXMoKSk7XG4gIH1cbn1cblxuLy8gdmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbi8vIHZhciBsID0gbGV4ZXIubGV4KCd7JS0gaWYgeCAtJX1cXG4gaGVsbG8geyUgZW5kaWYgJX0nKTtcbi8vIHZhciB0O1xuLy8gd2hpbGUoKHQgPSBsLm5leHRUb2tlbigpKSkge1xuLy8gICAgIGNvbnNvbGUubG9nKHV0aWwuaW5zcGVjdCh0KSk7XG4vLyB9XG5cbi8vIHZhciBwID0gbmV3IFBhcnNlcihsZXhlci5sZXgoJ2hlbGxvIHslIGZpbHRlciB0aXRsZSAlfScgK1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnSGVsbG8gbWFkYW0gaG93IGFyZSB5b3UnICtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3slIGVuZGZpbHRlciAlfScpKTtcbi8vIHZhciBuID0gcC5wYXJzZUFzUm9vdCgpO1xuLy8gbm9kZXMucHJpbnROb2RlcyhuKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlKHNyYywgZXh0ZW5zaW9ucywgb3B0cykge1xuICAgIHZhciBwID0gbmV3IFBhcnNlcihsZXhlci5sZXgoc3JjLCBvcHRzKSk7XG4gICAgaWYgKGV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcC5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB9XG4gICAgcmV0dXJuIHAucGFyc2VBc1Jvb3QoKTtcbiAgfSxcbiAgUGFyc2VyOiBQYXJzZXJcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9udW5qdWNrcy9zcmMvcGFyc2VyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBsaWIgPSByZXF1aXJlKCcuL2xpYicpO1xuXG5sZXQgd2hpdGVzcGFjZUNoYXJzID0gJyBcXG5cXHRcXHJcXHUwMEEwJztcbmxldCBkZWxpbUNoYXJzID0gJygpW117fSUqLSt+LyMsOnwuPD49ISc7XG5sZXQgaW50Q2hhcnMgPSAnMDEyMzQ1Njc4OSc7XG5cbmxldCBCTE9DS19TVEFSVCA9ICd7JSc7XG5sZXQgQkxPQ0tfRU5EID0gJyV9JztcbmxldCBWQVJJQUJMRV9TVEFSVCA9ICd7eyc7XG5sZXQgVkFSSUFCTEVfRU5EID0gJ319JztcbmxldCBDT01NRU5UX1NUQVJUID0gJ3sjJztcbmxldCBDT01NRU5UX0VORCA9ICcjfSc7XG5cbmxldCBUT0tFTl9TVFJJTkcgPSAnc3RyaW5nJztcbmxldCBUT0tFTl9XSElURVNQQUNFID0gJ3doaXRlc3BhY2UnO1xubGV0IFRPS0VOX0RBVEEgPSAnZGF0YSc7XG5sZXQgVE9LRU5fQkxPQ0tfU1RBUlQgPSAnYmxvY2stc3RhcnQnO1xubGV0IFRPS0VOX0JMT0NLX0VORCA9ICdibG9jay1lbmQnO1xubGV0IFRPS0VOX1ZBUklBQkxFX1NUQVJUID0gJ3ZhcmlhYmxlLXN0YXJ0JztcbmxldCBUT0tFTl9WQVJJQUJMRV9FTkQgPSAndmFyaWFibGUtZW5kJztcbmxldCBUT0tFTl9DT01NRU5UID0gJ2NvbW1lbnQnO1xubGV0IFRPS0VOX0xFRlRfUEFSRU4gPSAnbGVmdC1wYXJlbic7XG5sZXQgVE9LRU5fUklHSFRfUEFSRU4gPSAncmlnaHQtcGFyZW4nO1xubGV0IFRPS0VOX0xFRlRfQlJBQ0tFVCA9ICdsZWZ0LWJyYWNrZXQnO1xubGV0IFRPS0VOX1JJR0hUX0JSQUNLRVQgPSAncmlnaHQtYnJhY2tldCc7XG5sZXQgVE9LRU5fTEVGVF9DVVJMWSA9ICdsZWZ0LWN1cmx5JztcbmxldCBUT0tFTl9SSUdIVF9DVVJMWSA9ICdyaWdodC1jdXJseSc7XG5sZXQgVE9LRU5fT1BFUkFUT1IgPSAnb3BlcmF0b3InO1xubGV0IFRPS0VOX0NPTU1BID0gJ2NvbW1hJztcbmxldCBUT0tFTl9DT0xPTiA9ICdjb2xvbic7XG5sZXQgVE9LRU5fVElMREUgPSAndGlsZGUnO1xubGV0IFRPS0VOX1BJUEUgPSAncGlwZSc7XG5sZXQgVE9LRU5fSU5UID0gJ2ludCc7XG5sZXQgVE9LRU5fRkxPQVQgPSAnZmxvYXQnO1xubGV0IFRPS0VOX0JPT0xFQU4gPSAnYm9vbGVhbic7XG5sZXQgVE9LRU5fTk9ORSA9ICdub25lJztcbmxldCBUT0tFTl9TWU1CT0wgPSAnc3ltYm9sJztcbmxldCBUT0tFTl9TUEVDSUFMID0gJ3NwZWNpYWwnO1xubGV0IFRPS0VOX1JFR0VYID0gJ3JlZ2V4JztcblxuZnVuY3Rpb24gdG9rZW4odHlwZSwgdmFsdWUsIGxpbmVubywgY29sbm8pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBsaW5lbm86IGxpbmVubyxcbiAgICBjb2xubzogY29sbm9cbiAgfTtcbn1cblxuY2xhc3MgVG9rZW5pemVyIHtcbiAgY29uc3RydWN0b3Ioc3RyLCBvcHRzKSB7XG4gICAgdGhpcy5zdHIgPSBzdHI7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5sZW4gPSBzdHIubGVuZ3RoO1xuICAgIHRoaXMubGluZW5vID0gMDtcbiAgICB0aGlzLmNvbG5vID0gMDtcblxuICAgIHRoaXMuaW5fY29kZSA9IGZhbHNlO1xuXG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICBsZXQgdGFncyA9IG9wdHMudGFncyB8fCB7fTtcbiAgICB0aGlzLnRhZ3MgPSB7XG4gICAgICBCTE9DS19TVEFSVDogdGFncy5ibG9ja1N0YXJ0IHx8IEJMT0NLX1NUQVJULFxuICAgICAgQkxPQ0tfRU5EOiB0YWdzLmJsb2NrRW5kIHx8IEJMT0NLX0VORCxcbiAgICAgIFZBUklBQkxFX1NUQVJUOiB0YWdzLnZhcmlhYmxlU3RhcnQgfHwgVkFSSUFCTEVfU1RBUlQsXG4gICAgICBWQVJJQUJMRV9FTkQ6IHRhZ3MudmFyaWFibGVFbmQgfHwgVkFSSUFCTEVfRU5ELFxuICAgICAgQ09NTUVOVF9TVEFSVDogdGFncy5jb21tZW50U3RhcnQgfHwgQ09NTUVOVF9TVEFSVCxcbiAgICAgIENPTU1FTlRfRU5EOiB0YWdzLmNvbW1lbnRFbmQgfHwgQ09NTUVOVF9FTkRcbiAgICB9O1xuXG4gICAgdGhpcy50cmltQmxvY2tzID0gISFvcHRzLnRyaW1CbG9ja3M7XG4gICAgdGhpcy5sc3RyaXBCbG9ja3MgPSAhIW9wdHMubHN0cmlwQmxvY2tzO1xuICB9XG5cbiAgbmV4dFRva2VuKCkge1xuICAgIGxldCBsaW5lbm8gPSB0aGlzLmxpbmVubztcbiAgICBsZXQgY29sbm8gPSB0aGlzLmNvbG5vO1xuICAgIGxldCB0b2s7XG5cbiAgICBpZiAodGhpcy5pbl9jb2RlKSB7XG4gICAgICAvLyBPdGhlcndpc2UsIGlmIHdlIGFyZSBpbiBhIGJsb2NrIHBhcnNlIGl0IGFzIGNvZGVcbiAgICAgIGxldCBjdXIgPSB0aGlzLmN1cnJlbnQoKTtcblxuICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCgpKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgbm90aGluZyBlbHNlIHRvIHBhcnNlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICdcIicgfHwgY3VyID09PSAnXFwnJykge1xuICAgICAgICAvLyBXZSd2ZSBoaXQgYSBzdHJpbmdcbiAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX1NUUklORywgdGhpcy5fcGFyc2VTdHJpbmcoY3VyKSwgbGluZW5vLCBjb2xubyk7XG4gICAgICB9IGVsc2UgaWYgKCh0b2sgPSB0aGlzLl9leHRyYWN0KHdoaXRlc3BhY2VDaGFycykpKSB7XG4gICAgICAgIC8vIFdlIGhpdCBzb21lIHdoaXRlc3BhY2VcbiAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX1dISVRFU1BBQ0UsIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICB9IGVsc2UgaWYgKCh0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKHRoaXMudGFncy5CTE9DS19FTkQpKSB8fFxuICAgICAgICAodG9rID0gdGhpcy5fZXh0cmFjdFN0cmluZygnLScgKyB0aGlzLnRhZ3MuQkxPQ0tfRU5EKSkpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjaGVjayBmb3IgdGhlIGJsb2NrIGVuZCB0YWdcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSXQgaXMgYSByZXF1aXJlbWVudCB0aGF0IHN0YXJ0IGFuZCBlbmQgdGFncyBhcmUgY29tcG9zZWQgb2ZcbiAgICAgICAgLy8gZGVsaW1pdGVyIGNoYXJhY3RlcnMgKCV7fVtdIGV0YyksIGFuZCBvdXIgY29kZSBhbHdheXNcbiAgICAgICAgLy8gYnJlYWtzIG9uIGRlbGltaXRlcnMgc28gd2UgY2FuIGFzc3VtZSB0aGUgdG9rZW4gcGFyc2luZ1xuICAgICAgICAvLyBkb2Vzbid0IGNvbnN1bWUgdGhlc2UgZWxzZXdoZXJlXG4gICAgICAgIHRoaXMuaW5fY29kZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy50cmltQmxvY2tzKSB7XG4gICAgICAgICAgY3VyID0gdGhpcy5jdXJyZW50KCk7XG4gICAgICAgICAgaWYgKGN1ciA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIC8vIFNraXAgbmV3bGluZVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjdXIgPT09ICdcXHInKSB7XG4gICAgICAgICAgICAvLyBTa2lwIENSTEYgbmV3bGluZVxuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgICBjdXIgPSB0aGlzLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIGlmIChjdXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gV2FzIG5vdCBhIENSTEYsIHNvIGdvIGJhY2tcbiAgICAgICAgICAgICAgdGhpcy5iYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9CTE9DS19FTkQsIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICB9IGVsc2UgaWYgKCh0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKHRoaXMudGFncy5WQVJJQUJMRV9FTkQpKSB8fFxuICAgICAgICAodG9rID0gdGhpcy5fZXh0cmFjdFN0cmluZygnLScgKyB0aGlzLnRhZ3MuVkFSSUFCTEVfRU5EKSkpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjaGVjayBmb3IgdmFyaWFibGUgZW5kIHRhZyAoc2VlIGFib3ZlKVxuICAgICAgICB0aGlzLmluX2NvZGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX1ZBUklBQkxFX0VORCwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyID09PSAncicgJiYgdGhpcy5zdHIuY2hhckF0KHRoaXMuaW5kZXggKyAxKSA9PT0gJy8nKSB7XG4gICAgICAgIC8vIFNraXAgcGFzdCAnci8nLlxuICAgICAgICB0aGlzLmZvcndhcmROKDIpO1xuXG4gICAgICAgIC8vIEV4dHJhY3QgdW50aWwgdGhlIGVuZCBvZiB0aGUgcmVnZXggLS0gLyBlbmRzIGl0LCBcXC8gZG9lcyBub3QuXG4gICAgICAgIGxldCByZWdleEJvZHkgPSAnJztcbiAgICAgICAgd2hpbGUgKCF0aGlzLmlzRmluaXNoZWQoKSkge1xuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQoKSA9PT0gJy8nICYmIHRoaXMucHJldmlvdXMoKSAhPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWdleEJvZHkgKz0gdGhpcy5jdXJyZW50KCk7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgZmxhZ3MuXG4gICAgICAgIC8vIFRoZSBwb3NzaWJsZSBmbGFncyBhcmUgYWNjb3JkaW5nIHRvIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1JlZ0V4cClcbiAgICAgICAgbGV0IFBPU1NJQkxFX0ZMQUdTID0gWydnJywgJ2knLCAnbScsICd5J107XG4gICAgICAgIGxldCByZWdleEZsYWdzID0gJyc7XG4gICAgICAgIHdoaWxlICghdGhpcy5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgICAgICBsZXQgaXNDdXJyZW50QUZsYWcgPSBQT1NTSUJMRV9GTEFHUy5pbmRleE9mKHRoaXMuY3VycmVudCgpKSAhPT0gLTE7XG4gICAgICAgICAgaWYgKGlzQ3VycmVudEFGbGFnKSB7XG4gICAgICAgICAgICByZWdleEZsYWdzICs9IHRoaXMuY3VycmVudCgpO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9SRUdFWCwge1xuICAgICAgICAgIGJvZHk6IHJlZ2V4Qm9keSxcbiAgICAgICAgICBmbGFnczogcmVnZXhGbGFnc1xuICAgICAgICB9LCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVsaW1DaGFycy5pbmRleE9mKGN1cikgIT09IC0xKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGhpdCBhIGRlbGltaXRlciAoYSBzcGVjaWFsIGNoYXIgbGlrZSBhIGJyYWNrZXQpXG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICBsZXQgY29tcGxleE9wcyA9IFsnPT0nLCAnPT09JywgJyE9JywgJyE9PScsICc8PScsICc+PScsICcvLycsICcqKiddO1xuICAgICAgICBsZXQgY3VyQ29tcGxleCA9IGN1ciArIHRoaXMuY3VycmVudCgpO1xuICAgICAgICBsZXQgdHlwZTtcblxuICAgICAgICBpZiAobGliLmluZGV4T2YoY29tcGxleE9wcywgY3VyQ29tcGxleCkgIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgY3VyID0gY3VyQ29tcGxleDtcblxuICAgICAgICAgIC8vIFNlZSBpZiB0aGlzIGlzIGEgc3RyaWN0IGVxdWFsaXR5L2luZXF1YWxpdHkgY29tcGFyYXRvclxuICAgICAgICAgIGlmIChsaWIuaW5kZXhPZihjb21wbGV4T3BzLCBjdXJDb21wbGV4ICsgdGhpcy5jdXJyZW50KCkpICE9PSAtMSkge1xuICAgICAgICAgICAgY3VyID0gY3VyQ29tcGxleCArIHRoaXMuY3VycmVudCgpO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChjdXIpIHtcbiAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9MRUZUX1BBUkVOO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fUklHSFRfUEFSRU47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9MRUZUX0JSQUNLRVQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9SSUdIVF9CUkFDS0VUO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fTEVGVF9DVVJMWTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgdHlwZSA9IFRPS0VOX1JJR0hUX0NVUkxZO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fQ09NTUE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgIHR5cGUgPSBUT0tFTl9DT0xPTjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ34nOlxuICAgICAgICAgICAgdHlwZSA9IFRPS0VOX1RJTERFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fUElQRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0eXBlID0gVE9LRU5fT1BFUkFUT1I7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9rZW4odHlwZSwgY3VyLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGFyZSBub3QgYXQgd2hpdGVzcGFjZSBvciBhIGRlbGltaXRlciwgc28gZXh0cmFjdCB0aGVcbiAgICAgICAgLy8gdGV4dCBhbmQgcGFyc2UgaXRcbiAgICAgICAgdG9rID0gdGhpcy5fZXh0cmFjdFVudGlsKHdoaXRlc3BhY2VDaGFycyArIGRlbGltQ2hhcnMpO1xuXG4gICAgICAgIGlmICh0b2subWF0Y2goL15bLStdP1swLTldKyQvKSkge1xuICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQoKSA9PT0gJy4nKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmQoKTtcbiAgICAgICAgICAgIGxldCBkZWMgPSB0aGlzLl9leHRyYWN0KGludENoYXJzKTtcbiAgICAgICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9GTE9BVCwgdG9rICsgJy4nICsgZGVjLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX0lOVCwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodG9rLm1hdGNoKC9eKHRydWV8ZmFsc2UpJC8pKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX0JPT0xFQU4sIHRvaywgbGluZW5vLCBjb2xubyk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rID09PSAnbm9uZScpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fTk9ORSwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgICAgLypcbiAgICAgICAgICogQWRkZWQgdG8gbWFrZSB0aGUgdGVzdCBgbnVsbCBpcyBudWxsYCBldmFsdWF0ZSB0cnV0aGlseS5cbiAgICAgICAgICogT3RoZXJ3aXNlLCBOdW5qdWNrcyB3aWxsIGxvb2sgdXAgbnVsbCBpbiB0aGUgY29udGV4dCBhbmRcbiAgICAgICAgICogcmV0dXJuIGB1bmRlZmluZWRgLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LiBUaGlzICptYXkqIGhhdmVcbiAgICAgICAgICogY29uc2VxdWVuY2VzIGlzIHNvbWVvbmUgaXMgdXNpbmcgbnVsbCBpbiB0aGVpciB0ZW1wbGF0ZXMgYXMgYVxuICAgICAgICAgKiB2YXJpYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIH0gZWxzZSBpZiAodG9rID09PSAnbnVsbCcpIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fTk9ORSwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2spIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW4oVE9LRU5fU1lNQk9MLCB0b2ssIGxpbmVubywgY29sbm8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB2YWx1ZSB3aGlsZSBwYXJzaW5nOiAnICsgdG9rKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQYXJzZSBvdXQgdGhlIHRlbXBsYXRlIHRleHQsIGJyZWFraW5nIG9uIHRhZ1xuICAgICAgLy8gZGVsaW1pdGVycyBiZWNhdXNlIHdlIG5lZWQgdG8gbG9vayBmb3IgYmxvY2svdmFyaWFibGUgc3RhcnRcbiAgICAgIC8vIHRhZ3MgKGRvbid0IHVzZSB0aGUgZnVsbCBkZWxpbUNoYXJzIGZvciBvcHRpbWl6YXRpb24pXG4gICAgICBsZXQgYmVnaW5DaGFycyA9ICh0aGlzLnRhZ3MuQkxPQ0tfU1RBUlQuY2hhckF0KDApICtcbiAgICAgIHRoaXMudGFncy5WQVJJQUJMRV9TVEFSVC5jaGFyQXQoMCkgK1xuICAgICAgdGhpcy50YWdzLkNPTU1FTlRfU1RBUlQuY2hhckF0KDApICtcbiAgICAgIHRoaXMudGFncy5DT01NRU5UX0VORC5jaGFyQXQoMCkpO1xuXG4gICAgICBpZiAodGhpcy5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCh0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKHRoaXMudGFncy5CTE9DS19TVEFSVCArICctJykpIHx8XG4gICAgICAgICh0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKHRoaXMudGFncy5CTE9DS19TVEFSVCkpKSB7XG4gICAgICAgIHRoaXMuaW5fY29kZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tlbihUT0tFTl9CTE9DS19TVEFSVCwgdG9rLCBsaW5lbm8sIGNvbG5vKTtcbiAgICAgIH0gZWxzZSBpZiAoKHRvayA9IHRoaXMuX2V4dHJhY3RTdHJpbmcodGhpcy50YWdzLlZBUklBQkxFX1NUQVJUICsgJy0nKSkgfHxcbiAgICAgICAgKHRvayA9IHRoaXMuX2V4dHJhY3RTdHJpbmcodGhpcy50YWdzLlZBUklBQkxFX1NUQVJUKSkpIHtcbiAgICAgICAgdGhpcy5pbl9jb2RlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRva2VuKFRPS0VOX1ZBUklBQkxFX1NUQVJULCB0b2ssIGxpbmVubywgY29sbm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9rID0gJyc7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBsZXQgaW5Db21tZW50ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX21hdGNoZXModGhpcy50YWdzLkNPTU1FTlRfU1RBUlQpKSB7XG4gICAgICAgICAgaW5Db21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICB0b2sgPSB0aGlzLl9leHRyYWN0U3RyaW5nKHRoaXMudGFncy5DT01NRU5UX1NUQVJUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnRpbnVhbGx5IGNvbnN1bWUgdGV4dCwgYnJlYWtpbmcgb24gdGhlIHRhZyBkZWxpbWl0ZXJcbiAgICAgICAgLy8gY2hhcmFjdGVycyBhbmQgY2hlY2tpbmcgdG8gc2VlIGlmIGl0J3MgYSBzdGFydCB0YWcuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIGNvdWxkIGhpdCB0aGUgZW5kIG9mIHRoZSB0ZW1wbGF0ZSBpbiB0aGUgbWlkZGxlIG9mXG4gICAgICAgIC8vIG91ciBsb29waW5nLCBzbyBjaGVjayBmb3IgdGhlIG51bGwgcmV0dXJuIHZhbHVlIGZyb21cbiAgICAgICAgLy8gX2V4dHJhY3RVbnRpbFxuICAgICAgICB3aGlsZSAoKGRhdGEgPSB0aGlzLl9leHRyYWN0VW50aWwoYmVnaW5DaGFycykpICE9PSBudWxsKSB7XG4gICAgICAgICAgdG9rICs9IGRhdGE7XG5cbiAgICAgICAgICBpZiAoKHRoaXMuX21hdGNoZXModGhpcy50YWdzLkJMT0NLX1NUQVJUKSB8fFxuICAgICAgICAgICAgdGhpcy5fbWF0Y2hlcyh0aGlzLnRhZ3MuVkFSSUFCTEVfU1RBUlQpIHx8XG4gICAgICAgICAgICB0aGlzLl9tYXRjaGVzKHRoaXMudGFncy5DT01NRU5UX1NUQVJUKSkgJiZcbiAgICAgICAgICAgICFpbkNvbW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxzdHJpcEJsb2NrcyAmJlxuICAgICAgICAgICAgICB0aGlzLl9tYXRjaGVzKHRoaXMudGFncy5CTE9DS19TVEFSVCkgJiZcbiAgICAgICAgICAgICAgdGhpcy5jb2xubyA+IDAgJiZcbiAgICAgICAgICAgICAgdGhpcy5jb2xubyA8PSB0b2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGxldCBsYXN0TGluZSA9IHRvay5zbGljZSgtdGhpcy5jb2xubyk7XG4gICAgICAgICAgICAgIGlmICgvXlxccyskLy50ZXN0KGxhc3RMaW5lKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBibG9jayBsZWFkaW5nIHdoaXRlc3BhY2UgZnJvbSBiZWdpbm5pbmcgb2YgdGhlIHN0cmluZ1xuICAgICAgICAgICAgICAgIHRvayA9IHRvay5zbGljZSgwLCAtdGhpcy5jb2xubyk7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBbGwgZGF0YSByZW1vdmVkLCBjb2xsYXBzZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSBub2Rlc1xuICAgICAgICAgICAgICAgICAgLy8gYnkgcmV0dXJuaW5nIG5leHQgdG9rZW4gKGJsb2NrIHN0YXJ0KVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhIHN0YXJ0IHRhZywgc3RvcCBsb29waW5nXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX21hdGNoZXModGhpcy50YWdzLkNPTU1FTlRfRU5EKSkge1xuICAgICAgICAgICAgaWYgKCFpbkNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGVuZCBvZiBjb21tZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2sgKz0gdGhpcy5fZXh0cmFjdFN0cmluZyh0aGlzLnRhZ3MuQ09NTUVOVF9FTkQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0IGRvZXMgbm90IG1hdGNoIGFueSB0YWcsIHNvIGFkZCB0aGUgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgLy8gY2Fycnkgb25cbiAgICAgICAgICAgIHRvayArPSB0aGlzLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhID09PSBudWxsICYmIGluQ29tbWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgZW5kIG9mIGNvbW1lbnQsIGdvdCBlbmQgb2YgZmlsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRva2VuKGluQ29tbWVudCA/IFRPS0VOX0NPTU1FTlQgOiBUT0tFTl9EQVRBLFxuICAgICAgICAgIHRvayxcbiAgICAgICAgICBsaW5lbm8sXG4gICAgICAgICAgY29sbm8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9wYXJzZVN0cmluZyhkZWxpbWl0ZXIpIHtcbiAgICB0aGlzLmZvcndhcmQoKTtcblxuICAgIGxldCBzdHIgPSAnJztcblxuICAgIHdoaWxlICghdGhpcy5pc0ZpbmlzaGVkKCkgJiYgdGhpcy5jdXJyZW50KCkgIT09IGRlbGltaXRlcikge1xuICAgICAgbGV0IGN1ciA9IHRoaXMuY3VycmVudCgpO1xuXG4gICAgICBpZiAoY3VyID09PSAnXFxcXCcpIHtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jdXJyZW50KCkpIHtcbiAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xccic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3RyICs9IHRoaXMuY3VycmVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9yd2FyZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IGN1cjtcbiAgICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIF9tYXRjaGVzKHN0cikge1xuICAgIGlmICh0aGlzLmluZGV4ICsgc3RyLmxlbmd0aCA+IHRoaXMubGVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgbSA9IHRoaXMuc3RyLnNsaWNlKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggKyBzdHIubGVuZ3RoKTtcbiAgICByZXR1cm4gbSA9PT0gc3RyO1xuICB9XG5cbiAgX2V4dHJhY3RTdHJpbmcoc3RyKSB7XG4gICAgaWYgKHRoaXMuX21hdGNoZXMoc3RyKSkge1xuICAgICAgdGhpcy5mb3J3YXJkTihzdHIubGVuZ3RoKTtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgX2V4dHJhY3RVbnRpbChjaGFyU3RyaW5nKSB7XG4gICAgLy8gRXh0cmFjdCBhbGwgbm9uLW1hdGNoaW5nIGNoYXJzLCB3aXRoIHRoZSBkZWZhdWx0IG1hdGNoaW5nIHNldFxuICAgIC8vIHRvIGV2ZXJ5dGhpbmdcbiAgICByZXR1cm4gdGhpcy5fZXh0cmFjdE1hdGNoaW5nKHRydWUsIGNoYXJTdHJpbmcgfHwgJycpO1xuICB9XG5cbiAgX2V4dHJhY3QoY2hhclN0cmluZykge1xuICAgIC8vIEV4dHJhY3QgYWxsIG1hdGNoaW5nIGNoYXJzIChubyBkZWZhdWx0LCBzbyBjaGFyU3RyaW5nIG11c3QgYmVcbiAgICAvLyBleHBsaWNpdClcbiAgICByZXR1cm4gdGhpcy5fZXh0cmFjdE1hdGNoaW5nKGZhbHNlLCBjaGFyU3RyaW5nKTtcbiAgfVxuXG4gIF9leHRyYWN0TWF0Y2hpbmcoYnJlYWtPbk1hdGNoLCBjaGFyU3RyaW5nKSB7XG4gICAgLy8gUHVsbCBvdXQgY2hhcmFjdGVycyB1bnRpbCBhIGJyZWFraW5nIGNoYXIgaXMgaGl0LlxuICAgIC8vIElmIGJyZWFrT25NYXRjaCBpcyBmYWxzZSwgYSBub24tbWF0Y2hpbmcgY2hhciBzdG9wcyBpdC5cbiAgICAvLyBJZiBicmVha09uTWF0Y2ggaXMgdHJ1ZSwgYSBtYXRjaGluZyBjaGFyIHN0b3BzIGl0LlxuXG4gICAgaWYgKHRoaXMuaXNGaW5pc2hlZCgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgZmlyc3QgPSBjaGFyU3RyaW5nLmluZGV4T2YodGhpcy5jdXJyZW50KCkpO1xuXG4gICAgLy8gT25seSBwcm9jZWVkIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgZG9lc24ndCBtZWV0IG91ciBjb25kaXRpb25cbiAgICBpZiAoKGJyZWFrT25NYXRjaCAmJiBmaXJzdCA9PT0gLTEpIHx8XG4gICAgICAoIWJyZWFrT25NYXRjaCAmJiBmaXJzdCAhPT0gLTEpKSB7XG4gICAgICBsZXQgdCA9IHRoaXMuY3VycmVudCgpO1xuICAgICAgdGhpcy5mb3J3YXJkKCk7XG5cbiAgICAgIC8vIEFuZCBwdWxsIG91dCBhbGwgdGhlIGNoYXJzIG9uZSBhdCBhIHRpbWUgdW50aWwgd2UgaGl0IGFcbiAgICAgIC8vIGJyZWFraW5nIGNoYXJcbiAgICAgIGxldCBpZHggPSBjaGFyU3RyaW5nLmluZGV4T2YodGhpcy5jdXJyZW50KCkpO1xuXG4gICAgICB3aGlsZSAoKChicmVha09uTWF0Y2ggJiYgaWR4ID09PSAtMSkgfHxcbiAgICAgICAgKCFicmVha09uTWF0Y2ggJiYgaWR4ICE9PSAtMSkpICYmICF0aGlzLmlzRmluaXNoZWQoKSkge1xuICAgICAgICB0ICs9IHRoaXMuY3VycmVudCgpO1xuICAgICAgICB0aGlzLmZvcndhcmQoKTtcblxuICAgICAgICBpZHggPSBjaGFyU3RyaW5nLmluZGV4T2YodGhpcy5jdXJyZW50KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBfZXh0cmFjdFJlZ2V4KHJlZ2V4KSB7XG4gICAgbGV0IG1hdGNoZXMgPSB0aGlzLmN1cnJlbnRTdHIoKS5tYXRjaChyZWdleCk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBNb3ZlIGZvcndhcmQgd2hhdGV2ZXIgd2FzIG1hdGNoZWRcbiAgICB0aGlzLmZvcndhcmROKG1hdGNoZXNbMF0ubGVuZ3RoKTtcblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgaXNGaW5pc2hlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleCA+PSB0aGlzLmxlbjtcbiAgfVxuXG4gIGZvcndhcmROKG4pIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgdGhpcy5mb3J3YXJkKCk7XG4gICAgfVxuICB9XG5cbiAgZm9yd2FyZCgpIHtcbiAgICB0aGlzLmluZGV4Kys7XG5cbiAgICBpZiAodGhpcy5wcmV2aW91cygpID09PSAnXFxuJykge1xuICAgICAgdGhpcy5saW5lbm8rKztcbiAgICAgIHRoaXMuY29sbm8gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbG5vKys7XG4gICAgfVxuICB9XG5cbiAgYmFja04obikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICB0aGlzLmJhY2soKTtcbiAgICB9XG4gIH1cblxuICBiYWNrKCkge1xuICAgIHRoaXMuaW5kZXgtLTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnQoKSA9PT0gJ1xcbicpIHtcbiAgICAgIHRoaXMubGluZW5vLS07XG5cbiAgICAgIGxldCBpZHggPSB0aGlzLnNyYy5sYXN0SW5kZXhPZignXFxuJywgdGhpcy5pbmRleCAtIDEpO1xuICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5jb2xubyA9IHRoaXMuaW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbG5vID0gdGhpcy5pbmRleCAtIGlkeDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb2xuby0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGN1cnJlbnQgcmV0dXJucyBjdXJyZW50IGNoYXJhY3RlclxuICBjdXJyZW50KCkge1xuICAgIGlmICghdGhpcy5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0ci5jaGFyQXQodGhpcy5pbmRleCk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIGN1cnJlbnRTdHIgcmV0dXJucyB3aGF0J3MgbGVmdCBvZiB0aGUgdW5wYXJzZWQgc3RyaW5nXG4gIGN1cnJlbnRTdHIoKSB7XG4gICAgaWYgKCF0aGlzLmlzRmluaXNoZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyLnN1YnN0cih0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcHJldmlvdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyLmNoYXJBdCh0aGlzLmluZGV4IC0gMSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxleChzcmMsIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFRva2VuaXplcihzcmMsIG9wdHMpO1xuICB9LFxuXG4gIFRPS0VOX1NUUklORzogVE9LRU5fU1RSSU5HLFxuICBUT0tFTl9XSElURVNQQUNFOiBUT0tFTl9XSElURVNQQUNFLFxuICBUT0tFTl9EQVRBOiBUT0tFTl9EQVRBLFxuICBUT0tFTl9CTE9DS19TVEFSVDogVE9LRU5fQkxPQ0tfU1RBUlQsXG4gIFRPS0VOX0JMT0NLX0VORDogVE9LRU5fQkxPQ0tfRU5ELFxuICBUT0tFTl9WQVJJQUJMRV9TVEFSVDogVE9LRU5fVkFSSUFCTEVfU1RBUlQsXG4gIFRPS0VOX1ZBUklBQkxFX0VORDogVE9LRU5fVkFSSUFCTEVfRU5ELFxuICBUT0tFTl9DT01NRU5UOiBUT0tFTl9DT01NRU5ULFxuICBUT0tFTl9MRUZUX1BBUkVOOiBUT0tFTl9MRUZUX1BBUkVOLFxuICBUT0tFTl9SSUdIVF9QQVJFTjogVE9LRU5fUklHSFRfUEFSRU4sXG4gIFRPS0VOX0xFRlRfQlJBQ0tFVDogVE9LRU5fTEVGVF9CUkFDS0VULFxuICBUT0tFTl9SSUdIVF9CUkFDS0VUOiBUT0tFTl9SSUdIVF9CUkFDS0VULFxuICBUT0tFTl9MRUZUX0NVUkxZOiBUT0tFTl9MRUZUX0NVUkxZLFxuICBUT0tFTl9SSUdIVF9DVVJMWTogVE9LRU5fUklHSFRfQ1VSTFksXG4gIFRPS0VOX09QRVJBVE9SOiBUT0tFTl9PUEVSQVRPUixcbiAgVE9LRU5fQ09NTUE6IFRPS0VOX0NPTU1BLFxuICBUT0tFTl9DT0xPTjogVE9LRU5fQ09MT04sXG4gIFRPS0VOX1RJTERFOiBUT0tFTl9USUxERSxcbiAgVE9LRU5fUElQRTogVE9LRU5fUElQRSxcbiAgVE9LRU5fSU5UOiBUT0tFTl9JTlQsXG4gIFRPS0VOX0ZMT0FUOiBUT0tFTl9GTE9BVCxcbiAgVE9LRU5fQk9PTEVBTjogVE9LRU5fQk9PTEVBTixcbiAgVE9LRU5fTk9ORTogVE9LRU5fTk9ORSxcbiAgVE9LRU5fU1lNQk9MOiBUT0tFTl9TWU1CT0wsXG4gIFRPS0VOX1NQRUNJQUw6IFRPS0VOX1NQRUNJQUwsXG4gIFRPS0VOX1JFR0VYOiBUT0tFTl9SRUdFWFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL251bmp1Y2tzL3NyYy9sZXhlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTG9hZGVyID0gcmVxdWlyZSgnLi9sb2FkZXInKTtcbmNvbnN0IHtQcmVjb21waWxlZExvYWRlcn0gPSByZXF1aXJlKCcuL3ByZWNvbXBpbGVkLWxvYWRlci5qcycpO1xuXG5jbGFzcyBXZWJMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihiYXNlVVJMLCBvcHRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmJhc2VVUkwgPSBiYXNlVVJMIHx8ICcuJztcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSBjYWNoZSBpcyB0dXJuZWQgb2ZmIGJlY2F1c2UgdGhlcmUncyBubyB3YXlcbiAgICAvLyB0byBcIndhdGNoXCIgdGVtcGxhdGVzIG92ZXIgSFRUUCwgc28gdGhleSBhcmUgcmUtZG93bmxvYWRlZFxuICAgIC8vIGFuZCBjb21waWxlZCBlYWNoIHRpbWUuIChSZW1lbWJlciwgUFJFQ09NUElMRSBZT1VSXG4gICAgLy8gVEVNUExBVEVTIGluIHByb2R1Y3Rpb24hKVxuICAgIHRoaXMudXNlQ2FjaGUgPSAhIW9wdHMudXNlQ2FjaGU7XG5cbiAgICAvLyBXZSBkZWZhdWx0IGBhc3luY2AgdG8gZmFsc2Ugc28gdGhhdCB0aGUgc2ltcGxlIHN5bmNocm9ub3VzXG4gICAgLy8gQVBJIGNhbiBiZSB1c2VkIHdoZW4geW91IGFyZW4ndCBkb2luZyBhbnl0aGluZyBhc3luYyBpblxuICAgIC8vIHlvdXIgdGVtcGxhdGVzICh3aGljaCBpcyBtb3N0IG9mIHRoZSB0aW1lKS4gVGhpcyBwZXJmb3JtcyBhXG4gICAgLy8gc3luYyBhamF4IHJlcXVlc3QsIGJ1dCB0aGF0J3Mgb2sgYmVjYXVzZSBpdCBzaG91bGQgKm9ubHkqXG4gICAgLy8gaGFwcGVuIGluIGRldmVsb3BtZW50LiBQUkVDT01QSUxFIFlPVVIgVEVNUExBVEVTLlxuICAgIHRoaXMuYXN5bmMgPSAhIW9wdHMuYXN5bmM7XG4gIH1cblxuICByZXNvbHZlKGZyb20sIHRvKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZWxhdGl2ZSB0ZW1wbGF0ZXMgbm90IHN1cHBvcnQgaW4gdGhlIGJyb3dzZXIgeWV0Jyk7XG4gIH1cblxuICBnZXRTb3VyY2UobmFtZSwgY2IpIHtcbiAgICB2YXIgdXNlQ2FjaGUgPSB0aGlzLnVzZUNhY2hlO1xuICAgIHZhciByZXN1bHQ7XG4gICAgdGhpcy5mZXRjaCh0aGlzLmJhc2VVUkwgKyAnLycgKyBuYW1lLCAoZXJyLCBzcmMpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgY2IoZXJyLmNvbnRlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVyci5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICBzcmM6IHNyYyxcbiAgICAgICAgICBwYXRoOiBuYW1lLFxuICAgICAgICAgIG5vQ2FjaGU6ICF1c2VDYWNoZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXQoJ2xvYWQnLCBuYW1lLCByZXN1bHQpO1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICBjYihudWxsLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBpZiB0aGlzIFdlYkxvYWRlciBpc24ndCBydW5uaW5nIGFzeW5jaHJvbm91c2x5LCB0aGVcbiAgICAvLyBmZXRjaCBhYm92ZSB3b3VsZCBhY3R1YWxseSBydW4gc3luYyBhbmQgd2UnbGwgaGF2ZSBhXG4gICAgLy8gcmVzdWx0IGhlcmVcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZmV0Y2godXJsLCBjYikge1xuICAgIC8vIE9ubHkgaW4gdGhlIGJyb3dzZXIgcGxlYXNlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkxvYWRlciBjYW4gb25seSBieSB1c2VkIGluIGEgYnJvd3NlcicpO1xuICAgIH1cblxuICAgIGNvbnN0IGFqYXggPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBsZXQgbG9hZGluZyA9IHRydWU7XG5cbiAgICBhamF4Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChhamF4LnJlYWR5U3RhdGUgPT09IDQgJiYgbG9hZGluZykge1xuICAgICAgICBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChhamF4LnN0YXR1cyA9PT0gMCB8fCBhamF4LnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgY2IobnVsbCwgYWpheC5yZXNwb25zZVRleHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKHtcbiAgICAgICAgICAgIHN0YXR1czogYWpheC5zdGF0dXMsXG4gICAgICAgICAgICBjb250ZW50OiBhamF4LnJlc3BvbnNlVGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgJ3M9JyArXG4gICAgKG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcblxuICAgIGFqYXgub3BlbignR0VUJywgdXJsLCB0aGlzLmFzeW5jKTtcbiAgICBhamF4LnNlbmQoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViTG9hZGVyOiBXZWJMb2FkZXIsXG4gIFByZWNvbXBpbGVkTG9hZGVyOiBQcmVjb21waWxlZExvYWRlclxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL251bmp1Y2tzL3NyYy93ZWItbG9hZGVycy5qcyIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbGliID0gcmVxdWlyZSgnLi9zcmMvbGliJyk7XG5jb25zdCB7RW52aXJvbm1lbnQsIFRlbXBsYXRlfSA9IHJlcXVpcmUoJy4vc3JjL2Vudmlyb25tZW50Jyk7XG5jb25zdCBMb2FkZXIgPSByZXF1aXJlKCcuL3NyYy9sb2FkZXInKTtcbmNvbnN0IGxvYWRlcnMgPSByZXF1aXJlKCcuL3NyYy9sb2FkZXJzJyk7XG5jb25zdCBwcmVjb21waWxlID0gcmVxdWlyZSgnLi9zcmMvcHJlY29tcGlsZScpO1xuY29uc3QgY29tcGlsZXIgPSByZXF1aXJlKCcuL3NyYy9jb21waWxlcicpO1xuY29uc3QgcGFyc2VyID0gcmVxdWlyZSgnLi9zcmMvcGFyc2VyJyk7XG5jb25zdCBsZXhlciA9IHJlcXVpcmUoJy4vc3JjL2xleGVyJyk7XG5jb25zdCBydW50aW1lID0gcmVxdWlyZSgnLi9zcmMvcnVudGltZScpO1xuY29uc3Qgbm9kZXMgPSByZXF1aXJlKCcuL3NyYy9ub2RlcycpO1xuY29uc3QgaW5zdGFsbEppbmphQ29tcGF0ID0gcmVxdWlyZSgnLi9zcmMvamluamEtY29tcGF0Jyk7XG5cbi8vIEEgc2luZ2xlIGluc3RhbmNlIG9mIGFuIGVudmlyb25tZW50LCBzaW5jZSB0aGlzIGlzIHNvIGNvbW1vbmx5IHVzZWRcbmxldCBlO1xuXG5mdW5jdGlvbiBjb25maWd1cmUodGVtcGxhdGVzUGF0aCwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgaWYgKGxpYi5pc09iamVjdCh0ZW1wbGF0ZXNQYXRoKSkge1xuICAgIG9wdHMgPSB0ZW1wbGF0ZXNQYXRoO1xuICAgIHRlbXBsYXRlc1BhdGggPSBudWxsO1xuICB9XG5cbiAgbGV0IFRlbXBsYXRlTG9hZGVyO1xuICBpZiAobG9hZGVycy5GaWxlU3lzdGVtTG9hZGVyKSB7XG4gICAgVGVtcGxhdGVMb2FkZXIgPSBuZXcgbG9hZGVycy5GaWxlU3lzdGVtTG9hZGVyKHRlbXBsYXRlc1BhdGgsIHtcbiAgICAgIHdhdGNoOiBvcHRzLndhdGNoLFxuICAgICAgbm9DYWNoZTogb3B0cy5ub0NhY2hlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobG9hZGVycy5XZWJMb2FkZXIpIHtcbiAgICBUZW1wbGF0ZUxvYWRlciA9IG5ldyBsb2FkZXJzLldlYkxvYWRlcih0ZW1wbGF0ZXNQYXRoLCB7XG4gICAgICB1c2VDYWNoZTogb3B0cy53ZWIgJiYgb3B0cy53ZWIudXNlQ2FjaGUsXG4gICAgICBhc3luYzogb3B0cy53ZWIgJiYgb3B0cy53ZWIuYXN5bmNcbiAgICB9KTtcbiAgfVxuXG4gIGUgPSBuZXcgRW52aXJvbm1lbnQoVGVtcGxhdGVMb2FkZXIsIG9wdHMpO1xuXG4gIGlmIChvcHRzICYmIG9wdHMuZXhwcmVzcykge1xuICAgIGUuZXhwcmVzcyhvcHRzLmV4cHJlc3MpO1xuICB9XG5cbiAgcmV0dXJuIGU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFbnZpcm9ubWVudDogRW52aXJvbm1lbnQsXG4gIFRlbXBsYXRlOiBUZW1wbGF0ZSxcbiAgTG9hZGVyOiBMb2FkZXIsXG4gIEZpbGVTeXN0ZW1Mb2FkZXI6IGxvYWRlcnMuRmlsZVN5c3RlbUxvYWRlcixcbiAgTm9kZVJlc29sdmVMb2FkZXI6IGxvYWRlcnMuTm9kZVJlc29sdmVMb2FkZXIsXG4gIFByZWNvbXBpbGVkTG9hZGVyOiBsb2FkZXJzLlByZWNvbXBpbGVkTG9hZGVyLFxuICBXZWJMb2FkZXI6IGxvYWRlcnMuV2ViTG9hZGVyLFxuICBjb21waWxlcjogY29tcGlsZXIsXG4gIHBhcnNlcjogcGFyc2VyLFxuICBsZXhlcjogbGV4ZXIsXG4gIHJ1bnRpbWU6IHJ1bnRpbWUsXG4gIGxpYjogbGliLFxuICBub2Rlczogbm9kZXMsXG4gIGluc3RhbGxKaW5qYUNvbXBhdDogaW5zdGFsbEppbmphQ29tcGF0LFxuICBjb25maWd1cmU6IGNvbmZpZ3VyZSxcbiAgcmVzZXQoKSB7XG4gICAgZSA9IHVuZGVmaW5lZDtcbiAgfSxcbiAgY29tcGlsZShzcmMsIGVudiwgcGF0aCwgZWFnZXJDb21waWxlKSB7XG4gICAgaWYgKCFlKSB7XG4gICAgICBjb25maWd1cmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZW1wbGF0ZShzcmMsIGVudiwgcGF0aCwgZWFnZXJDb21waWxlKTtcbiAgfSxcbiAgcmVuZGVyKG5hbWUsIGN0eCwgY2IpIHtcbiAgICBpZiAoIWUpIHtcbiAgICAgIGNvbmZpZ3VyZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBlLnJlbmRlcihuYW1lLCBjdHgsIGNiKTtcbiAgfSxcbiAgcmVuZGVyU3RyaW5nKHNyYywgY3R4LCBjYikge1xuICAgIGlmICghZSkge1xuICAgICAgY29uZmlndXJlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGUucmVuZGVyU3RyaW5nKHNyYywgY3R4LCBjYik7XG4gIH0sXG4gIHByZWNvbXBpbGU6IChwcmVjb21waWxlKSA/IHByZWNvbXBpbGUucHJlY29tcGlsZSA6IHVuZGVmaW5lZCxcbiAgcHJlY29tcGlsZVN0cmluZzogKHByZWNvbXBpbGUpID8gcHJlY29tcGlsZS5wcmVjb21waWxlU3RyaW5nIDogdW5kZWZpbmVkLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL251bmp1Y2tzL2luZGV4LmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHJhd0FzYXAgcHJvdmlkZXMgZXZlcnl0aGluZyB3ZSBuZWVkIGV4Y2VwdCBleGNlcHRpb24gbWFuYWdlbWVudC5cbnZhciByYXdBc2FwID0gcmVxdWlyZShcIi4vcmF3XCIpO1xuLy8gUmF3VGFza3MgYXJlIHJlY3ljbGVkIHRvIHJlZHVjZSBHQyBjaHVybi5cbnZhciBmcmVlVGFza3MgPSBbXTtcbi8vIFdlIHF1ZXVlIGVycm9ycyB0byBlbnN1cmUgdGhleSBhcmUgdGhyb3duIGluIHJpZ2h0IG9yZGVyIChGSUZPKS5cbi8vIEFycmF5LWFzLXF1ZXVlIGlzIGdvb2QgZW5vdWdoIGhlcmUsIHNpbmNlIHdlIGFyZSBqdXN0IGRlYWxpbmcgd2l0aCBleGNlcHRpb25zLlxudmFyIHBlbmRpbmdFcnJvcnMgPSBbXTtcbnZhciByZXF1ZXN0RXJyb3JUaHJvdyA9IHJhd0FzYXAubWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKHRocm93Rmlyc3RFcnJvcik7XG5cbmZ1bmN0aW9uIHRocm93Rmlyc3RFcnJvcigpIHtcbiAgICBpZiAocGVuZGluZ0Vycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgcGVuZGluZ0Vycm9ycy5zaGlmdCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDYWxscyBhIHRhc2sgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciByZXR1cm5pbmcsIGluIGl0cyBvd24gZXZlbnQsIHdpdGggcHJpb3JpdHlcbiAqIG92ZXIgb3RoZXIgZXZlbnRzIGxpa2UgYW5pbWF0aW9uLCByZWZsb3csIGFuZCByZXBhaW50LiBBbiBlcnJvciB0aHJvd24gZnJvbSBhblxuICogZXZlbnQgd2lsbCBub3QgaW50ZXJydXB0LCBub3IgZXZlbiBzdWJzdGFudGlhbGx5IHNsb3cgZG93biB0aGUgcHJvY2Vzc2luZyBvZlxuICogb3RoZXIgZXZlbnRzLCBidXQgd2lsbCBiZSByYXRoZXIgcG9zdHBvbmVkIHRvIGEgbG93ZXIgcHJpb3JpdHkgZXZlbnQuXG4gKiBAcGFyYW0ge3tjYWxsfX0gdGFzayBBIGNhbGxhYmxlIG9iamVjdCwgdHlwaWNhbGx5IGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBub1xuICogYXJndW1lbnRzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGFzYXA7XG5mdW5jdGlvbiBhc2FwKHRhc2spIHtcbiAgICB2YXIgcmF3VGFzaztcbiAgICBpZiAoZnJlZVRhc2tzLmxlbmd0aCkge1xuICAgICAgICByYXdUYXNrID0gZnJlZVRhc2tzLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJhd1Rhc2sgPSBuZXcgUmF3VGFzaygpO1xuICAgIH1cbiAgICByYXdUYXNrLnRhc2sgPSB0YXNrO1xuICAgIHJhd0FzYXAocmF3VGFzayk7XG59XG5cbi8vIFdlIHdyYXAgdGFza3Mgd2l0aCByZWN5Y2xhYmxlIHRhc2sgb2JqZWN0cy4gIEEgdGFzayBvYmplY3QgaW1wbGVtZW50c1xuLy8gYGNhbGxgLCBqdXN0IGxpa2UgYSBmdW5jdGlvbi5cbmZ1bmN0aW9uIFJhd1Rhc2soKSB7XG4gICAgdGhpcy50YXNrID0gbnVsbDtcbn1cblxuLy8gVGhlIHNvbGUgcHVycG9zZSBvZiB3cmFwcGluZyB0aGUgdGFzayBpcyB0byBjYXRjaCB0aGUgZXhjZXB0aW9uIGFuZCByZWN5Y2xlXG4vLyB0aGUgdGFzayBvYmplY3QgYWZ0ZXIgaXRzIHNpbmdsZSB1c2UuXG5SYXdUYXNrLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMudGFzay5jYWxsKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGFzYXAub25lcnJvcikge1xuICAgICAgICAgICAgLy8gVGhpcyBob29rIGV4aXN0cyBwdXJlbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gICAgICAgICAgICAvLyBJdHMgbmFtZSB3aWxsIGJlIHBlcmlvZGljYWxseSByYW5kb21pemVkIHRvIGJyZWFrIGFueSBjb2RlIHRoYXRcbiAgICAgICAgICAgIC8vIGRlcGVuZHMgb24gaXRzIGV4aXN0ZW5jZS5cbiAgICAgICAgICAgIGFzYXAub25lcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJbiBhIHdlYiBicm93c2VyLCBleGNlcHRpb25zIGFyZSBub3QgZmF0YWwuIEhvd2V2ZXIsIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBzbG93aW5nIGRvd24gdGhlIHF1ZXVlIG9mIHBlbmRpbmcgdGFza3MsIHdlIHJldGhyb3cgdGhlIGVycm9yIGluIGFcbiAgICAgICAgICAgIC8vIGxvd2VyIHByaW9yaXR5IHR1cm4uXG4gICAgICAgICAgICBwZW5kaW5nRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgcmVxdWVzdEVycm9yVGhyb3coKTtcbiAgICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIGZyZWVUYXNrc1tmcmVlVGFza3MubGVuZ3RoXSA9IHRoaXM7XG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FzYXAvYnJvd3Nlci1hc2FwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gVXNlIHRoZSBmYXN0ZXN0IG1lYW5zIHBvc3NpYmxlIHRvIGV4ZWN1dGUgYSB0YXNrIGluIGl0cyBvd24gdHVybiwgd2l0aFxuLy8gcHJpb3JpdHkgb3ZlciBvdGhlciBldmVudHMgaW5jbHVkaW5nIElPLCBhbmltYXRpb24sIHJlZmxvdywgYW5kIHJlZHJhd1xuLy8gZXZlbnRzIGluIGJyb3dzZXJzLlxuLy9cbi8vIEFuIGV4Y2VwdGlvbiB0aHJvd24gYnkgYSB0YXNrIHdpbGwgcGVybWFuZW50bHkgaW50ZXJydXB0IHRoZSBwcm9jZXNzaW5nIG9mXG4vLyBzdWJzZXF1ZW50IHRhc2tzLiBUaGUgaGlnaGVyIGxldmVsIGBhc2FwYCBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgaWYgYW5cbi8vIGV4Y2VwdGlvbiBpcyB0aHJvd24gYnkgYSB0YXNrLCB0aGF0IHRoZSB0YXNrIHF1ZXVlIHdpbGwgY29udGludWUgZmx1c2hpbmcgYXNcbi8vIHNvb24gYXMgcG9zc2libGUsIGJ1dCBpZiB5b3UgdXNlIGByYXdBc2FwYCBkaXJlY3RseSwgeW91IGFyZSByZXNwb25zaWJsZSB0b1xuLy8gZWl0aGVyIGVuc3VyZSB0aGF0IG5vIGV4Y2VwdGlvbnMgYXJlIHRocm93biBmcm9tIHlvdXIgdGFzaywgb3IgdG8gbWFudWFsbHlcbi8vIGNhbGwgYHJhd0FzYXAucmVxdWVzdEZsdXNoYCBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxubW9kdWxlLmV4cG9ydHMgPSByYXdBc2FwO1xuZnVuY3Rpb24gcmF3QXNhcCh0YXNrKSB7XG4gICAgaWYgKCFxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmVxdWVzdEZsdXNoKCk7XG4gICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRXF1aXZhbGVudCB0byBwdXNoLCBidXQgYXZvaWRzIGEgZnVuY3Rpb24gY2FsbC5cbiAgICBxdWV1ZVtxdWV1ZS5sZW5ndGhdID0gdGFzaztcbn1cblxudmFyIHF1ZXVlID0gW107XG4vLyBPbmNlIGEgZmx1c2ggaGFzIGJlZW4gcmVxdWVzdGVkLCBubyBmdXJ0aGVyIGNhbGxzIHRvIGByZXF1ZXN0Rmx1c2hgIGFyZVxuLy8gbmVjZXNzYXJ5IHVudGlsIHRoZSBuZXh0IGBmbHVzaGAgY29tcGxldGVzLlxudmFyIGZsdXNoaW5nID0gZmFsc2U7XG4vLyBgcmVxdWVzdEZsdXNoYCBpcyBhbiBpbXBsZW1lbnRhdGlvbi1zcGVjaWZpYyBtZXRob2QgdGhhdCBhdHRlbXB0cyB0byBraWNrXG4vLyBvZmYgYSBgZmx1c2hgIGV2ZW50IGFzIHF1aWNrbHkgYXMgcG9zc2libGUuIGBmbHVzaGAgd2lsbCBhdHRlbXB0IHRvIGV4aGF1c3Rcbi8vIHRoZSBldmVudCBxdWV1ZSBiZWZvcmUgeWllbGRpbmcgdG8gdGhlIGJyb3dzZXIncyBvd24gZXZlbnQgbG9vcC5cbnZhciByZXF1ZXN0Rmx1c2g7XG4vLyBUaGUgcG9zaXRpb24gb2YgdGhlIG5leHQgdGFzayB0byBleGVjdXRlIGluIHRoZSB0YXNrIHF1ZXVlLiBUaGlzIGlzXG4vLyBwcmVzZXJ2ZWQgYmV0d2VlbiBjYWxscyB0byBgZmx1c2hgIHNvIHRoYXQgaXQgY2FuIGJlIHJlc3VtZWQgaWZcbi8vIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLlxudmFyIGluZGV4ID0gMDtcbi8vIElmIGEgdGFzayBzY2hlZHVsZXMgYWRkaXRpb25hbCB0YXNrcyByZWN1cnNpdmVseSwgdGhlIHRhc2sgcXVldWUgY2FuIGdyb3dcbi8vIHVuYm91bmRlZC4gVG8gcHJldmVudCBtZW1vcnkgZXhoYXVzdGlvbiwgdGhlIHRhc2sgcXVldWUgd2lsbCBwZXJpb2RpY2FsbHlcbi8vIHRydW5jYXRlIGFscmVhZHktY29tcGxldGVkIHRhc2tzLlxudmFyIGNhcGFjaXR5ID0gMTAyNDtcblxuLy8gVGhlIGZsdXNoIGZ1bmN0aW9uIHByb2Nlc3NlcyBhbGwgdGFza3MgdGhhdCBoYXZlIGJlZW4gc2NoZWR1bGVkIHdpdGhcbi8vIGByYXdBc2FwYCB1bmxlc3MgYW5kIHVudGlsIG9uZSBvZiB0aG9zZSB0YXNrcyB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuLy8gSWYgYSB0YXNrIHRocm93cyBhbiBleGNlcHRpb24sIGBmbHVzaGAgZW5zdXJlcyB0aGF0IGl0cyBzdGF0ZSB3aWxsIHJlbWFpblxuLy8gY29uc2lzdGVudCBhbmQgd2lsbCByZXN1bWUgd2hlcmUgaXQgbGVmdCBvZmYgd2hlbiBjYWxsZWQgYWdhaW4uXG4vLyBIb3dldmVyLCBgZmx1c2hgIGRvZXMgbm90IG1ha2UgYW55IGFycmFuZ2VtZW50cyB0byBiZSBjYWxsZWQgYWdhaW4gaWYgYW5cbi8vIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB3aGlsZSAoaW5kZXggPCBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgICAvLyBBZHZhbmNlIHRoZSBpbmRleCBiZWZvcmUgY2FsbGluZyB0aGUgdGFzay4gVGhpcyBlbnN1cmVzIHRoYXQgd2Ugd2lsbFxuICAgICAgICAvLyBiZWdpbiBmbHVzaGluZyBvbiB0aGUgbmV4dCB0YXNrIHRoZSB0YXNrIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIHF1ZXVlW2N1cnJlbnRJbmRleF0uY2FsbCgpO1xuICAgICAgICAvLyBQcmV2ZW50IGxlYWtpbmcgbWVtb3J5IGZvciBsb25nIGNoYWlucyBvZiByZWN1cnNpdmUgY2FsbHMgdG8gYGFzYXBgLlxuICAgICAgICAvLyBJZiB3ZSBjYWxsIGBhc2FwYCB3aXRoaW4gdGFza3Mgc2NoZWR1bGVkIGJ5IGBhc2FwYCwgdGhlIHF1ZXVlIHdpbGxcbiAgICAgICAgLy8gZ3JvdywgYnV0IHRvIGF2b2lkIGFuIE8obikgd2FsayBmb3IgZXZlcnkgdGFzayB3ZSBleGVjdXRlLCB3ZSBkb24ndFxuICAgICAgICAvLyBzaGlmdCB0YXNrcyBvZmYgdGhlIHF1ZXVlIGFmdGVyIHRoZXkgaGF2ZSBiZWVuIGV4ZWN1dGVkLlxuICAgICAgICAvLyBJbnN0ZWFkLCB3ZSBwZXJpb2RpY2FsbHkgc2hpZnQgMTAyNCB0YXNrcyBvZmYgdGhlIHF1ZXVlLlxuICAgICAgICBpZiAoaW5kZXggPiBjYXBhY2l0eSkge1xuICAgICAgICAgICAgLy8gTWFudWFsbHkgc2hpZnQgYWxsIHZhbHVlcyBzdGFydGluZyBhdCB0aGUgaW5kZXggYmFjayB0byB0aGVcbiAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiB0aGUgcXVldWUuXG4gICAgICAgICAgICBmb3IgKHZhciBzY2FuID0gMCwgbmV3TGVuZ3RoID0gcXVldWUubGVuZ3RoIC0gaW5kZXg7IHNjYW4gPCBuZXdMZW5ndGg7IHNjYW4rKykge1xuICAgICAgICAgICAgICAgIHF1ZXVlW3NjYW5dID0gcXVldWVbc2NhbiArIGluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCAtPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIGluZGV4ID0gMDtcbiAgICBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBgcmVxdWVzdEZsdXNoYCBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHN0cmF0ZWd5IGJhc2VkIG9uIGRhdGEgY29sbGVjdGVkIGZyb21cbi8vIGV2ZXJ5IGF2YWlsYWJsZSBTYXVjZUxhYnMgU2VsZW5pdW0gd2ViIGRyaXZlciB3b3JrZXIgYXQgdGltZSBvZiB3cml0aW5nLlxuLy8gaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMW1HLTVVWUd1cDVxeEdkRU1Xa2hQNkJXQ3owNTNOVWIyRTFRb1VUVTE2dUEvZWRpdCNnaWQ9NzgzNzI0NTkzXG5cbi8vIFNhZmFyaSA2IGFuZCA2LjEgZm9yIGRlc2t0b3AsIGlQYWQsIGFuZCBpUGhvbmUgYXJlIHRoZSBvbmx5IGJyb3dzZXJzIHRoYXRcbi8vIGhhdmUgV2ViS2l0TXV0YXRpb25PYnNlcnZlciBidXQgbm90IHVuLXByZWZpeGVkIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXN0IHVzZSBgZ2xvYmFsYCBvciBgc2VsZmAgaW5zdGVhZCBvZiBgd2luZG93YCB0byB3b3JrIGluIGJvdGggZnJhbWVzIGFuZCB3ZWJcbi8vIHdvcmtlcnMuIGBnbG9iYWxgIGlzIGEgcHJvdmlzaW9uIG9mIEJyb3dzZXJpZnksIE1yLCBNcnMsIG9yIE1vcC5cblxuLyogZ2xvYmFscyBzZWxmICovXG52YXIgc2NvcGUgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogc2VsZjtcbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IHNjb3BlLk11dGF0aW9uT2JzZXJ2ZXIgfHwgc2NvcGUuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxuLy8gTXV0YXRpb25PYnNlcnZlcnMgYXJlIGRlc2lyYWJsZSBiZWNhdXNlIHRoZXkgaGF2ZSBoaWdoIHByaW9yaXR5IGFuZCB3b3JrXG4vLyByZWxpYWJseSBldmVyeXdoZXJlIHRoZXkgYXJlIGltcGxlbWVudGVkLlxuLy8gVGhleSBhcmUgaW1wbGVtZW50ZWQgaW4gYWxsIG1vZGVybiBicm93c2Vycy5cbi8vXG4vLyAtIEFuZHJvaWQgNC00LjNcbi8vIC0gQ2hyb21lIDI2LTM0XG4vLyAtIEZpcmVmb3ggMTQtMjlcbi8vIC0gSW50ZXJuZXQgRXhwbG9yZXIgMTFcbi8vIC0gaVBhZCBTYWZhcmkgNi03LjFcbi8vIC0gaVBob25lIFNhZmFyaSA3LTcuMVxuLy8gLSBTYWZhcmkgNi03XG5pZiAodHlwZW9mIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXF1ZXN0Rmx1c2ggPSBtYWtlUmVxdWVzdENhbGxGcm9tTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG5cbi8vIE1lc3NhZ2VDaGFubmVscyBhcmUgZGVzaXJhYmxlIGJlY2F1c2UgdGhleSBnaXZlIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIEhUTUxcbi8vIHRhc2sgcXVldWUsIGFyZSBpbXBsZW1lbnRlZCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMCwgU2FmYXJpIDUuMC0xLCBhbmQgT3BlcmFcbi8vIDExLTEyLCBhbmQgaW4gd2ViIHdvcmtlcnMgaW4gbWFueSBlbmdpbmVzLlxuLy8gQWx0aG91Z2ggbWVzc2FnZSBjaGFubmVscyB5aWVsZCB0byBhbnkgcXVldWVkIHJlbmRlcmluZyBhbmQgSU8gdGFza3MsIHRoZXlcbi8vIHdvdWxkIGJlIGJldHRlciB0aGFuIGltcG9zaW5nIHRoZSA0bXMgZGVsYXkgb2YgdGltZXJzLlxuLy8gSG93ZXZlciwgdGhleSBkbyBub3Qgd29yayByZWxpYWJseSBpbiBJbnRlcm5ldCBFeHBsb3JlciBvciBTYWZhcmkuXG5cbi8vIEludGVybmV0IEV4cGxvcmVyIDEwIGlzIHRoZSBvbmx5IGJyb3dzZXIgdGhhdCBoYXMgc2V0SW1tZWRpYXRlIGJ1dCBkb2VzXG4vLyBub3QgaGF2ZSBNdXRhdGlvbk9ic2VydmVycy5cbi8vIEFsdGhvdWdoIHNldEltbWVkaWF0ZSB5aWVsZHMgdG8gdGhlIGJyb3dzZXIncyByZW5kZXJlciwgaXQgd291bGQgYmVcbi8vIHByZWZlcnJhYmxlIHRvIGZhbGxpbmcgYmFjayB0byBzZXRUaW1lb3V0IHNpbmNlIGl0IGRvZXMgbm90IGhhdmVcbi8vIHRoZSBtaW5pbXVtIDRtcyBwZW5hbHR5LlxuLy8gVW5mb3J0dW5hdGVseSB0aGVyZSBhcHBlYXJzIHRvIGJlIGEgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwIE1vYmlsZSAoYW5kXG4vLyBEZXNrdG9wIHRvIGEgbGVzc2VyIGV4dGVudCkgdGhhdCByZW5kZXJzIGJvdGggc2V0SW1tZWRpYXRlIGFuZFxuLy8gTWVzc2FnZUNoYW5uZWwgdXNlbGVzcyBmb3IgdGhlIHB1cnBvc2VzIG9mIEFTQVAuXG4vLyBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EvaXNzdWVzLzM5NlxuXG4vLyBUaW1lcnMgYXJlIGltcGxlbWVudGVkIHVuaXZlcnNhbGx5LlxuLy8gV2UgZmFsbCBiYWNrIHRvIHRpbWVycyBpbiB3b3JrZXJzIGluIG1vc3QgZW5naW5lcywgYW5kIGluIGZvcmVncm91bmRcbi8vIGNvbnRleHRzIGluIHRoZSBmb2xsb3dpbmcgYnJvd3NlcnMuXG4vLyBIb3dldmVyLCBub3RlIHRoYXQgZXZlbiB0aGlzIHNpbXBsZSBjYXNlIHJlcXVpcmVzIG51YW5jZXMgdG8gb3BlcmF0ZSBpbiBhXG4vLyBicm9hZCBzcGVjdHJ1bSBvZiBicm93c2Vycy5cbi8vXG4vLyAtIEZpcmVmb3ggMy0xM1xuLy8gLSBJbnRlcm5ldCBFeHBsb3JlciA2LTlcbi8vIC0gaVBhZCBTYWZhcmkgNC4zXG4vLyAtIEx5bnggMi44Ljdcbn0gZWxzZSB7XG4gICAgcmVxdWVzdEZsdXNoID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKGZsdXNoKTtcbn1cblxuLy8gYHJlcXVlc3RGbHVzaGAgcmVxdWVzdHMgdGhhdCB0aGUgaGlnaCBwcmlvcml0eSBldmVudCBxdWV1ZSBiZSBmbHVzaGVkIGFzXG4vLyBzb29uIGFzIHBvc3NpYmxlLlxuLy8gVGhpcyBpcyB1c2VmdWwgdG8gcHJldmVudCBhbiBlcnJvciB0aHJvd24gaW4gYSB0YXNrIGZyb20gc3RhbGxpbmcgdGhlIGV2ZW50XG4vLyBxdWV1ZSBpZiB0aGUgZXhjZXB0aW9uIGhhbmRsZWQgYnkgTm9kZS5qc+KAmXNcbi8vIGBwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIilgIG9yIGJ5IGEgZG9tYWluLlxucmF3QXNhcC5yZXF1ZXN0Rmx1c2ggPSByZXF1ZXN0Rmx1c2g7XG5cbi8vIFRvIHJlcXVlc3QgYSBoaWdoIHByaW9yaXR5IGV2ZW50LCB3ZSBpbmR1Y2UgYSBtdXRhdGlvbiBvYnNlcnZlciBieSB0b2dnbGluZ1xuLy8gdGhlIHRleHQgb2YgYSB0ZXh0IG5vZGUgYmV0d2VlbiBcIjFcIiBhbmQgXCItMVwiLlxuZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbU11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgICB2YXIgdG9nZ2xlID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbiAgICAgICAgdG9nZ2xlID0gLXRvZ2dsZTtcbiAgICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlO1xuICAgIH07XG59XG5cbi8vIFRoZSBtZXNzYWdlIGNoYW5uZWwgdGVjaG5pcXVlIHdhcyBkaXNjb3ZlcmVkIGJ5IE1hbHRlIFVibCBhbmQgd2FzIHRoZVxuLy8gb3JpZ2luYWwgZm91bmRhdGlvbiBmb3IgdGhpcyBsaWJyYXJ5LlxuLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcblxuLy8gU2FmYXJpIDYuMC41IChhdCBsZWFzdCkgaW50ZXJtaXR0ZW50bHkgZmFpbHMgdG8gY3JlYXRlIG1lc3NhZ2UgcG9ydHMgb24gYVxuLy8gcGFnZSdzIGZpcnN0IGxvYWQuIFRoYW5rZnVsbHksIHRoaXMgdmVyc2lvbiBvZiBTYWZhcmkgc3VwcG9ydHNcbi8vIE11dGF0aW9uT2JzZXJ2ZXJzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGZhbGwgYmFjayBpbiB0aGF0IGNhc2UuXG5cbi8vIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NZXNzYWdlQ2hhbm5lbChjYWxsYmFjaykge1xuLy8gICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4vLyAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBjYWxsYmFjaztcbi8vICAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4vLyAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4vLyAgICAgfTtcbi8vIH1cblxuLy8gRm9yIHJlYXNvbnMgZXhwbGFpbmVkIGFib3ZlLCB3ZSBhcmUgYWxzbyB1bmFibGUgdG8gdXNlIGBzZXRJbW1lZGlhdGVgXG4vLyB1bmRlciBhbnkgY2lyY3Vtc3RhbmNlcy5cbi8vIEV2ZW4gaWYgd2Ugd2VyZSwgdGhlcmUgaXMgYW5vdGhlciBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4vLyBJdCBpcyBub3Qgc3VmZmljaWVudCB0byBhc3NpZ24gYHNldEltbWVkaWF0ZWAgdG8gYHJlcXVlc3RGbHVzaGAgYmVjYXVzZVxuLy8gYHNldEltbWVkaWF0ZWAgbXVzdCBiZSBjYWxsZWQgKmJ5IG5hbWUqIGFuZCB0aGVyZWZvcmUgbXVzdCBiZSB3cmFwcGVkIGluIGFcbi8vIGNsb3N1cmUuXG4vLyBOZXZlciBmb3JnZXQuXG5cbi8vIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21TZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbi8vICAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4vLyAgICAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4vLyAgICAgfTtcbi8vIH1cblxuLy8gU2FmYXJpIDYuMCBoYXMgYSBwcm9ibGVtIHdoZXJlIHRpbWVycyB3aWxsIGdldCBsb3N0IHdoaWxlIHRoZSB1c2VyIGlzXG4vLyBzY3JvbGxpbmcuIFRoaXMgcHJvYmxlbSBkb2VzIG5vdCBpbXBhY3QgQVNBUCBiZWNhdXNlIFNhZmFyaSA2LjAgc3VwcG9ydHNcbi8vIG11dGF0aW9uIG9ic2VydmVycywgc28gdGhhdCBpbXBsZW1lbnRhdGlvbiBpcyB1c2VkIGluc3RlYWQuXG4vLyBIb3dldmVyLCBpZiB3ZSBldmVyIGVsZWN0IHRvIHVzZSB0aW1lcnMgaW4gU2FmYXJpLCB0aGUgcHJldmFsZW50IHdvcmstYXJvdW5kXG4vLyBpcyB0byBhZGQgYSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgdGhhdCBjYWxscyBmb3IgYSBmbHVzaC5cblxuLy8gYHNldFRpbWVvdXRgIGRvZXMgbm90IGNhbGwgdGhlIHBhc3NlZCBjYWxsYmFjayBpZiB0aGUgZGVsYXkgaXMgbGVzcyB0aGFuXG4vLyBhcHByb3hpbWF0ZWx5IDcgaW4gd2ViIHdvcmtlcnMgaW4gRmlyZWZveCA4IHRocm91Z2ggMTgsIGFuZCBzb21ldGltZXMgbm90XG4vLyBldmVuIHRoZW4uXG5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcihjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbiAgICAgICAgLy8gV2UgZGlzcGF0Y2ggYSB0aW1lb3V0IHdpdGggYSBzcGVjaWZpZWQgZGVsYXkgb2YgMCBmb3IgZW5naW5lcyB0aGF0XG4gICAgICAgIC8vIGNhbiByZWxpYWJseSBhY2NvbW1vZGF0ZSB0aGF0IHJlcXVlc3QuIFRoaXMgd2lsbCB1c3VhbGx5IGJlIHNuYXBwZWRcbiAgICAgICAgLy8gdG8gYSA0IG1pbGlzZWNvbmQgZGVsYXksIGJ1dCBvbmNlIHdlJ3JlIGZsdXNoaW5nLCB0aGVyZSdzIG5vIGRlbGF5XG4gICAgICAgIC8vIGJldHdlZW4gZXZlbnRzLlxuICAgICAgICB2YXIgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoaGFuZGxlVGltZXIsIDApO1xuICAgICAgICAvLyBIb3dldmVyLCBzaW5jZSB0aGlzIHRpbWVyIGdldHMgZnJlcXVlbnRseSBkcm9wcGVkIGluIEZpcmVmb3hcbiAgICAgICAgLy8gd29ya2Vycywgd2UgZW5saXN0IGFuIGludGVydmFsIGhhbmRsZSB0aGF0IHdpbGwgdHJ5IHRvIGZpcmVcbiAgICAgICAgLy8gYW4gZXZlbnQgMjAgdGltZXMgcGVyIHNlY29uZCB1bnRpbCBpdCBzdWNjZWVkcy5cbiAgICAgICAgdmFyIGludGVydmFsSGFuZGxlID0gc2V0SW50ZXJ2YWwoaGFuZGxlVGltZXIsIDUwKTtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVUaW1lcigpIHtcbiAgICAgICAgICAgIC8vIFdoaWNoZXZlciB0aW1lciBzdWNjZWVkcyB3aWxsIGNhbmNlbCBib3RoIHRpbWVycyBhbmRcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbEhhbmRsZSk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gVGhpcyBpcyBmb3IgYGFzYXAuanNgIG9ubHkuXG4vLyBJdHMgbmFtZSB3aWxsIGJlIHBlcmlvZGljYWxseSByYW5kb21pemVkIHRvIGJyZWFrIGFueSBjb2RlIHRoYXQgZGVwZW5kcyBvblxuLy8gaXRzIGV4aXN0ZW5jZS5cbnJhd0FzYXAubWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyO1xuXG4vLyBBU0FQIHdhcyBvcmlnaW5hbGx5IGEgbmV4dFRpY2sgc2hpbSBpbmNsdWRlZCBpbiBRLiBUaGlzIHdhcyBmYWN0b3JlZCBvdXRcbi8vIGludG8gdGhpcyBBU0FQIHBhY2thZ2UuIEl0IHdhcyBsYXRlciBhZGFwdGVkIHRvIFJTVlAgd2hpY2ggbWFkZSBmdXJ0aGVyXG4vLyBhbWVuZG1lbnRzLiBUaGVzZSBkZWNpc2lvbnMsIHBhcnRpY3VsYXJseSB0byBtYXJnaW5hbGl6ZSBNZXNzYWdlQ2hhbm5lbCBhbmRcbi8vIHRvIGNhcHR1cmUgdGhlIE11dGF0aW9uT2JzZXJ2ZXIgaW1wbGVtZW50YXRpb24gaW4gYSBjbG9zdXJlLCB3ZXJlIGludGVncmF0ZWRcbi8vIGJhY2sgaW50byBBU0FQIHByb3Blci5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aWxkZWlvL3JzdnAuanMvYmxvYi9jZGRmNzIzMjU0NmE5Y2Y4NTg1MjRiNzVjZGU2ZjllZGY3MjYyMGE3L2xpYi9yc3ZwL2FzYXAuanNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2FzYXAvYnJvd3Nlci1yYXcuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gTUlUIGxpY2Vuc2UgKGJ5IEVsYW4gU2hhbmtlcikuXG4oZnVuY3Rpb24oZ2xvYmFscykge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGV4ZWN1dGVTeW5jID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nKXtcbiAgICAgIGFyZ3NbMF0uYXBwbHkobnVsbCwgYXJncy5zcGxpY2UoMSkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZXhlY3V0ZUFzeW5jID0gZnVuY3Rpb24oZm4pe1xuICAgIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MubmV4dFRpY2spIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG1ha2VJdGVyYXRvciA9IGZ1bmN0aW9uICh0YXNrcykge1xuICAgIHZhciBtYWtlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCkge1xuICAgICAgICAgIHRhc2tzW2luZGV4XS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5uZXh0KCk7XG4gICAgICB9O1xuICAgICAgZm4ubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChpbmRleCA8IHRhc2tzLmxlbmd0aCAtIDEpID8gbWFrZUNhbGxiYWNrKGluZGV4ICsgMSk6IG51bGw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgcmV0dXJuIG1ha2VDYWxsYmFjaygwKTtcbiAgfTtcbiAgXG4gIHZhciBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24obWF5YmVBcnJheSl7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtYXliZUFycmF5KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICB2YXIgd2F0ZXJmYWxsID0gZnVuY3Rpb24gKHRhc2tzLCBjYWxsYmFjaywgZm9yY2VBc3luYykge1xuICAgIHZhciBuZXh0VGljayA9IGZvcmNlQXN5bmMgPyBleGVjdXRlQXN5bmMgOiBleGVjdXRlU3luYztcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgIGlmICghX2lzQXJyYXkodGFza3MpKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byB3YXRlcmZhbGwgbXVzdCBiZSBhbiBhcnJheSBvZiBmdW5jdGlvbnMnKTtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgICBpZiAoIXRhc2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHZhciB3cmFwSXRlcmF0b3IgPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICBhcmdzLnB1c2god3JhcEl0ZXJhdG9yKG5leHQpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJncy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXRlcmF0b3IuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICB3cmFwSXRlcmF0b3IobWFrZUl0ZXJhdG9yKHRhc2tzKSkoKTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHdhdGVyZmFsbDtcbiAgICB9KTsgLy8gUmVxdWlyZUpTXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdhdGVyZmFsbDsgLy8gQ29tbW9uSlNcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWxzLndhdGVyZmFsbCA9IHdhdGVyZmFsbDsgLy8gPHNjcmlwdD5cbiAgfVxufSkodGhpcyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hLXN5bmMtd2F0ZXJmYWxsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9kZXMgPSByZXF1aXJlKCcuL25vZGVzJyk7XG52YXIgbGliID0gcmVxdWlyZSgnLi9saWInKTtcblxudmFyIHN5bSA9IDA7XG5mdW5jdGlvbiBnZW5zeW0oKSB7XG4gIHJldHVybiAnaG9sZV8nICsgc3ltKys7XG59XG5cbi8vIGNvcHktb24td3JpdGUgdmVyc2lvbiBvZiBtYXBcbmZ1bmN0aW9uIG1hcENPVyhhcnIsIGZ1bmMpIHtcbiAgdmFyIHJlcyA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgaXRlbSA9IGZ1bmMoYXJyW2ldKTtcblxuICAgIGlmIChpdGVtICE9PSBhcnJbaV0pIHtcbiAgICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJlcyA9IGFyci5zbGljZSgpO1xuICAgICAgfVxuXG4gICAgICByZXNbaV0gPSBpdGVtO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgfHwgYXJyO1xufVxuXG5mdW5jdGlvbiB3YWxrKGFzdCwgZnVuYywgZGVwdGhGaXJzdCkge1xuICBpZiAoIShhc3QgaW5zdGFuY2VvZiBub2Rlcy5Ob2RlKSkge1xuICAgIHJldHVybiBhc3Q7XG4gIH1cblxuICBpZiAoIWRlcHRoRmlyc3QpIHtcbiAgICBjb25zdCBhc3RUID0gZnVuYyhhc3QpO1xuXG4gICAgaWYgKGFzdFQgJiYgYXN0VCAhPT0gYXN0KSB7XG4gICAgICByZXR1cm4gYXN0VDtcbiAgICB9XG4gIH1cblxuICBpZiAoYXN0IGluc3RhbmNlb2Ygbm9kZXMuTm9kZUxpc3QpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG1hcENPVyhhc3QuY2hpbGRyZW4sIChub2RlKSA9PiB3YWxrKG5vZGUsIGZ1bmMsIGRlcHRoRmlyc3QpKTtcblxuICAgIGlmIChjaGlsZHJlbiAhPT0gYXN0LmNoaWxkcmVuKSB7XG4gICAgICBhc3QgPSBuZXcgbm9kZXNbYXN0LnR5cGVuYW1lXShhc3QubGluZW5vLCBhc3QuY29sbm8sIGNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXN0IGluc3RhbmNlb2Ygbm9kZXMuQ2FsbEV4dGVuc2lvbikge1xuICAgIGNvbnN0IGFyZ3MgPSB3YWxrKGFzdC5hcmdzLCBmdW5jLCBkZXB0aEZpcnN0KTtcbiAgICBjb25zdCBjb250ZW50QXJncyA9IG1hcENPVyhhc3QuY29udGVudEFyZ3MsIChub2RlKSA9PiB3YWxrKG5vZGUsIGZ1bmMsIGRlcHRoRmlyc3QpKTtcblxuICAgIGlmIChhcmdzICE9PSBhc3QuYXJncyB8fCBjb250ZW50QXJncyAhPT0gYXN0LmNvbnRlbnRBcmdzKSB7XG4gICAgICBhc3QgPSBuZXcgbm9kZXNbYXN0LnR5cGVuYW1lXShhc3QuZXh0TmFtZSwgYXN0LnByb3AsIGFyZ3MsIGNvbnRlbnRBcmdzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJvcHMgPSBhc3QuZmllbGRzLm1hcCgoZmllbGQpID0+IGFzdFtmaWVsZF0pO1xuICAgIGNvbnN0IHByb3BzVCA9IG1hcENPVyhwcm9wcywgKHByb3ApID0+IHdhbGsocHJvcCwgZnVuYywgZGVwdGhGaXJzdCkpO1xuXG4gICAgaWYgKHByb3BzVCAhPT0gcHJvcHMpIHtcbiAgICAgIGFzdCA9IG5ldyBub2Rlc1thc3QudHlwZW5hbWVdKGFzdC5saW5lbm8sIGFzdC5jb2xubyk7XG4gICAgICBwcm9wc1QuZm9yRWFjaCgocHJvcCwgaSkgPT4ge1xuICAgICAgICBhc3RbYXN0LmZpZWxkc1tpXV0gPSBwcm9wO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlcHRoRmlyc3QgPyAoZnVuYyhhc3QpIHx8IGFzdCkgOiBhc3Q7XG59XG5cbmZ1bmN0aW9uIGRlcHRoV2Fsayhhc3QsIGZ1bmMpIHtcbiAgcmV0dXJuIHdhbGsoYXN0LCBmdW5jLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gX2xpZnRGaWx0ZXJzKG5vZGUsIGFzeW5jRmlsdGVycywgcHJvcCkge1xuICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICB2YXIgd2Fsa2VkID0gZGVwdGhXYWxrKHByb3AgPyBub2RlW3Byb3BdIDogbm9kZSwgKGRlc2NOb2RlKSA9PiB7XG4gICAgbGV0IHN5bWJvbDtcbiAgICBpZiAoZGVzY05vZGUgaW5zdGFuY2VvZiBub2Rlcy5CbG9jaykge1xuICAgICAgcmV0dXJuIGRlc2NOb2RlO1xuICAgIH0gZWxzZSBpZiAoKGRlc2NOb2RlIGluc3RhbmNlb2Ygbm9kZXMuRmlsdGVyICYmXG4gICAgICBsaWIuaW5kZXhPZihhc3luY0ZpbHRlcnMsIGRlc2NOb2RlLm5hbWUudmFsdWUpICE9PSAtMSkgfHxcbiAgICAgIGRlc2NOb2RlIGluc3RhbmNlb2Ygbm9kZXMuQ2FsbEV4dGVuc2lvbkFzeW5jKSB7XG4gICAgICBzeW1ib2wgPSBuZXcgbm9kZXMuU3ltYm9sKGRlc2NOb2RlLmxpbmVubyxcbiAgICAgICAgZGVzY05vZGUuY29sbm8sXG4gICAgICAgIGdlbnN5bSgpKTtcblxuICAgICAgY2hpbGRyZW4ucHVzaChuZXcgbm9kZXMuRmlsdGVyQXN5bmMoZGVzY05vZGUubGluZW5vLFxuICAgICAgICBkZXNjTm9kZS5jb2xubyxcbiAgICAgICAgZGVzY05vZGUubmFtZSxcbiAgICAgICAgZGVzY05vZGUuYXJncyxcbiAgICAgICAgc3ltYm9sKSk7XG4gICAgfVxuICAgIHJldHVybiBzeW1ib2w7XG4gIH0pO1xuXG4gIGlmIChwcm9wKSB7XG4gICAgbm9kZVtwcm9wXSA9IHdhbGtlZDtcbiAgfSBlbHNlIHtcbiAgICBub2RlID0gd2Fsa2VkO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG5cbiAgICByZXR1cm4gbmV3IG5vZGVzLk5vZGVMaXN0KFxuICAgICAgbm9kZS5saW5lbm8sXG4gICAgICBub2RlLmNvbG5vLFxuICAgICAgY2hpbGRyZW5cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxpZnRGaWx0ZXJzKGFzdCwgYXN5bmNGaWx0ZXJzKSB7XG4gIHJldHVybiBkZXB0aFdhbGsoYXN0LCAobm9kZSkgPT4ge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuT3V0cHV0KSB7XG4gICAgICByZXR1cm4gX2xpZnRGaWx0ZXJzKG5vZGUsIGFzeW5jRmlsdGVycyk7XG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuU2V0KSB7XG4gICAgICByZXR1cm4gX2xpZnRGaWx0ZXJzKG5vZGUsIGFzeW5jRmlsdGVycywgJ3ZhbHVlJyk7XG4gICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuRm9yKSB7XG4gICAgICByZXR1cm4gX2xpZnRGaWx0ZXJzKG5vZGUsIGFzeW5jRmlsdGVycywgJ2FycicpO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLklmKSB7XG4gICAgICByZXR1cm4gX2xpZnRGaWx0ZXJzKG5vZGUsIGFzeW5jRmlsdGVycywgJ2NvbmQnKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5DYWxsRXh0ZW5zaW9uKSB7XG4gICAgICByZXR1cm4gX2xpZnRGaWx0ZXJzKG5vZGUsIGFzeW5jRmlsdGVycywgJ2FyZ3MnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBsaWZ0U3VwZXIoYXN0KSB7XG4gIHJldHVybiB3YWxrKGFzdCwgKGJsb2NrTm9kZSkgPT4ge1xuICAgIGlmICghKGJsb2NrTm9kZSBpbnN0YW5jZW9mIG5vZGVzLkJsb2NrKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBoYXNTdXBlciA9IGZhbHNlO1xuICAgIGNvbnN0IHN5bWJvbCA9IGdlbnN5bSgpO1xuXG4gICAgYmxvY2tOb2RlLmJvZHkgPSB3YWxrKGJsb2NrTm9kZS5ib2R5LCAobm9kZSkgPT4geyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLkZ1bkNhbGwgJiYgbm9kZS5uYW1lLnZhbHVlID09PSAnc3VwZXInKSB7XG4gICAgICAgIGhhc1N1cGVyID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBub2Rlcy5TeW1ib2wobm9kZS5saW5lbm8sIG5vZGUuY29sbm8sIHN5bWJvbCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoaGFzU3VwZXIpIHtcbiAgICAgIGJsb2NrTm9kZS5ib2R5LmNoaWxkcmVuLnVuc2hpZnQobmV3IG5vZGVzLlN1cGVyKFxuICAgICAgICAwLCAwLCBibG9ja05vZGUubmFtZSwgbmV3IG5vZGVzLlN5bWJvbCgwLCAwLCBzeW1ib2wpXG4gICAgICApKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0U3RhdGVtZW50cyhhc3QpIHtcbiAgcmV0dXJuIGRlcHRoV2Fsayhhc3QsIChub2RlKSA9PiB7XG4gICAgaWYgKCEobm9kZSBpbnN0YW5jZW9mIG5vZGVzLklmKSAmJiAhKG5vZGUgaW5zdGFuY2VvZiBub2Rlcy5Gb3IpKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGxldCBhc3luYyA9IGZhbHNlO1xuICAgIHdhbGsobm9kZSwgKGNoaWxkKSA9PiB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBub2Rlcy5GaWx0ZXJBc3luYyB8fFxuICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIG5vZGVzLklmQXN5bmMgfHxcbiAgICAgICAgY2hpbGQgaW5zdGFuY2VvZiBub2Rlcy5Bc3luY0VhY2ggfHxcbiAgICAgICAgY2hpbGQgaW5zdGFuY2VvZiBub2Rlcy5Bc3luY0FsbCB8fFxuICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIG5vZGVzLkNhbGxFeHRlbnNpb25Bc3luYykge1xuICAgICAgICBhc3luYyA9IHRydWU7XG4gICAgICAgIC8vIFN0b3AgaXRlcmF0aW5nIGJ5IHJldHVybmluZyB0aGUgbm9kZVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuXG4gICAgaWYgKGFzeW5jKSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG5vZGVzLklmKSB7XG4gICAgICAgIHJldHVybiBuZXcgbm9kZXMuSWZBc3luYyhcbiAgICAgICAgICBub2RlLmxpbmVubyxcbiAgICAgICAgICBub2RlLmNvbG5vLFxuICAgICAgICAgIG5vZGUuY29uZCxcbiAgICAgICAgICBub2RlLmJvZHksXG4gICAgICAgICAgbm9kZS5lbHNlX1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2Ygbm9kZXMuRm9yICYmICEobm9kZSBpbnN0YW5jZW9mIG5vZGVzLkFzeW5jQWxsKSkge1xuICAgICAgICByZXR1cm4gbmV3IG5vZGVzLkFzeW5jRWFjaChcbiAgICAgICAgICBub2RlLmxpbmVubyxcbiAgICAgICAgICBub2RlLmNvbG5vLFxuICAgICAgICAgIG5vZGUuYXJyLFxuICAgICAgICAgIG5vZGUubmFtZSxcbiAgICAgICAgICBub2RlLmJvZHksXG4gICAgICAgICAgbm9kZS5lbHNlX1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3BzKGFzdCwgYXN5bmNGaWx0ZXJzKSB7XG4gIHJldHVybiBjb252ZXJ0U3RhdGVtZW50cyhsaWZ0U3VwZXIobGlmdEZpbHRlcnMoYXN0LCBhc3luY0ZpbHRlcnMpKSk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShhc3QsIGFzeW5jRmlsdGVycykge1xuICByZXR1cm4gY3BzKGFzdCwgYXN5bmNGaWx0ZXJzIHx8IFtdKTtcbn1cblxuLy8gdmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG4vLyB2YXIgc3JjID0gJ2hlbGxvIHslIGZvbyAlfXslIGVuZGZvbyAlfSBlbmQnO1xuLy8gdmFyIGFzdCA9IHRyYW5zZm9ybShwYXJzZXIucGFyc2Uoc3JjLCBbbmV3IEZvb0V4dGVuc2lvbigpXSksIFsnYmFyJ10pO1xuLy8gbm9kZXMucHJpbnROb2Rlcyhhc3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9udW5qdWNrcy9zcmMvdHJhbnNmb3JtZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBsaWIgPSByZXF1aXJlKCcuL2xpYicpO1xudmFyIHIgPSByZXF1aXJlKCcuL3J1bnRpbWUnKTtcblxudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5mdW5jdGlvbiBub3JtYWxpemUodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0cy5hYnMgPSBNYXRoLmFicztcblxuZnVuY3Rpb24gaXNOYU4obnVtKSB7XG4gIHJldHVybiBudW0gIT09IG51bTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuZnVuY3Rpb24gYmF0Y2goYXJyLCBsaW5lY291bnQsIGZpbGxXaXRoKSB7XG4gIHZhciBpO1xuICB2YXIgcmVzID0gW107XG4gIHZhciB0bXAgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGkgJSBsaW5lY291bnQgPT09IDAgJiYgdG1wLmxlbmd0aCkge1xuICAgICAgcmVzLnB1c2godG1wKTtcbiAgICAgIHRtcCA9IFtdO1xuICAgIH1cblxuICAgIHRtcC5wdXNoKGFycltpXSk7XG4gIH1cblxuICBpZiAodG1wLmxlbmd0aCkge1xuICAgIGlmIChmaWxsV2l0aCkge1xuICAgICAgZm9yIChpID0gdG1wLmxlbmd0aDsgaSA8IGxpbmVjb3VudDsgaSsrKSB7XG4gICAgICAgIHRtcC5wdXNoKGZpbGxXaXRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXMucHVzaCh0bXApO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0cy5iYXRjaCA9IGJhdGNoO1xuXG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICBzdHIgPSBub3JtYWxpemUoc3RyLCAnJyk7XG4gIGNvbnN0IHJldCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gci5jb3B5U2FmZW5lc3Moc3RyLCByZXQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyByZXQuc2xpY2UoMSkpO1xufVxuXG5leHBvcnRzLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuXG5mdW5jdGlvbiBjZW50ZXIoc3RyLCB3aWR0aCkge1xuICBzdHIgPSBub3JtYWxpemUoc3RyLCAnJyk7XG4gIHdpZHRoID0gd2lkdGggfHwgODA7XG5cbiAgaWYgKHN0ci5sZW5ndGggPj0gd2lkdGgpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgY29uc3Qgc3BhY2VzID0gd2lkdGggLSBzdHIubGVuZ3RoO1xuICBjb25zdCBwcmUgPSBsaWIucmVwZWF0KCcgJywgKHNwYWNlcyAvIDIpIC0gKHNwYWNlcyAlIDIpKTtcbiAgY29uc3QgcG9zdCA9IGxpYi5yZXBlYXQoJyAnLCBzcGFjZXMgLyAyKTtcbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKHN0ciwgcHJlICsgc3RyICsgcG9zdCk7XG59XG5cbmV4cG9ydHMuY2VudGVyID0gY2VudGVyO1xuXG5mdW5jdGlvbiBkZWZhdWx0Xyh2YWwsIGRlZiwgYm9vbCkge1xuICBpZiAoYm9vbCkge1xuICAgIHJldHVybiB2YWwgfHwgZGVmO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAodmFsICE9PSB1bmRlZmluZWQpID8gdmFsIDogZGVmO1xuICB9XG59XG5cbi8vIFRPRE86IGl0IGlzIGNvbmZ1c2luZyB0byBleHBvcnQgc29tZXRoaW5nIGNhbGxlZCAnZGVmYXVsdCdcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGRlZmF1bHRfOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuXG5mdW5jdGlvbiBkaWN0c29ydCh2YWwsIGNhc2VTZW5zaXRpdmUsIGJ5KSB7XG4gIGlmICghbGliLmlzT2JqZWN0KHZhbCkpIHtcbiAgICB0aHJvdyBuZXcgbGliLlRlbXBsYXRlRXJyb3IoJ2RpY3Rzb3J0IGZpbHRlcjogdmFsIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICBsZXQgYXJyYXkgPSBbXTtcbiAgLy8gZGVsaWJlcmF0ZWx5IGluY2x1ZGUgcHJvcGVydGllcyBmcm9tIHRoZSBvYmplY3QncyBwcm90b3R5cGVcbiAgZm9yIChsZXQgayBpbiB2YWwpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW4sIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgYXJyYXkucHVzaChbaywgdmFsW2tdXSk7XG4gIH1cblxuICBsZXQgc2k7XG4gIGlmIChieSA9PT0gdW5kZWZpbmVkIHx8IGJ5ID09PSAna2V5Jykge1xuICAgIHNpID0gMDtcbiAgfSBlbHNlIGlmIChieSA9PT0gJ3ZhbHVlJykge1xuICAgIHNpID0gMTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgbGliLlRlbXBsYXRlRXJyb3IoXG4gICAgICAnZGljdHNvcnQgZmlsdGVyOiBZb3UgY2FuIG9ubHkgc29ydCBieSBlaXRoZXIga2V5IG9yIHZhbHVlJyk7XG4gIH1cblxuICBhcnJheS5zb3J0KCh0MSwgdDIpID0+IHtcbiAgICB2YXIgYSA9IHQxW3NpXTtcbiAgICB2YXIgYiA9IHQyW3NpXTtcblxuICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgaWYgKGxpYi5pc1N0cmluZyhhKSkge1xuICAgICAgICBhID0gYS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGxpYi5pc1N0cmluZyhiKSkge1xuICAgICAgICBiID0gYi50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhID4gYiA/IDEgOiAoYSA9PT0gYiA/IDAgOiAtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgfSk7XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnRzLmRpY3Rzb3J0ID0gZGljdHNvcnQ7XG5cbmZ1bmN0aW9uIGR1bXAob2JqLCBzcGFjZXMpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgc3BhY2VzKTtcbn1cblxuZXhwb3J0cy5kdW1wID0gZHVtcDtcblxuZnVuY3Rpb24gZXNjYXBlKHN0cikge1xuICBpZiAoc3RyIGluc3RhbmNlb2Ygci5TYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBzdHIgPSAoc3RyID09PSBudWxsIHx8IHN0ciA9PT0gdW5kZWZpbmVkKSA/ICcnIDogc3RyO1xuICByZXR1cm4gci5tYXJrU2FmZShsaWIuZXNjYXBlKHN0ci50b1N0cmluZygpKSk7XG59XG5cbmV4cG9ydHMuZXNjYXBlID0gZXNjYXBlO1xuXG5mdW5jdGlvbiBzYWZlKHN0cikge1xuICBpZiAoc3RyIGluc3RhbmNlb2Ygci5TYWZlU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuICBzdHIgPSAoc3RyID09PSBudWxsIHx8IHN0ciA9PT0gdW5kZWZpbmVkKSA/ICcnIDogc3RyO1xuICByZXR1cm4gci5tYXJrU2FmZShzdHIudG9TdHJpbmcoKSk7XG59XG5cbmV4cG9ydHMuc2FmZSA9IHNhZmU7XG5cbmZ1bmN0aW9uIGZpcnN0KGFycikge1xuICByZXR1cm4gYXJyWzBdO1xufVxuXG5leHBvcnRzLmZpcnN0ID0gZmlyc3Q7XG5cbmZ1bmN0aW9uIGZvcmNlZXNjYXBlKHN0cikge1xuICBzdHIgPSAoc3RyID09PSBudWxsIHx8IHN0ciA9PT0gdW5kZWZpbmVkKSA/ICcnIDogc3RyO1xuICByZXR1cm4gci5tYXJrU2FmZShsaWIuZXNjYXBlKHN0ci50b1N0cmluZygpKSk7XG59XG5cbmV4cG9ydHMuZm9yY2Vlc2NhcGUgPSBmb3JjZWVzY2FwZTtcblxuZnVuY3Rpb24gZ3JvdXBieShhcnIsIGF0dHIpIHtcbiAgcmV0dXJuIGxpYi5ncm91cEJ5KGFyciwgYXR0ciwgdGhpcy5lbnYub3B0cy50aHJvd09uVW5kZWZpbmVkKTtcbn1cblxuZXhwb3J0cy5ncm91cGJ5ID0gZ3JvdXBieTtcblxuZnVuY3Rpb24gaW5kZW50KHN0ciwgd2lkdGgsIGluZGVudGZpcnN0KSB7XG4gIHN0ciA9IG5vcm1hbGl6ZShzdHIsICcnKTtcblxuICBpZiAoc3RyID09PSAnJykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHdpZHRoID0gd2lkdGggfHwgNDtcbiAgLy8gbGV0IHJlcyA9ICcnO1xuICBjb25zdCBsaW5lcyA9IHN0ci5zcGxpdCgnXFxuJyk7XG4gIGNvbnN0IHNwID0gbGliLnJlcGVhdCgnICcsIHdpZHRoKTtcblxuICBjb25zdCByZXMgPSBsaW5lcy5tYXAoKGwsIGkpID0+IHtcbiAgICByZXR1cm4gKGkgPT09IDAgJiYgIWluZGVudGZpcnN0KSA/IGwgOiBgJHtzcH0ke2x9YDtcbiAgfSkuam9pbignXFxuJyk7XG5cbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKHN0ciwgcmVzKTtcbn1cblxuZXhwb3J0cy5pbmRlbnQgPSBpbmRlbnQ7XG5cbmZ1bmN0aW9uIGpvaW4oYXJyLCBkZWwsIGF0dHIpIHtcbiAgZGVsID0gZGVsIHx8ICcnO1xuXG4gIGlmIChhdHRyKSB7XG4gICAgYXJyID0gbGliLm1hcChhcnIsICh2KSA9PiB2W2F0dHJdKTtcbiAgfVxuXG4gIHJldHVybiBhcnIuam9pbihkZWwpO1xufVxuXG5leHBvcnRzLmpvaW4gPSBqb2luO1xuXG5mdW5jdGlvbiBsYXN0KGFycikge1xuICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cblxuZXhwb3J0cy5sYXN0ID0gbGFzdDtcblxuZnVuY3Rpb24gbGVuZ3RoRmlsdGVyKHZhbCkge1xuICB2YXIgdmFsdWUgPSBub3JtYWxpemUodmFsLCAnJyk7XG5cbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoXG4gICAgICAodHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCkgfHxcbiAgICAgICh0eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlIGluc3RhbmNlb2YgU2V0KVxuICAgICkge1xuICAgICAgLy8gRUNNQVNjcmlwdCAyMDE1IE1hcHMgYW5kIFNldHNcbiAgICAgIHJldHVybiB2YWx1ZS5zaXplO1xuICAgIH1cbiAgICBpZiAobGliLmlzT2JqZWN0KHZhbHVlKSAmJiAhKHZhbHVlIGluc3RhbmNlb2Ygci5TYWZlU3RyaW5nKSkge1xuICAgICAgLy8gT2JqZWN0cyAoYmVzaWRlcyBTYWZlU3RyaW5ncyksIG5vbi1wcmltYXRpdmUgQXJyYXlzXG4gICAgICByZXR1cm4gbGliLmtleXModmFsdWUpLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZXhwb3J0cy5sZW5ndGggPSBsZW5ndGhGaWx0ZXI7XG5cbmZ1bmN0aW9uIGxpc3QodmFsKSB7XG4gIGlmIChsaWIuaXNTdHJpbmcodmFsKSkge1xuICAgIHJldHVybiB2YWwuc3BsaXQoJycpO1xuICB9IGVsc2UgaWYgKGxpYi5pc09iamVjdCh2YWwpKSB7XG4gICAgcmV0dXJuIGxpYi5fZW50cmllcyh2YWwgfHwge30pLm1hcCgoW2tleSwgdmFsdWVdKSA9PiAoe2tleSwgdmFsdWV9KSk7XG4gIH0gZWxzZSBpZiAobGliLmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiB2YWw7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IGxpYi5UZW1wbGF0ZUVycm9yKCdsaXN0IGZpbHRlcjogdHlwZSBub3QgaXRlcmFibGUnKTtcbiAgfVxufVxuXG5leHBvcnRzLmxpc3QgPSBsaXN0O1xuXG5mdW5jdGlvbiBsb3dlcihzdHIpIHtcbiAgc3RyID0gbm9ybWFsaXplKHN0ciwgJycpO1xuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG59XG5cbmV4cG9ydHMubG93ZXIgPSBsb3dlcjtcblxuZnVuY3Rpb24gbmwyYnIoc3RyKSB7XG4gIGlmIChzdHIgPT09IG51bGwgfHwgc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKHN0ciwgc3RyLnJlcGxhY2UoL1xcclxcbnxcXG4vZywgJzxiciAvPlxcbicpKTtcbn1cblxuZXhwb3J0cy5ubDJiciA9IG5sMmJyO1xuXG5mdW5jdGlvbiByYW5kb20oYXJyKSB7XG4gIHJldHVybiBhcnJbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyLmxlbmd0aCldO1xufVxuXG5leHBvcnRzLnJhbmRvbSA9IHJhbmRvbTtcblxuLyoqXG4gKiBDb25zdHJ1Y3Qgc2VsZWN0IG9yIHJlamVjdCBmaWx0ZXJcbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGV4cGVjdGVkVGVzdFJlc3VsdFxuICogQHJldHVybnMge2Z1bmN0aW9uKGFycmF5LCBzdHJpbmcsICopOiBhcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0T3JSZWplY3QoZXhwZWN0ZWRUZXN0UmVzdWx0KSB7XG4gIGZ1bmN0aW9uIGZpbHRlcihhcnIsIHRlc3ROYW1lID0gJ3RydXRoeScsIHNlY29uZEFyZykge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzO1xuICAgIGNvbnN0IHRlc3QgPSBjb250ZXh0LmVudi5nZXRUZXN0KHRlc3ROYW1lKTtcblxuICAgIHJldHVybiBsaWIudG9BcnJheShhcnIpLmZpbHRlcihmdW5jdGlvbiBleGFtaW5lVGVzdFJlc3VsdChpdGVtKSB7XG4gICAgICByZXR1cm4gdGVzdC5jYWxsKGNvbnRleHQsIGl0ZW0sIHNlY29uZEFyZykgPT09IGV4cGVjdGVkVGVzdFJlc3VsdDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBmaWx0ZXI7XG59XG5cbmV4cG9ydHMucmVqZWN0ID0gZ2V0U2VsZWN0T3JSZWplY3QoZmFsc2UpO1xuXG5mdW5jdGlvbiByZWplY3RhdHRyKGFyciwgYXR0cikge1xuICByZXR1cm4gYXJyLmZpbHRlcigoaXRlbSkgPT4gIWl0ZW1bYXR0cl0pO1xufVxuXG5leHBvcnRzLnJlamVjdGF0dHIgPSByZWplY3RhdHRyO1xuXG5leHBvcnRzLnNlbGVjdCA9IGdldFNlbGVjdE9yUmVqZWN0KHRydWUpO1xuXG5mdW5jdGlvbiBzZWxlY3RhdHRyKGFyciwgYXR0cikge1xuICByZXR1cm4gYXJyLmZpbHRlcigoaXRlbSkgPT4gISFpdGVtW2F0dHJdKTtcbn1cblxuZXhwb3J0cy5zZWxlY3RhdHRyID0gc2VsZWN0YXR0cjtcblxuZnVuY3Rpb24gcmVwbGFjZShzdHIsIG9sZCwgbmV3XywgbWF4Q291bnQpIHtcbiAgdmFyIG9yaWdpbmFsU3RyID0gc3RyO1xuXG4gIGlmIChvbGQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2Uob2xkLCBuZXdfKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbWF4Q291bnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbWF4Q291bnQgPSAtMTtcbiAgfVxuXG4gIGxldCByZXMgPSAnJzsgLy8gT3V0cHV0XG5cbiAgLy8gQ2FzdCBOdW1iZXJzIGluIHRoZSBzZWFyY2ggdGVybSB0byBzdHJpbmdcbiAgaWYgKHR5cGVvZiBvbGQgPT09ICdudW1iZXInKSB7XG4gICAgb2xkID0gJycgKyBvbGQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9sZCAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiBpdCBpcyBzb21ldGhpbmcgb3RoZXIgdGhhbiBudW1iZXIgb3Igc3RyaW5nLFxuICAgIC8vIHJldHVybiB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIC8vIENhc3QgbnVtYmVycyBpbiB0aGUgcmVwbGFjZW1lbnQgdG8gc3RyaW5nXG4gIGlmICh0eXBlb2Ygc3RyID09PSAnbnVtYmVyJykge1xuICAgIHN0ciA9ICcnICsgc3RyO1xuICB9XG5cbiAgLy8gSWYgYnkgbm93LCB3ZSBkb24ndCBoYXZlIGEgc3RyaW5nLCB0aHJvdyBpdCBiYWNrXG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyAmJiAhKHN0ciBpbnN0YW5jZW9mIHIuU2FmZVN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgLy8gU2hvcnRDaXJjdWl0c1xuICBpZiAob2xkID09PSAnJykge1xuICAgIC8vIE1pbWljIHRoZSBweXRob24gYmVoYXZpb3VyOiBlbXB0eSBzdHJpbmcgaXMgcmVwbGFjZWRcbiAgICAvLyBieSByZXBsYWNlbWVudCBlLmcuIFwiYWJjXCJ8cmVwbGFjZShcIlwiLCBcIi5cIikgLT4gLmEuYi5jLlxuICAgIHJlcyA9IG5ld18gKyBzdHIuc3BsaXQoJycpLmpvaW4obmV3XykgKyBuZXdfO1xuICAgIHJldHVybiByLmNvcHlTYWZlbmVzcyhzdHIsIHJlcyk7XG4gIH1cblxuICBsZXQgbmV4dEluZGV4ID0gc3RyLmluZGV4T2Yob2xkKTtcbiAgLy8gaWYgIyBvZiByZXBsYWNlbWVudHMgdG8gcGVyZm9ybSBpcyAwLCBvciB0aGUgc3RyaW5nIHRvIGRvZXNcbiAgLy8gbm90IGNvbnRhaW4gdGhlIG9sZCB2YWx1ZSwgcmV0dXJuIHRoZSBzdHJpbmdcbiAgaWYgKG1heENvdW50ID09PSAwIHx8IG5leHRJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgbGV0IHBvcyA9IDA7XG4gIGxldCBjb3VudCA9IDA7IC8vICMgb2YgcmVwbGFjZW1lbnRzIG1hZGVcblxuICB3aGlsZSAobmV4dEluZGV4ID4gLTEgJiYgKG1heENvdW50ID09PSAtMSB8fCBjb3VudCA8IG1heENvdW50KSkge1xuICAgIC8vIEdyYWIgdGhlIG5leHQgY2h1bmsgb2Ygc3JjIHN0cmluZyBhbmQgYWRkIGl0IHdpdGggdGhlXG4gICAgLy8gcmVwbGFjZW1lbnQsIHRvIHRoZSByZXN1bHRcbiAgICByZXMgKz0gc3RyLnN1YnN0cmluZyhwb3MsIG5leHRJbmRleCkgKyBuZXdfO1xuICAgIC8vIEluY3JlbWVudCBvdXIgcG9pbnRlciBpbiB0aGUgc3JjIHN0cmluZ1xuICAgIHBvcyA9IG5leHRJbmRleCArIG9sZC5sZW5ndGg7XG4gICAgY291bnQrKztcbiAgICAvLyBTZWUgaWYgdGhlcmUgYXJlIGFueSBtb3JlIHJlcGxhY2VtZW50cyB0byBiZSBtYWRlXG4gICAgbmV4dEluZGV4ID0gc3RyLmluZGV4T2Yob2xkLCBwb3MpO1xuICB9XG5cbiAgLy8gV2UndmUgZWl0aGVyIHJlYWNoZWQgdGhlIGVuZCwgb3IgZG9uZSB0aGUgbWF4ICMgb2ZcbiAgLy8gcmVwbGFjZW1lbnRzLCB0YWNrIG9uIGFueSByZW1haW5pbmcgc3RyaW5nXG4gIGlmIChwb3MgPCBzdHIubGVuZ3RoKSB7XG4gICAgcmVzICs9IHN0ci5zdWJzdHJpbmcocG9zKTtcbiAgfVxuXG4gIHJldHVybiByLmNvcHlTYWZlbmVzcyhvcmlnaW5hbFN0ciwgcmVzKTtcbn1cblxuZXhwb3J0cy5yZXBsYWNlID0gcmVwbGFjZTtcblxuZnVuY3Rpb24gcmV2ZXJzZSh2YWwpIHtcbiAgdmFyIGFycjtcbiAgaWYgKGxpYi5pc1N0cmluZyh2YWwpKSB7XG4gICAgYXJyID0gbGlzdCh2YWwpO1xuICB9IGVsc2Uge1xuICAgIC8vIENvcHkgaXRcbiAgICBhcnIgPSBsaWIubWFwKHZhbCwgdiA9PiB2KTtcbiAgfVxuXG4gIGFyci5yZXZlcnNlKCk7XG5cbiAgaWYgKGxpYi5pc1N0cmluZyh2YWwpKSB7XG4gICAgcmV0dXJuIHIuY29weVNhZmVuZXNzKHZhbCwgYXJyLmpvaW4oJycpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnRzLnJldmVyc2UgPSByZXZlcnNlO1xuXG5mdW5jdGlvbiByb3VuZCh2YWwsIHByZWNpc2lvbiwgbWV0aG9kKSB7XG4gIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuICBjb25zdCBmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgbGV0IHJvdW5kZXI7XG5cbiAgaWYgKG1ldGhvZCA9PT0gJ2NlaWwnKSB7XG4gICAgcm91bmRlciA9IE1hdGguY2VpbDtcbiAgfSBlbHNlIGlmIChtZXRob2QgPT09ICdmbG9vcicpIHtcbiAgICByb3VuZGVyID0gTWF0aC5mbG9vcjtcbiAgfSBlbHNlIHtcbiAgICByb3VuZGVyID0gTWF0aC5yb3VuZDtcbiAgfVxuXG4gIHJldHVybiByb3VuZGVyKHZhbCAqIGZhY3RvcikgLyBmYWN0b3I7XG59XG5cbmV4cG9ydHMucm91bmQgPSByb3VuZDtcblxuZnVuY3Rpb24gc2xpY2UoYXJyLCBzbGljZXMsIGZpbGxXaXRoKSB7XG4gIGNvbnN0IHNsaWNlTGVuZ3RoID0gTWF0aC5mbG9vcihhcnIubGVuZ3RoIC8gc2xpY2VzKTtcbiAgY29uc3QgZXh0cmEgPSBhcnIubGVuZ3RoICUgc2xpY2VzO1xuICBjb25zdCByZXMgPSBbXTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZXM7IGkrKykge1xuICAgIGNvbnN0IHN0YXJ0ID0gb2Zmc2V0ICsgKGkgKiBzbGljZUxlbmd0aCk7XG4gICAgaWYgKGkgPCBleHRyYSkge1xuICAgICAgb2Zmc2V0Kys7XG4gICAgfVxuICAgIGNvbnN0IGVuZCA9IG9mZnNldCArICgoaSArIDEpICogc2xpY2VMZW5ndGgpO1xuXG4gICAgY29uc3QgY3VyclNsaWNlID0gYXJyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIGlmIChmaWxsV2l0aCAmJiBpID49IGV4dHJhKSB7XG4gICAgICBjdXJyU2xpY2UucHVzaChmaWxsV2l0aCk7XG4gICAgfVxuICAgIHJlcy5wdXNoKGN1cnJTbGljZSk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnRzLnNsaWNlID0gc2xpY2U7XG5cbmZ1bmN0aW9uIHN1bShhcnIsIGF0dHIsIHN0YXJ0ID0gMCkge1xuICBpZiAoYXR0cikge1xuICAgIGFyciA9IGxpYi5tYXAoYXJyLCAodikgPT4gdlthdHRyXSk7XG4gIH1cblxuICByZXR1cm4gc3RhcnQgKyBhcnIucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG59XG5cbmV4cG9ydHMuc3VtID0gc3VtO1xuXG5leHBvcnRzLnNvcnQgPSByLm1ha2VNYWNybyhcbiAgWyd2YWx1ZScsICdyZXZlcnNlJywgJ2Nhc2Vfc2Vuc2l0aXZlJywgJ2F0dHJpYnV0ZSddLCBbXSxcbiAgKGFyciwgcmV2ZXJzZWQsIGNhc2VTZW5zLCBhdHRyKSA9PiB7XG4gICAgLy8gQ29weSBpdFxuICAgIGxldCBhcnJheSA9IGxpYi5tYXAoYXJyLCB2ID0+IHYpO1xuXG4gICAgYXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgbGV0IHggPSAoYXR0cikgPyBhW2F0dHJdIDogYTtcbiAgICAgIGxldCB5ID0gKGF0dHIpID8gYlthdHRyXSA6IGI7XG5cbiAgICAgIGlmICghY2FzZVNlbnMgJiYgbGliLmlzU3RyaW5nKHgpICYmIGxpYi5pc1N0cmluZyh5KSkge1xuICAgICAgICB4ID0geC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB5ID0geS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA8IHkpIHtcbiAgICAgICAgcmV0dXJuIHJldmVyc2VkID8gMSA6IC0xO1xuICAgICAgfSBlbHNlIGlmICh4ID4geSkge1xuICAgICAgICByZXR1cm4gcmV2ZXJzZWQgPyAtMSA6IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBhcnJheTtcbiAgfSk7XG5cbmZ1bmN0aW9uIHN0cmluZyhvYmopIHtcbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKG9iaiwgb2JqKTtcbn1cblxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5cbmZ1bmN0aW9uIHN0cmlwdGFncyhpbnB1dCwgcHJlc2VydmVMaW5lYnJlYWtzKSB7XG4gIGlucHV0ID0gbm9ybWFsaXplKGlucHV0LCAnJyk7XG4gIGxldCB0YWdzID0gLzxcXC8/KFthLXpdW2EtejAtOV0qKVxcYltePl0qPnw8IS0tW1xcc1xcU10qPy0tPi9naTtcbiAgbGV0IHRyaW1tZWRJbnB1dCA9IHRyaW0oaW5wdXQucmVwbGFjZSh0YWdzLCAnJykpO1xuICBsZXQgcmVzID0gJyc7XG4gIGlmIChwcmVzZXJ2ZUxpbmVicmVha3MpIHtcbiAgICByZXMgPSB0cmltbWVkSW5wdXRcbiAgICAgIC5yZXBsYWNlKC9eICt8ICskL2dtLCAnJykgLy8gcmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlc1xuICAgICAgLnJlcGxhY2UoLyArL2csICcgJykgLy8gc3F1YXNoIGFkamFjZW50IHNwYWNlc1xuICAgICAgLnJlcGxhY2UoLyhcXHJcXG4pL2csICdcXG4nKSAvLyBub3JtYWxpemUgbGluZWJyZWFrcyAoQ1JMRiAtPiBMRilcbiAgICAgIC5yZXBsYWNlKC9cXG5cXG5cXG4rL2csICdcXG5cXG4nKTsgLy8gc3F1YXNoIGFibm9ybWFsIGFkamFjZW50IGxpbmVicmVha3NcbiAgfSBlbHNlIHtcbiAgICByZXMgPSB0cmltbWVkSW5wdXQucmVwbGFjZSgvXFxzKy9naSwgJyAnKTtcbiAgfVxuICByZXR1cm4gci5jb3B5U2FmZW5lc3MoaW5wdXQsIHJlcyk7XG59XG5cbmV4cG9ydHMuc3RyaXB0YWdzID0gc3RyaXB0YWdzO1xuXG5mdW5jdGlvbiB0aXRsZShzdHIpIHtcbiAgc3RyID0gbm9ybWFsaXplKHN0ciwgJycpO1xuICBsZXQgd29yZHMgPSBzdHIuc3BsaXQoJyAnKS5tYXAod29yZCA9PiBjYXBpdGFsaXplKHdvcmQpKTtcbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKHN0ciwgd29yZHMuam9pbignICcpKTtcbn1cblxuZXhwb3J0cy50aXRsZSA9IHRpdGxlO1xuXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gci5jb3B5U2FmZW5lc3Moc3RyLCBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpKTtcbn1cblxuZXhwb3J0cy50cmltID0gdHJpbTtcblxuZnVuY3Rpb24gdHJ1bmNhdGUoaW5wdXQsIGxlbmd0aCwga2lsbHdvcmRzLCBlbmQpIHtcbiAgdmFyIG9yaWcgPSBpbnB1dDtcbiAgaW5wdXQgPSBub3JtYWxpemUoaW5wdXQsICcnKTtcbiAgbGVuZ3RoID0gbGVuZ3RoIHx8IDI1NTtcblxuICBpZiAoaW5wdXQubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGlmIChraWxsd29yZHMpIHtcbiAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygwLCBsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGxldCBpZHggPSBpbnB1dC5sYXN0SW5kZXhPZignICcsIGxlbmd0aCk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIGlkeCA9IGxlbmd0aDtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygwLCBpZHgpO1xuICB9XG5cbiAgaW5wdXQgKz0gKGVuZCAhPT0gdW5kZWZpbmVkICYmIGVuZCAhPT0gbnVsbCkgPyBlbmQgOiAnLi4uJztcbiAgcmV0dXJuIHIuY29weVNhZmVuZXNzKG9yaWcsIGlucHV0KTtcbn1cblxuZXhwb3J0cy50cnVuY2F0ZSA9IHRydW5jYXRlO1xuXG5mdW5jdGlvbiB1cHBlcihzdHIpIHtcbiAgc3RyID0gbm9ybWFsaXplKHN0ciwgJycpO1xuICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7XG59XG5cbmV4cG9ydHMudXBwZXIgPSB1cHBlcjtcblxuZnVuY3Rpb24gdXJsZW5jb2RlKG9iaikge1xuICB2YXIgZW5jID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuICBpZiAobGliLmlzU3RyaW5nKG9iaikpIHtcbiAgICByZXR1cm4gZW5jKG9iaik7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGtleXZhbHMgPSAobGliLmlzQXJyYXkob2JqKSkgPyBvYmogOiBsaWIuX2VudHJpZXMob2JqKTtcbiAgICByZXR1cm4ga2V5dmFscy5tYXAoKFtrLCB2XSkgPT4gYCR7ZW5jKGspfT0ke2VuYyh2KX1gKS5qb2luKCcmJyk7XG4gIH1cbn1cblxuZXhwb3J0cy51cmxlbmNvZGUgPSB1cmxlbmNvZGU7XG5cbi8vIEZvciB0aGUgamluamEgcmVnZXhwLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXRzdWhpa28vamluamEyL2Jsb2IvZjE1YjgxNGRjYmE2YWExMmJjNzRkMWY3ZDBjODgxZDU1ZjcxMjZiZS9qaW5qYTIvdXRpbHMucHkjTDIwLUwyM1xuY29uc3QgcHVuY1JlID0gL14oPzpcXCh8PHwmbHQ7KT8oLio/KSg/OlxcLnwsfFxcKXxcXG58Jmd0Oyk/JC87XG4vLyBmcm9tIGh0dHA6Ly9ibG9nLmdlcnYubmV0LzIwMTEvMDUvaHRtbDVfZW1haWxfYWRkcmVzc19yZWdleHAvXG5jb25zdCBlbWFpbFJlID0gL15bXFx3LiEjJCUmJyorXFwtXFwvPT9cXF5ge3x9fl0rQFthLXpcXGRcXC1dKyhcXC5bYS16XFxkXFwtXSspKyQvaTtcbmNvbnN0IGh0dHBIdHRwc1JlID0gL15odHRwcz86XFwvXFwvLiokLztcbmNvbnN0IHd3d1JlID0gL153d3dcXC4vO1xuY29uc3QgdGxkUmUgPSAvXFwuKD86b3JnfG5ldHxjb20pKD86XFw6fFxcL3wkKS87XG5cbmZ1bmN0aW9uIHVybGl6ZShzdHIsIGxlbmd0aCwgbm9mb2xsb3cpIHtcbiAgaWYgKGlzTmFOKGxlbmd0aCkpIHtcbiAgICBsZW5ndGggPSBJbmZpbml0eTtcbiAgfVxuXG4gIGNvbnN0IG5vRm9sbG93QXR0ciA9IChub2ZvbGxvdyA9PT0gdHJ1ZSA/ICcgcmVsPVwibm9mb2xsb3dcIicgOiAnJyk7XG5cbiAgY29uc3Qgd29yZHMgPSBzdHIuc3BsaXQoLyhcXHMrKS8pLmZpbHRlcigod29yZCkgPT4ge1xuICAgIC8vIElmIHRoZSB3b3JkIGhhcyBubyBsZW5ndGgsIGJhaWwuIFRoaXMgY2FuIGhhcHBlbiBmb3Igc3RyIHdpdGhcbiAgICAvLyB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIHJldHVybiB3b3JkICYmIHdvcmQubGVuZ3RoO1xuICB9KS5tYXAoKHdvcmQpID0+IHtcbiAgICB2YXIgbWF0Y2hlcyA9IHdvcmQubWF0Y2gocHVuY1JlKTtcbiAgICB2YXIgcG9zc2libGVVcmwgPSAobWF0Y2hlcykgPyBtYXRjaGVzWzFdIDogd29yZDtcbiAgICB2YXIgc2hvcnRVcmwgPSBwb3NzaWJsZVVybC5zdWJzdHIoMCwgbGVuZ3RoKTtcblxuICAgIC8vIHVybCB0aGF0IHN0YXJ0cyB3aXRoIGh0dHAgb3IgaHR0cHNcbiAgICBpZiAoaHR0cEh0dHBzUmUudGVzdChwb3NzaWJsZVVybCkpIHtcbiAgICAgIHJldHVybiBgPGEgaHJlZj1cIiR7cG9zc2libGVVcmx9XCIke25vRm9sbG93QXR0cn0+JHtzaG9ydFVybH08L2E+YDtcbiAgICB9XG5cbiAgICAvLyB1cmwgdGhhdCBzdGFydHMgd2l0aCB3d3cuXG4gICAgaWYgKHd3d1JlLnRlc3QocG9zc2libGVVcmwpKSB7XG4gICAgICByZXR1cm4gYDxhIGhyZWY9XCJodHRwOi8vJHtwb3NzaWJsZVVybH1cIiR7bm9Gb2xsb3dBdHRyfT4ke3Nob3J0VXJsfTwvYT5gO1xuICAgIH1cblxuICAgIC8vIGFuIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIGZvcm0gdXNlcm5hbWVAZG9tYWluLnRsZFxuICAgIGlmIChlbWFpbFJlLnRlc3QocG9zc2libGVVcmwpKSB7XG4gICAgICByZXR1cm4gYDxhIGhyZWY9XCJtYWlsdG86JHtwb3NzaWJsZVVybH1cIj4ke3Bvc3NpYmxlVXJsfTwvYT5gO1xuICAgIH1cblxuICAgIC8vIHVybCB0aGF0IGVuZHMgaW4gLmNvbSwgLm9yZyBvciAubmV0IHRoYXQgaXMgbm90IGFuIGVtYWlsIGFkZHJlc3NcbiAgICBpZiAodGxkUmUudGVzdChwb3NzaWJsZVVybCkpIHtcbiAgICAgIHJldHVybiBgPGEgaHJlZj1cImh0dHA6Ly8ke3Bvc3NpYmxlVXJsfVwiJHtub0ZvbGxvd0F0dHJ9PiR7c2hvcnRVcmx9PC9hPmA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmQ7XG4gIH0pO1xuXG4gIHJldHVybiB3b3Jkcy5qb2luKCcnKTtcbn1cblxuZXhwb3J0cy51cmxpemUgPSB1cmxpemU7XG5cbmZ1bmN0aW9uIHdvcmRjb3VudChzdHIpIHtcbiAgc3RyID0gbm9ybWFsaXplKHN0ciwgJycpO1xuICBjb25zdCB3b3JkcyA9IChzdHIpID8gc3RyLm1hdGNoKC9cXHcrL2cpIDogbnVsbDtcbiAgcmV0dXJuICh3b3JkcykgPyB3b3Jkcy5sZW5ndGggOiBudWxsO1xufVxuXG5leHBvcnRzLndvcmRjb3VudCA9IHdvcmRjb3VudDtcblxuZnVuY3Rpb24gZmxvYXQodmFsLCBkZWYpIHtcbiAgdmFyIHJlcyA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIChpc05hTihyZXMpKSA/IGRlZiA6IHJlcztcbn1cblxuZXhwb3J0cy5mbG9hdCA9IGZsb2F0O1xuXG5mdW5jdGlvbiBpbnQodmFsLCBkZWYpIHtcbiAgdmFyIHJlcyA9IHBhcnNlSW50KHZhbCwgMTApO1xuICByZXR1cm4gKGlzTmFOKHJlcykpID8gZGVmIDogcmVzO1xufVxuXG5leHBvcnRzLmludCA9IGludDtcblxuLy8gQWxpYXNlc1xuZXhwb3J0cy5kID0gZXhwb3J0cy5kZWZhdWx0O1xuZXhwb3J0cy5lID0gZXhwb3J0cy5lc2NhcGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9udW5qdWNrcy9zcmMvZmlsdGVycy5qcyIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgTG9hZGVyID0gcmVxdWlyZSgnLi9sb2FkZXInKTtcblxuY2xhc3MgUHJlY29tcGlsZWRMb2FkZXIgZXh0ZW5kcyBMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihjb21waWxlZFRlbXBsYXRlcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wcmVjb21waWxlZCA9IGNvbXBpbGVkVGVtcGxhdGVzIHx8IHt9O1xuICB9XG5cbiAgZ2V0U291cmNlKG5hbWUpIHtcbiAgICBpZiAodGhpcy5wcmVjb21waWxlZFtuYW1lXSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3JjOiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIG9iajogdGhpcy5wcmVjb21waWxlZFtuYW1lXVxuICAgICAgICB9LFxuICAgICAgICBwYXRoOiBuYW1lXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUHJlY29tcGlsZWRMb2FkZXI6IFByZWNvbXBpbGVkTG9hZGVyLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL251bmp1Y2tzL3NyYy9wcmVjb21waWxlZC1sb2FkZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBTYWZlU3RyaW5nID0gcmVxdWlyZSgnLi9ydW50aW1lJykuU2FmZVN0cmluZztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0IGlzIGEgZnVuY3Rpb24sIG90aGVyd2lzZSBgZmFsc2VgLlxuICogQHBhcmFtIHsgYW55IH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cbmZ1bmN0aW9uIGNhbGxhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydHMuY2FsbGFibGUgPSBjYWxsYWJsZTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0IGlzIHN0cmljdGx5IG5vdCBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSB7IGFueSB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5mdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuXG5leHBvcnRzLmRlZmluZWQgPSBkZWZpbmVkO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvcGVyYW5kIChvbmUpIGlzIGRpdmlzYmxlIGJ5IHRoZSB0ZXN0J3MgYXJndW1lbnRcbiAqICh0d28pLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gb25lXG4gKiBAcGFyYW0geyBudW1iZXIgfSB0d29cbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cbmZ1bmN0aW9uIGRpdmlzaWJsZWJ5KG9uZSwgdHdvKSB7XG4gIHJldHVybiAob25lICUgdHdvKSA9PT0gMDtcbn1cblxuZXhwb3J0cy5kaXZpc2libGVieSA9IGRpdmlzaWJsZWJ5O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGhhcyBiZWVuIGVzY2FwZWQgKGkuZS4sIGlzIGEgU2FmZVN0cmluZykuXG4gKiBAcGFyYW0geyBhbnkgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuZnVuY3Rpb24gZXNjYXBlZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTYWZlU3RyaW5nO1xufVxuXG5leHBvcnRzLmVzY2FwZWQgPSBlc2NhcGVkO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICogQHBhcmFtIHsgYW55IH0gb25lXG4gKiBAcGFyYW0geyBhbnkgfSB0d29cbiAqL1xuZnVuY3Rpb24gZXF1YWx0byhvbmUsIHR3bykge1xuICByZXR1cm4gb25lID09PSB0d287XG59XG5cbmV4cG9ydHMuZXF1YWx0byA9IGVxdWFsdG87XG5cbi8vIEFsaWFzZXNcbmV4cG9ydHMuZXEgPSBleHBvcnRzLmVxdWFsdG87XG5leHBvcnRzLnNhbWVhcyA9IGV4cG9ydHMuZXF1YWx0bztcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgZXZlbmx5IGRpdmlzaWJsZSBieSAyLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cbmZ1bmN0aW9uIGV2ZW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICUgMiA9PT0gMDtcbn1cblxuZXhwb3J0cy5ldmVuID0gZXZlbjtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgZmFsc3kgLSBpZiBJIHJlY2FsbCBjb3JyZWN0bHksICcnLCAwLCBmYWxzZSxcbiAqIHVuZGVmaW5lZCwgTmFOIG9yIG51bGwuIEkgZG9uJ3Qga25vdyBpZiB3ZSBzaG91bGQgc3RpY2sgdG8gdGhlIGRlZmF1bHQgSlNcbiAqIGJlaGF2aW9yIG9yIGF0dGVtcHQgdG8gcmVwbGljYXRlIHdoYXQgUHl0aG9uIGJlbGlldmVzIHNob3VsZCBiZSBmYWxzeSAoaS5lLixcbiAqIGVtcHR5IGFycmF5cywgZW1wdHkgZGljdHMsIG5vdCAwLi4uKS5cbiAqIEBwYXJhbSB7IGFueSB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5mdW5jdGlvbiBmYWxzeSh2YWx1ZSkge1xuICByZXR1cm4gIXZhbHVlO1xufVxuXG5leHBvcnRzLmZhbHN5ID0gZmFsc3k7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9wZXJhbmQgKG9uZSkgaXMgZ3JlYXRlciBvciBlcXVhbCB0byB0aGUgdGVzdCdzXG4gKiBhcmd1bWVudCAodHdvKS5cbiAqIEBwYXJhbSB7IG51bWJlciB9IG9uZVxuICogQHBhcmFtIHsgbnVtYmVyIH0gdHdvXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5mdW5jdGlvbiBnZShvbmUsIHR3bykge1xuICByZXR1cm4gb25lID49IHR3bztcbn1cblxuZXhwb3J0cy5nZSA9IGdlO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBvcGVyYW5kIChvbmUpIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdGVzdCdzIGFyZ3VtZW50XG4gKiAodHdvKS5cbiAqIEBwYXJhbSB7IG51bWJlciB9IG9uZVxuICogQHBhcmFtIHsgbnVtYmVyIH0gdHdvXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5mdW5jdGlvbiBncmVhdGVydGhhbihvbmUsIHR3bykge1xuICByZXR1cm4gb25lID4gdHdvO1xufVxuXG5leHBvcnRzLmdyZWF0ZXJ0aGFuID0gZ3JlYXRlcnRoYW47XG5cbi8vIGFsaWFzXG5leHBvcnRzLmd0ID0gZXhwb3J0cy5ncmVhdGVydGhhbjtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb3BlcmFuZCAob25lKSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHRlc3Qnc1xuICogYXJndW1lbnQgKHR3bykuXG4gKiBAcGFyYW0geyBudW1iZXIgfSBvbmVcbiAqIEBwYXJhbSB7IG51bWJlciB9IHR3b1xuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuZnVuY3Rpb24gbGUob25lLCB0d28pIHtcbiAgcmV0dXJuIG9uZSA8PSB0d287XG59XG5cbmV4cG9ydHMubGUgPSBsZTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb3BlcmFuZCAob25lKSBpcyBsZXNzIHRoYW4gdGhlIHRlc3QncyBwYXNzZWQgYXJndW1lbnRcbiAqICh0d28pLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gb25lXG4gKiBAcGFyYW0geyBudW1iZXIgfSB0d29cbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cbmZ1bmN0aW9uIGxlc3N0aGFuKG9uZSwgdHdvKSB7XG4gIHJldHVybiBvbmUgPCB0d287XG59XG5cbmV4cG9ydHMubGVzc3RoYW4gPSBsZXNzdGhhbjtcblxuLy8gYWxpYXNcbmV4cG9ydHMubHQgPSBleHBvcnRzLmxlc3N0aGFuO1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzdHJpbmcgaXMgbG93ZXJjYXNlZC5cbiAqIEBwYXJhbSB7IHN0cmluZyB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5mdW5jdGlvbiBsb3dlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gdmFsdWU7XG59XG5cbmV4cG9ydHMubG93ZXIgPSBsb3dlcjtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb3BlcmFuZCAob25lKSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHRlc3Qnc1xuICogYXJndW1lbnQgKHR3bykuXG4gKiBAcGFyYW0geyBudW1iZXIgfSBvbmVcbiAqIEBwYXJhbSB7IG51bWJlciB9IHR3b1xuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuZnVuY3Rpb24gbmUob25lLCB0d28pIHtcbiAgcmV0dXJuIG9uZSAhPT0gdHdvO1xufVxuXG5leHBvcnRzLm5lID0gbmU7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBzdHJpY3RseSBlcXVhbCB0byBgbnVsbGAuXG4gKiBAcGFyYW0geyBhbnkgfVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuZnVuY3Rpb24gbnVsbFRlc3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xufVxuXG5leHBvcnRzLm51bGwgPSBudWxsVGVzdDtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0geyBhbnkgfVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xufVxuXG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgKm5vdCogZXZlbmx5IGRpdmlzaWJsZSBieSAyLlxuICogQHBhcmFtIHsgbnVtYmVyIH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cbmZ1bmN0aW9uIG9kZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJSAyID09PSAxO1xufVxuXG5leHBvcnRzLm9kZCA9IG9kZDtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGBmYWxzZWAgaWYgbm90LlxuICogQHBhcmFtIHsgYW55IH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIG5vdCBpbiB0aGUgbGlzdCBvZiB0aGluZ3MgY29uc2lkZXJlZCBmYWxzeTpcbiAqICcnLCBudWxsLCB1bmRlZmluZWQsIDAsIE5hTiBhbmQgZmFsc2UuXG4gKiBAcGFyYW0geyBhbnkgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuZnVuY3Rpb24gdHJ1dGh5KHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlO1xufVxuXG5leHBvcnRzLnRydXRoeSA9IHRydXRoeTtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLlxuICogQHBhcmFtIHsgYW55IH0gdmFsdWVcbiAqIEByZXR1cm5zIHsgYm9vbGVhbiB9XG4gKi9cbmZ1bmN0aW9uIHVuZGVmaW5lZFRlc3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydHMudW5kZWZpbmVkID0gdW5kZWZpbmVkVGVzdDtcblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3RyaW5nIGlzIHVwcGVyY2FzZWQuXG4gKiBAcGFyYW0geyBzdHJpbmcgfSB2YWx1ZVxuICogQHJldHVybnMgeyBib29sZWFuIH1cbiAqL1xuZnVuY3Rpb24gdXBwZXIodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnRvVXBwZXJDYXNlKCkgPT09IHZhbHVlO1xufVxuXG5leHBvcnRzLnVwcGVyID0gdXBwZXI7XG5cbi8qKlxuICogSWYgRVM2IGZlYXR1cmVzIGFyZSBhdmFpbGFibGUsIHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpbXBsZW1lbnRzIHRoZVxuICogYFN5bWJvbC5pdGVyYXRvcmAgbWV0aG9kLiBJZiBub3QsIGl0J3MgYSBzdHJpbmcgb3IgQXJyYXkuXG4gKlxuICogQ291bGQgcG90ZW50aWFsbHkgY2F1c2UgaXNzdWVzIGlmIGEgYnJvd3NlciBleGlzdHMgdGhhdCBoYXMgU2V0IGFuZCBNYXAgYnV0XG4gKiBub3QgU3ltYm9sLlxuICpcbiAqIEBwYXJhbSB7IGFueSB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5mdW5jdGlvbiBpdGVyYWJsZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gISF2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICB9XG59XG5cbmV4cG9ydHMuaXRlcmFibGUgPSBpdGVyYWJsZTtcblxuLyoqXG4gKiBJZiBFUzYgZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSwgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCBoYXNoXG4gKiBvciBhbiBFUzYgTWFwLiBPdGhlcndpc2UganVzdCByZXR1cm4gaWYgaXQncyBhbiBvYmplY3QgaGFzaC5cbiAqIEBwYXJhbSB7IGFueSB9IHZhbHVlXG4gKiBAcmV0dXJucyB7IGJvb2xlYW4gfVxuICovXG5mdW5jdGlvbiBtYXBwaW5nKHZhbHVlKSB7XG4gIC8vIG9ubHkgbWFwcyBhbmQgb2JqZWN0IGhhc2hlc1xuICB2YXIgYm9vbCA9IHZhbHVlICE9PSBudWxsXG4gICAgJiYgdmFsdWUgIT09IHVuZGVmaW5lZFxuICAgICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbiAgICAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChTZXQpIHtcbiAgICByZXR1cm4gYm9vbCAmJiAhKHZhbHVlIGluc3RhbmNlb2YgU2V0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYm9vbDtcbiAgfVxufVxuXG5leHBvcnRzLm1hcHBpbmcgPSBtYXBwaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbnVuanVja3Mvc3JjL3Rlc3RzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjeWNsZXIoaXRlbXMpIHtcbiAgdmFyIGluZGV4ID0gLTE7XG5cbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBudWxsLFxuICAgIHJlc2V0KCkge1xuICAgICAgaW5kZXggPSAtMTtcbiAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgfSxcblxuICAgIG5leHQoKSB7XG4gICAgICBpbmRleCsrO1xuICAgICAgaWYgKGluZGV4ID49IGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudCA9IGl0ZW1zW2luZGV4XTtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgfSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gam9pbmVyKHNlcCkge1xuICBzZXAgPSBzZXAgfHwgJywnO1xuICBsZXQgZmlyc3QgPSB0cnVlO1xuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3QgdmFsID0gZmlyc3QgPyAnJyA6IHNlcDtcbiAgICBmaXJzdCA9IGZhbHNlO1xuICAgIHJldHVybiB2YWw7XG4gIH07XG59XG5cbi8vIE1ha2luZyB0aGlzIGEgZnVuY3Rpb24gaW5zdGVhZCBzbyBpdCByZXR1cm5zIGEgbmV3IG9iamVjdFxuLy8gZWFjaCB0aW1lIGl0J3MgY2FsbGVkLiBUaGF0IHdheSwgaWYgc29tZXRoaW5nIGxpa2UgYW4gZW52aXJvbm1lbnRcbi8vIHVzZXMgaXQsIHRoZXkgd2lsbCBlYWNoIGhhdmUgdGhlaXIgb3duIGNvcHkuXG5mdW5jdGlvbiBnbG9iYWxzKCkge1xuICByZXR1cm4ge1xuICAgIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICBpZiAodHlwZW9mIHN0b3AgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHN0b3AgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBzdGVwID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0ZXApIHtcbiAgICAgICAgc3RlcCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgaWYgKHN0ZXAgPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0b3A7IGkgKz0gc3RlcCkge1xuICAgICAgICAgIGFyci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPiBzdG9wOyBpICs9IHN0ZXApIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBmb3ItZGlyZWN0aW9uXG4gICAgICAgICAgYXJyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIGN5Y2xlcigpIHtcbiAgICAgIHJldHVybiBjeWNsZXIoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfSxcblxuICAgIGpvaW5lcihzZXApIHtcbiAgICAgIHJldHVybiBqb2luZXIoc2VwKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFscztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL251bmp1Y2tzL3NyYy9nbG9iYWxzLmpzIiwiY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBleHByZXNzKGVudiwgYXBwKSB7XG4gIGZ1bmN0aW9uIE51bmp1Y2tzVmlldyhuYW1lLCBvcHRzKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnBhdGggPSBuYW1lO1xuICAgIHRoaXMuZGVmYXVsdEVuZ2luZSA9IG9wdHMuZGVmYXVsdEVuZ2luZTtcbiAgICB0aGlzLmV4dCA9IHBhdGguZXh0bmFtZShuYW1lKTtcbiAgICBpZiAoIXRoaXMuZXh0ICYmICF0aGlzLmRlZmF1bHRFbmdpbmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGVmYXVsdCBlbmdpbmUgd2FzIHNwZWNpZmllZCBhbmQgbm8gZXh0ZW5zaW9uIHdhcyBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmV4dCkge1xuICAgICAgdGhpcy5uYW1lICs9ICh0aGlzLmV4dCA9ICh0aGlzLmRlZmF1bHRFbmdpbmVbMF0gIT09ICcuJyA/ICcuJyA6ICcnKSArIHRoaXMuZGVmYXVsdEVuZ2luZSk7XG4gICAgfVxuICB9XG5cbiAgTnVuanVja3NWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIob3B0cywgY2IpIHtcbiAgICBlbnYucmVuZGVyKHRoaXMubmFtZSwgb3B0cywgY2IpO1xuICB9O1xuXG4gIGFwcC5zZXQoJ3ZpZXcnLCBOdW5qdWNrc1ZpZXcpO1xuICBhcHAuc2V0KCdudW5qdWNrc0VudicsIGVudik7XG4gIHJldHVybiBlbnY7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbnVuanVja3Mvc3JjL2V4cHJlc3MtYXBwLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3Qge19wcmV0dGlmeUVycm9yfSA9IHJlcXVpcmUoJy4vbGliJyk7XG5jb25zdCBjb21waWxlciA9IHJlcXVpcmUoJy4vY29tcGlsZXInKTtcbmNvbnN0IHtFbnZpcm9ubWVudH0gPSByZXF1aXJlKCcuL2Vudmlyb25tZW50Jyk7XG5jb25zdCBwcmVjb21waWxlR2xvYmFsID0gcmVxdWlyZSgnLi9wcmVjb21waWxlLWdsb2JhbCcpO1xuXG5mdW5jdGlvbiBtYXRjaChmaWxlbmFtZSwgcGF0dGVybnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhdHRlcm5zKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcGF0dGVybnMuc29tZSgocGF0dGVybikgPT4gZmlsZW5hbWUubWF0Y2gocGF0dGVybikpO1xufVxuXG5mdW5jdGlvbiBwcmVjb21waWxlU3RyaW5nKHN0ciwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy5pc1N0cmluZyA9IHRydWU7XG4gIGNvbnN0IGVudiA9IG9wdHMuZW52IHx8IG5ldyBFbnZpcm9ubWVudChbXSk7XG4gIGNvbnN0IHdyYXBwZXIgPSBvcHRzLndyYXBwZXIgfHwgcHJlY29tcGlsZUdsb2JhbDtcblxuICBpZiAoIW9wdHMubmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGhlIFwibmFtZVwiIG9wdGlvbiBpcyByZXF1aXJlZCB3aGVuIGNvbXBpbGluZyBhIHN0cmluZycpO1xuICB9XG4gIHJldHVybiB3cmFwcGVyKFtfcHJlY29tcGlsZShzdHIsIG9wdHMubmFtZSwgZW52KV0sIG9wdHMpO1xufVxuXG5mdW5jdGlvbiBwcmVjb21waWxlKGlucHV0LCBvcHRzKSB7XG4gIC8vIFRoZSBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgYXZhaWxhYmxlOlxuICAvL1xuICAvLyAqIG5hbWU6IG5hbWUgb2YgdGhlIHRlbXBsYXRlIChhdXRvLWdlbmVyYXRlZCB3aGVuIGNvbXBpbGluZyBhIGRpcmVjdG9yeSlcbiAgLy8gKiBpc1N0cmluZzogaW5wdXQgaXMgYSBzdHJpbmcsIG5vdCBhIGZpbGUgcGF0aFxuICAvLyAqIGFzRnVuY3Rpb246IGdlbmVyYXRlIGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgLy8gKiBmb3JjZToga2VlcCBjb21waWxpbmcgb24gZXJyb3JcbiAgLy8gKiBlbnY6IHRoZSBFbnZpcm9ubWVudCB0byB1c2UgKGdldHMgZXh0ZW5zaW9ucyBhbmQgYXN5bmMgZmlsdGVycyBmcm9tIGl0KVxuICAvLyAqIGluY2x1ZGU6IHdoaWNoIGZpbGUvZm9sZGVycyB0byBpbmNsdWRlIChmb2xkZXJzIGFyZSBhdXRvLWluY2x1ZGVkLCBmaWxlcyBhcmUgYXV0by1leGNsdWRlZClcbiAgLy8gKiBleGNsdWRlOiB3aGljaCBmaWxlL2ZvbGRlcnMgdG8gZXhjbHVkZSAoZm9sZGVycyBhcmUgYXV0by1pbmNsdWRlZCwgZmlsZXMgYXJlIGF1dG8tZXhjbHVkZWQpXG4gIC8vICogd3JhcHBlcjogZnVuY3Rpb24odGVtcGxhdGVzLCBvcHRzKSB7Li4ufVxuICAvLyAgICAgICBDdXN0b21pemUgdGhlIG91dHB1dCBmb3JtYXQgdG8gc3RvcmUgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAvLyAgICAgICBCeSBkZWZhdWx0LCB0ZW1wbGF0ZXMgYXJlIHN0b3JlZCBpbiBhIGdsb2JhbCB2YXJpYWJsZSB1c2VkIGJ5IHRoZSBydW50aW1lLlxuICAvLyAgICAgICBBIGN1c3RvbSBsb2FkZXIgd2lsbCBiZSBuZWNlc3NhcnkgdG8gbG9hZCB5b3VyIGN1c3RvbSB3cmFwcGVyLlxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBjb25zdCBlbnYgPSBvcHRzLmVudiB8fCBuZXcgRW52aXJvbm1lbnQoW10pO1xuICBjb25zdCB3cmFwcGVyID0gb3B0cy53cmFwcGVyIHx8IHByZWNvbXBpbGVHbG9iYWw7XG5cbiAgaWYgKG9wdHMuaXNTdHJpbmcpIHtcbiAgICByZXR1cm4gcHJlY29tcGlsZVN0cmluZyhpbnB1dCwgb3B0cyk7XG4gIH1cblxuICBjb25zdCBwYXRoU3RhdHMgPSBmcy5leGlzdHNTeW5jKGlucHV0KSAmJiBmcy5zdGF0U3luYyhpbnB1dCk7XG4gIGNvbnN0IHByZWNvbXBpbGVkID0gW107XG4gIGNvbnN0IHRlbXBsYXRlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGFkZFRlbXBsYXRlcyhkaXIpIHtcbiAgICBmcy5yZWFkZGlyU3luYyhkaXIpLmZvckVhY2goKGZpbGUpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVwYXRoID0gcGF0aC5qb2luKGRpciwgZmlsZSk7XG4gICAgICBsZXQgc3VicGF0aCA9IGZpbGVwYXRoLnN1YnN0cihwYXRoLmpvaW4oaW5wdXQsICcvJykubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHN0YXQgPSBmcy5zdGF0U3luYyhmaWxlcGF0aCk7XG5cbiAgICAgIGlmIChzdGF0ICYmIHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICBzdWJwYXRoICs9ICcvJztcbiAgICAgICAgaWYgKCFtYXRjaChzdWJwYXRoLCBvcHRzLmV4Y2x1ZGUpKSB7XG4gICAgICAgICAgYWRkVGVtcGxhdGVzKGZpbGVwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtYXRjaChzdWJwYXRoLCBvcHRzLmluY2x1ZGUpKSB7XG4gICAgICAgIHRlbXBsYXRlcy5wdXNoKGZpbGVwYXRoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwYXRoU3RhdHMuaXNGaWxlKCkpIHtcbiAgICBwcmVjb21waWxlZC5wdXNoKF9wcmVjb21waWxlKFxuICAgICAgZnMucmVhZEZpbGVTeW5jKGlucHV0LCAndXRmLTgnKSxcbiAgICAgIG9wdHMubmFtZSB8fCBpbnB1dCxcbiAgICAgIGVudlxuICAgICkpO1xuICB9IGVsc2UgaWYgKHBhdGhTdGF0cy5pc0RpcmVjdG9yeSgpKSB7XG4gICAgYWRkVGVtcGxhdGVzKGlucHV0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBuYW1lID0gdGVtcGxhdGVzW2ldLnJlcGxhY2UocGF0aC5qb2luKGlucHV0LCAnLycpLCAnJyk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHByZWNvbXBpbGVkLnB1c2goX3ByZWNvbXBpbGUoXG4gICAgICAgICAgZnMucmVhZEZpbGVTeW5jKHRlbXBsYXRlc1tpXSwgJ3V0Zi04JyksXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBlbnZcbiAgICAgICAgKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChvcHRzLmZvcmNlKSB7XG4gICAgICAgICAgLy8gRG9uJ3Qgc3RvcCBnZW5lcmF0aW5nIHRoZSBvdXRwdXQgaWYgd2UncmVcbiAgICAgICAgICAvLyBmb3JjaW5nIGNvbXBpbGF0aW9uLlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gd3JhcHBlcihwcmVjb21waWxlZCwgb3B0cyk7XG59XG5cbmZ1bmN0aW9uIF9wcmVjb21waWxlKHN0ciwgbmFtZSwgZW52KSB7XG4gIGVudiA9IGVudiB8fCBuZXcgRW52aXJvbm1lbnQoW10pO1xuXG4gIGNvbnN0IGFzeW5jRmlsdGVycyA9IGVudi5hc3luY0ZpbHRlcnM7XG4gIGNvbnN0IGV4dGVuc2lvbnMgPSBlbnYuZXh0ZW5zaW9uc0xpc3Q7XG4gIGxldCB0ZW1wbGF0ZTtcblxuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG5cbiAgdHJ5IHtcbiAgICB0ZW1wbGF0ZSA9IGNvbXBpbGVyLmNvbXBpbGUoc3RyLFxuICAgICAgYXN5bmNGaWx0ZXJzLFxuICAgICAgZXh0ZW5zaW9ucyxcbiAgICAgIG5hbWUsXG4gICAgICBlbnYub3B0cyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IF9wcmV0dGlmeUVycm9yKG5hbWUsIGZhbHNlLCBlcnIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcHJlY29tcGlsZTogcHJlY29tcGlsZSxcbiAgcHJlY29tcGlsZVN0cmluZzogcHJlY29tcGlsZVN0cmluZ1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL251bmp1Y2tzL3NyYy9wcmVjb21waWxlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBwcmVjb21waWxlR2xvYmFsKHRlbXBsYXRlcywgb3B0cykge1xuICB2YXIgb3V0ID0gJyc7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IEpTT04uc3RyaW5naWZ5KHRlbXBsYXRlc1tpXS5uYW1lKTtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlc1tpXS50ZW1wbGF0ZTtcblxuICAgIG91dCArPSAnKGZ1bmN0aW9uKCkgeycgK1xuICAgICAgJyh3aW5kb3cubnVuanVja3NQcmVjb21waWxlZCA9IHdpbmRvdy5udW5qdWNrc1ByZWNvbXBpbGVkIHx8IHt9KScgK1xuICAgICAgJ1snICsgbmFtZSArICddID0gKGZ1bmN0aW9uKCkge1xcbicgKyB0ZW1wbGF0ZSArICdcXG59KSgpO1xcbic7XG5cbiAgICBpZiAob3B0cy5hc0Z1bmN0aW9uKSB7XG4gICAgICBvdXQgKz0gJ3JldHVybiBmdW5jdGlvbihjdHgsIGNiKSB7IHJldHVybiBudW5qdWNrcy5yZW5kZXIoJyArIG5hbWUgKyAnLCBjdHgsIGNiKTsgfVxcbic7XG4gICAgfVxuXG4gICAgb3V0ICs9ICd9KSgpO1xcbic7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcmVjb21waWxlR2xvYmFsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbnVuanVja3Mvc3JjL3ByZWNvbXBpbGUtZ2xvYmFsLmpzIiwiZnVuY3Rpb24gaW5zdGFsbENvbXBhdCgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuXG4gIC8vIFRoaXMgbXVzdCBiZSBjYWxsZWQgbGlrZSBgbnVuanVja3MuaW5zdGFsbENvbXBhdGAgc28gdGhhdCBgdGhpc2BcbiAgLy8gcmVmZXJlbmNlcyB0aGUgbnVuanVja3MgaW5zdGFuY2VcbiAgdmFyIHJ1bnRpbWUgPSB0aGlzLnJ1bnRpbWU7XG4gIHZhciBsaWIgPSB0aGlzLmxpYjtcbiAgLy8gSGFuZGxlIHNsaW0gY2FzZSB3aGVyZSB0aGVzZSAnbW9kdWxlcycgYXJlIGV4Y2x1ZGVkIGZyb20gdGhlIGJ1aWx0IHNvdXJjZVxuICB2YXIgQ29tcGlsZXIgPSB0aGlzLmNvbXBpbGVyLkNvbXBpbGVyO1xuICB2YXIgUGFyc2VyID0gdGhpcy5wYXJzZXIuUGFyc2VyO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICB2YXIgbGV4ZXIgPSB0aGlzLmxleGVyO1xuXG4gIHZhciBvcmlnX2NvbnRleHRPckZyYW1lTG9va3VwID0gcnVudGltZS5jb250ZXh0T3JGcmFtZUxvb2t1cDtcbiAgdmFyIG9yaWdfbWVtYmVyTG9va3VwID0gcnVudGltZS5tZW1iZXJMb29rdXA7XG4gIHZhciBvcmlnX0NvbXBpbGVyX2Fzc2VydFR5cGU7XG4gIHZhciBvcmlnX1BhcnNlcl9wYXJzZUFnZ3JlZ2F0ZTtcbiAgaWYgKENvbXBpbGVyKSB7XG4gICAgb3JpZ19Db21waWxlcl9hc3NlcnRUeXBlID0gQ29tcGlsZXIucHJvdG90eXBlLmFzc2VydFR5cGU7XG4gIH1cbiAgaWYgKFBhcnNlcikge1xuICAgIG9yaWdfUGFyc2VyX3BhcnNlQWdncmVnYXRlID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUFnZ3JlZ2F0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuaW5zdGFsbCgpIHtcbiAgICBydW50aW1lLmNvbnRleHRPckZyYW1lTG9va3VwID0gb3JpZ19jb250ZXh0T3JGcmFtZUxvb2t1cDtcbiAgICBydW50aW1lLm1lbWJlckxvb2t1cCA9IG9yaWdfbWVtYmVyTG9va3VwO1xuICAgIGlmIChDb21waWxlcikge1xuICAgICAgQ29tcGlsZXIucHJvdG90eXBlLmFzc2VydFR5cGUgPSBvcmlnX0NvbXBpbGVyX2Fzc2VydFR5cGU7XG4gICAgfVxuICAgIGlmIChQYXJzZXIpIHtcbiAgICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBZ2dyZWdhdGUgPSBvcmlnX1BhcnNlcl9wYXJzZUFnZ3JlZ2F0ZTtcbiAgICB9XG4gIH1cblxuICBydW50aW1lLmNvbnRleHRPckZyYW1lTG9va3VwID0gZnVuY3Rpb24gY29udGV4dE9yRnJhbWVMb29rdXAoY29udGV4dCwgZnJhbWUsIGtleSkge1xuICAgIHZhciB2YWwgPSBvcmlnX2NvbnRleHRPckZyYW1lTG9va3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSAnVHJ1ZSc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnRmFsc2UnOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBjYXNlICdOb25lJzpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRUb2tlbnNTdGF0ZSh0b2tlbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXg6IHRva2Vucy5pbmRleCxcbiAgICAgIGxpbmVubzogdG9rZW5zLmxpbmVubyxcbiAgICAgIGNvbG5vOiB0b2tlbnMuY29sbm9cbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52LkJVSUxEX1RZUEUgIT09ICdTTElNJyAmJiBub2RlcyAmJiBDb21waWxlciAmJiBQYXJzZXIpIHsgLy8gaS5lLiwgbm90IHNsaW0gbW9kZVxuICAgIGNvbnN0IFNsaWNlID0gbm9kZXMuTm9kZS5leHRlbmQoJ1NsaWNlJywge1xuICAgICAgZmllbGRzOiBbJ3N0YXJ0JywgJ3N0b3AnLCAnc3RlcCddLFxuICAgICAgaW5pdChsaW5lbm8sIGNvbG5vLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IG5ldyBub2Rlcy5MaXRlcmFsKGxpbmVubywgY29sbm8sIG51bGwpO1xuICAgICAgICBzdG9wID0gc3RvcCB8fCBuZXcgbm9kZXMuTGl0ZXJhbChsaW5lbm8sIGNvbG5vLCBudWxsKTtcbiAgICAgICAgc3RlcCA9IHN0ZXAgfHwgbmV3IG5vZGVzLkxpdGVyYWwobGluZW5vLCBjb2xubywgMSk7XG4gICAgICAgIHRoaXMucGFyZW50KGxpbmVubywgY29sbm8sIHN0YXJ0LCBzdG9wLCBzdGVwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIENvbXBpbGVyLnByb3RvdHlwZS5hc3NlcnRUeXBlID0gZnVuY3Rpb24gYXNzZXJ0VHlwZShub2RlKSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFNsaWNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9yaWdfQ29tcGlsZXJfYXNzZXJ0VHlwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgQ29tcGlsZXIucHJvdG90eXBlLmNvbXBpbGVTbGljZSA9IGZ1bmN0aW9uIGNvbXBpbGVTbGljZShub2RlLCBmcmFtZSkge1xuICAgICAgdGhpcy5fZW1pdCgnKCcpO1xuICAgICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS5zdGFydCwgZnJhbWUpO1xuICAgICAgdGhpcy5fZW1pdCgnKSwoJyk7XG4gICAgICB0aGlzLl9jb21waWxlRXhwcmVzc2lvbihub2RlLnN0b3AsIGZyYW1lKTtcbiAgICAgIHRoaXMuX2VtaXQoJyksKCcpO1xuICAgICAgdGhpcy5fY29tcGlsZUV4cHJlc3Npb24obm9kZS5zdGVwLCBmcmFtZSk7XG4gICAgICB0aGlzLl9lbWl0KCcpJyk7XG4gICAgfTtcblxuICAgIFBhcnNlci5wcm90b3R5cGUucGFyc2VBZ2dyZWdhdGUgPSBmdW5jdGlvbiBwYXJzZUFnZ3JlZ2F0ZSgpIHtcbiAgICAgIHZhciBvcmlnU3RhdGUgPSBnZXRUb2tlbnNTdGF0ZSh0aGlzLnRva2Vucyk7XG4gICAgICAvLyBTZXQgYmFjayBvbmUgYWNjb3VudGluZyBmb3Igb3BlbmluZyBicmFja2V0L3BhcmVuc1xuICAgICAgb3JpZ1N0YXRlLmNvbG5vLS07XG4gICAgICBvcmlnU3RhdGUuaW5kZXgtLTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvcmlnX1BhcnNlcl9wYXJzZUFnZ3JlZ2F0ZS5hcHBseSh0aGlzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyU3RhdGUgPSBnZXRUb2tlbnNTdGF0ZSh0aGlzLnRva2Vucyk7XG4gICAgICAgIGNvbnN0IHJldGhyb3cgPSAoKSA9PiB7XG4gICAgICAgICAgbGliLl9hc3NpZ24odGhpcy50b2tlbnMsIGVyclN0YXRlKTtcbiAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXNldCB0byBzdGF0ZSBiZWZvcmUgb3JpZ2luYWwgcGFyc2VBZ2dyZWdhdGUgY2FsbGVkXG4gICAgICAgIGxpYi5fYXNzaWduKHRoaXMudG9rZW5zLCBvcmlnU3RhdGUpO1xuICAgICAgICB0aGlzLnBlZWtlZCA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHRvayA9IHRoaXMucGVla1Rva2VuKCk7XG4gICAgICAgIGlmICh0b2sudHlwZSAhPT0gbGV4ZXIuVE9LRU5fTEVGVF9CUkFDS0VUKSB7XG4gICAgICAgICAgdGhyb3cgcmV0aHJvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub2RlID0gbmV3IFNsaWNlKHRvay5saW5lbm8sIHRvay5jb2xubyk7XG5cbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZW5jb3VudGVyIGEgY29sb24gd2hpbGUgcGFyc2luZywgdGhpcyBpcyBub3QgYSBzbGljZSxcbiAgICAgICAgLy8gc28gcmUtcmFpc2UgdGhlIG9yaWdpbmFsIGV4Y2VwdGlvbi5cbiAgICAgICAgbGV0IGlzU2xpY2UgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBub2RlLmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLnNraXAobGV4ZXIuVE9LRU5fUklHSFRfQlJBQ0tFVCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gbm9kZS5maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaXNTbGljZSkge1xuICAgICAgICAgICAgICB0aGlzLmZhaWwoJ3BhcnNlU2xpY2U6IHRvbyBtYW55IHNsaWNlIGNvbXBvbmVudHMnLCB0b2subGluZW5vLCB0b2suY29sbm8pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnNraXAobGV4ZXIuVE9LRU5fQ09MT04pKSB7XG4gICAgICAgICAgICBpc1NsaWNlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBub2RlLmZpZWxkc1tpXTtcbiAgICAgICAgICAgIG5vZGVbZmllbGRdID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICAgIGlzU2xpY2UgPSB0aGlzLnNraXAobGV4ZXIuVE9LRU5fQ09MT04pIHx8IGlzU2xpY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTbGljZSkge1xuICAgICAgICAgIHRocm93IHJldGhyb3coKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IG5vZGVzLkFycmF5KHRvay5saW5lbm8sIHRvay5jb2xubywgW25vZGVdKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2xpY2VMb29rdXAob2JqLCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIG9iaiA9IG9iaiB8fCBbXTtcbiAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgIHN0YXJ0ID0gKHN0ZXAgPCAwKSA/IChvYmoubGVuZ3RoIC0gMSkgOiAwO1xuICAgIH1cbiAgICBpZiAoc3RvcCA9PT0gbnVsbCkge1xuICAgICAgc3RvcCA9IChzdGVwIDwgMCkgPyAtMSA6IG9iai5sZW5ndGg7XG4gICAgfSBlbHNlIGlmIChzdG9wIDwgMCkge1xuICAgICAgc3RvcCArPSBvYmoubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgIHN0YXJ0ICs9IG9iai5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyA7IGkgKz0gc3RlcCkge1xuICAgICAgaWYgKGkgPCAwIHx8IGkgPiBvYmoubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0ZXAgPiAwICYmIGkgPj0gc3RvcCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGVwIDwgMCAmJiBpIDw9IHN0b3ApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXN1bHRzLnB1c2gocnVudGltZS5tZW1iZXJMb29rdXAob2JqLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFzT3duUHJvcChvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9XG5cbiAgY29uc3QgQVJSQVlfTUVNQkVSUyA9IHtcbiAgICBwb3AoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcCgpO1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID49IHRoaXMubGVuZ3RoIHx8IGluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleUVycm9yJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH0sXG4gICAgYXBwZW5kKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1c2goZWxlbWVudCk7XG4gICAgfSxcbiAgICByZW1vdmUoZWxlbWVudCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzW2ldID09PSBlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlRXJyb3InKTtcbiAgICB9LFxuICAgIGNvdW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXNbaV0gPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcbiAgICBpbmRleChlbGVtZW50KSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGlmICgoaSA9IHRoaXMuaW5kZXhPZihlbGVtZW50KSkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWVFcnJvcicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGk7XG4gICAgfSxcbiAgICBmaW5kKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4T2YoZWxlbWVudCk7XG4gICAgfSxcbiAgICBpbnNlcnQoaW5kZXgsIGVsZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLnNwbGljZShpbmRleCwgMCwgZWxlbSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBPQkpFQ1RfTUVNQkVSUyA9IHtcbiAgICBpdGVtcygpIHtcbiAgICAgIHJldHVybiBsaWIuX2VudHJpZXModGhpcyk7XG4gICAgfSxcbiAgICB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gbGliLl92YWx1ZXModGhpcyk7XG4gICAgfSxcbiAgICBrZXlzKCkge1xuICAgICAgcmV0dXJuIGxpYi5rZXlzKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0KGtleSwgZGVmKSB7XG4gICAgICB2YXIgb3V0cHV0ID0gdGhpc1trZXldO1xuICAgICAgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dCA9IGRlZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcbiAgICBoYXNfa2V5KGtleSkge1xuICAgICAgcmV0dXJuIGhhc093blByb3AodGhpcywga2V5KTtcbiAgICB9LFxuICAgIHBvcChrZXksIGRlZikge1xuICAgICAgdmFyIG91dHB1dCA9IHRoaXNba2V5XTtcbiAgICAgIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCAmJiBkZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQgPSBkZWY7XG4gICAgICB9IGVsc2UgaWYgKG91dHB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignS2V5RXJyb3InKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0sXG4gICAgcG9waXRlbSgpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBsaWIua2V5cyh0aGlzKTtcbiAgICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlFcnJvcicpO1xuICAgICAgfVxuICAgICAgY29uc3QgayA9IGtleXNbMF07XG4gICAgICBjb25zdCB2YWwgPSB0aGlzW2tdO1xuICAgICAgZGVsZXRlIHRoaXNba107XG4gICAgICByZXR1cm4gW2ssIHZhbF07XG4gICAgfSxcbiAgICBzZXRkZWZhdWx0KGtleSwgZGVmID0gbnVsbCkge1xuICAgICAgaWYgKCEoa2V5IGluIHRoaXMpKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IGRlZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzW2tleV07XG4gICAgfSxcbiAgICB1cGRhdGUoa3dhcmdzKSB7XG4gICAgICBsaWIuX2Fzc2lnbih0aGlzLCBrd2FyZ3MpO1xuICAgICAgcmV0dXJuIG51bGw7IC8vIEFsd2F5cyByZXR1cm5zIE5vbmVcbiAgICB9XG4gIH07XG4gIE9CSkVDVF9NRU1CRVJTLml0ZXJpdGVtcyA9IE9CSkVDVF9NRU1CRVJTLml0ZW1zO1xuICBPQkpFQ1RfTUVNQkVSUy5pdGVydmFsdWVzID0gT0JKRUNUX01FTUJFUlMudmFsdWVzO1xuICBPQkpFQ1RfTUVNQkVSUy5pdGVya2V5cyA9IE9CSkVDVF9NRU1CRVJTLmtleXM7XG5cbiAgcnVudGltZS5tZW1iZXJMb29rdXAgPSBmdW5jdGlvbiBtZW1iZXJMb29rdXAob2JqLCB2YWwsIGF1dG9lc2NhcGUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIHNsaWNlTG9va3VwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9iaiA9IG9iaiB8fCB7fTtcblxuICAgIC8vIElmIHRoZSBvYmplY3QgaXMgYW4gb2JqZWN0LCByZXR1cm4gYW55IG9mIHRoZSBtZXRob2RzIHRoYXQgUHl0aG9uIHdvdWxkXG4gICAgLy8gb3RoZXJ3aXNlIHByb3ZpZGUuXG4gICAgaWYgKGxpYi5pc0FycmF5KG9iaikgJiYgaGFzT3duUHJvcChBUlJBWV9NRU1CRVJTLCB2YWwpKSB7XG4gICAgICByZXR1cm4gQVJSQVlfTUVNQkVSU1t2YWxdLmJpbmQob2JqKTtcbiAgICB9XG4gICAgaWYgKGxpYi5pc09iamVjdChvYmopICYmIGhhc093blByb3AoT0JKRUNUX01FTUJFUlMsIHZhbCkpIHtcbiAgICAgIHJldHVybiBPQkpFQ1RfTUVNQkVSU1t2YWxdLmJpbmQob2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3JpZ19tZW1iZXJMb29rdXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICByZXR1cm4gdW5pbnN0YWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc3RhbGxDb21wYXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9udW5qdWNrcy9zcmMvamluamEtY29tcGF0LmpzIiwiaW1wb3J0IHsgTWV0aG9kIH0gZnJvbSAnLi9tZXRob2RzJztcbmV4cG9ydCBjbGFzcyBCcmlkZ2Uge1xuICBuYW1lOiBzdHJpbmc7XG4gIG1ldGhvZHM6IE1hcDxzdHJpbmcsIE1ldGhvZD4gPSBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG59XG4iLCJpbXBvcnQgeyBpc0FycmF5LCBpc1N0cmluZywgaXNGdW5jdGlvbiB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBCcmlkZ2UgfSBmcm9tICcuL2JyaWRnZSc7XG5pbXBvcnQgeyBNZXRob2QgfSBmcm9tICcuL21ldGhvZHMnO1xuXG5jbGFzcyBDbGllbnQge1xuICBwcm9wcyE6IElQcm9wcztcbiAgYnJpZGdlTWFwOiBNYXA8c3RyaW5nLCBCcmlkZ2U+O1xuICBjdXJCcmlkZ2VOYW1lOiBzdHJpbmc7XG4gIGN1ck1ldGhvZHNOYW1lOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IElQcm9wcykge1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLmJyaWRnZU1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgY29uc3QgeyBicmlkZ2UgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgaGFuZGxlID0gbmFtZSA9PiB7XG4gICAgICB0aGlzLmN1ckJyaWRnZU5hbWUgPSBuYW1lO1xuICAgICAgdGhpcy5icmlkZ2VNYXAuc2V0KG5hbWUsIG5ldyBCcmlkZ2UobmFtZSkpO1xuICAgICAgdGhpcy5oYW5kbGVTaW5nbGVCcmlkZ2UobmFtZSk7XG4gICAgfTtcbiAgICBpZiAoaXNBcnJheShicmlkZ2UpKSB7XG4gICAgICAoYnJpZGdlIGFzIHN0cmluZ1tdKS5mb3JFYWNoKGIgPT4gaGFuZGxlKGIpKTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKGJyaWRnZSkpIHtcbiAgICAgIGhhbmRsZShicmlkZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZVNpbmdsZUJyaWRnZShicmlkZ2UpIHtcbiAgICBpZiAodHlwZW9mIGJyaWRnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGJyaWRnZU1hcCA9IHdpbmRvd1ticmlkZ2VdO1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGJyaWRnZU1hcCk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGJyaWRnZU1hcFtrZXldKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJCcmlkZ2UgPSB0aGlzLmJyaWRnZU1hcC5nZXQodGhpcy5jdXJCcmlkZ2VOYW1lKTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gbmV3IE1ldGhvZChrZXkpO1xuICAgICAgICBjdXJCcmlkZ2UubWV0aG9kcy5zZXQoa2V5LCBtZXRob2QpO1xuICAgICAgICBjb25zdCBfZm4gPSBicmlkZ2VNYXBba2V5XTtcbiAgICAgICAgY29uc3QgZm4gPSAoLi4ucGFyYW1zKSA9PiB7XG4gICAgICAgICAgbWV0aG9kLnJlZnJlc2goKTtcbiAgICAgICAgICAvLyDmi6bmiKrlhaXlj4JcbiAgICAgICAgICB0aGlzLmludGVyY2VwdFBhcmFtcyhwYXJhbXMsIG1ldGhvZCk7XG4gICAgICAgICAgLy8g5oum5oiq6L+U5Zue5YC8XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gX2ZuLmFwcGx5KHRoaXMsIHBhcmFtcyk7XG4gICAgICAgICAgbWV0aG9kLnJlc3VsdC5zZXQoJ3JldHVybicsIHJlc3VsdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgbWV0aG9kLl9mbiA9IF9mbjtcbiAgICAgICAgbWV0aG9kLmZuID0gZm47XG4gICAgICAgIGJyaWRnZU1hcFtrZXldID0gZm47XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpbnRlcmNlcHRQYXJhbXMocGFyYW1zLCBtZXRob2Q6IE1ldGhvZCkge1xuICAgIHBhcmFtcy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgIG1ldGhvZC5wcm9wcy5wdXNoKHBhcmFtKTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHBhcmFtKSkge1xuICAgICAgICAvLyDlpITnkIbov5Tlm57lgLzlnKjlm57osIPkuK3mg4XlhrVcbiAgICAgICAgcGFyYW1zW2luZGV4XSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgbWV0aG9kLnJlc3VsdC5zZXQoYGNiJHtpbmRleH1gLCBhcmdzKTtcbiAgICAgICAgICByZXR1cm4gcGFyYW0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IENsaWVudDtcbiIsImV4cG9ydCBjbGFzcyBNZXRob2Qge1xuICBuYW1lOiBzdHJpbmc7XG4gIF9mbjogRnVuY3Rpb247XG4gIGZuOiBGdW5jdGlvbjtcbiAgaXNDYWxsZWQ6IEJvb2xlYW4gPSBmYWxzZTtcbiAgcHJvcHM6IGFueVtdID0gW107XG4gIHJlc3VsdDogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHRoaXMuaXNDYWxsZWQgPSB0cnVlO1xuICAgIHRoaXMucHJvcHMgPSBbXTtcbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgfVxufVxuIiwiaW1wb3J0IENsaWVudCBmcm9tICcuL2NsaWVudC9pbmRleCc7XG5pbXBvcnQgTG9nIGZyb20gJy4vbG9nL2luZGV4JztcbmltcG9ydCBTdXJmYWNlIGZyb20gJy4vc3VyZmFjZSc7XG5cbmNsYXNzIEludGVyZmFjZUxvZyB7XG4gIHByaXZhdGUgX3N1cmZhY2UhOiBTdXJmYWNlO1xuICBwcml2YXRlIF9jbGllbnQhOiBDbGllbnQ7XG5cbiAgY29uc3RydWN0b3IoY29uZmlnOiBJUHJvcHMpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZUNsaWVudChjb25maWcpO1xuICAgIHRoaXMuX2luaXRTdXJmYWNlKCk7XG4gIH1cbiAgcHJpdmF0ZSBwcmludENvbnRlbnQoKSB7XG4gICAgY29uc3QgYnJpZGdlcyA9IHRoaXMuX2NsaWVudC5icmlkZ2VNYXAudmFsdWVzKCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYnJpZGdlcyk7XG4gICAgLy8gcmV0dXJuIHRoaXMuX2NsaWVudDtcbiAgfVxuICBwcml2YXRlIF9pbml0U3VyZmFjZSgpIHtcbiAgICB0aGlzLl9zdXJmYWNlID0gbmV3IFN1cmZhY2UoKTtcbiAgICBsZXQgJGRvbSA9IG5ldyBMb2coKS5nZXRGb2xkZWRMaW5lKHRoaXMucHJpbnRDb250ZW50KCkpO1xuICAgIHRoaXMuX3N1cmZhY2UuYXBwZW5kKCRkb20pO1xuICAgIHRoaXMuX3N1cmZhY2UucmVmcmVzaCgoKSA9PiB7XG4gICAgICAkZG9tID0gbmV3IExvZygpLmdldEZvbGRlZExpbmUodGhpcy5wcmludENvbnRlbnQoKSk7XG4gICAgICB0aGlzLl9zdXJmYWNlLmFwcGVuZCgkZG9tKTtcbiAgICB9KTtcbiAgfVxuICBfZ2VuZXJhdGVDbGllbnQoY29uZmlnOiBJUHJvcHMpIHtcbiAgICBpZiAodGhpcy5fY2xpZW50KSByZXR1cm47XG4gICAgdGhpcy5fY2xpZW50ID0gbmV3IENsaWVudChjb25maWcpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEludGVyZmFjZUxvZztcbiIsImltcG9ydCAqIGFzIG51bmp1Y2tzIGZyb20gJ251bmp1Y2tzJztcbmltcG9ydCBmbG9kVHBsIGZyb20gJy4vZmxvZC5odG1sJztcbmltcG9ydCBjb2RlVHBsIGZyb20gJy4vY29kZS5odG1sJztcbmltcG9ydCBmbG9kQ29kZVRwbCBmcm9tICcuL2Zsb2QtY29kZS5odG1sJztcbmltcG9ydCB7XG4gIEpTT05TdHJpbmdpZnksXG4gIGdldE9iak5hbWUsXG4gIGlzU3RyaW5nLFxuICBpc051bWJlcixcbiAgaXNCb29sZWFuLFxuICBpc051bGwsXG4gIGlzVW5kZWZpbmVkLFxuICBpc0Z1bmN0aW9uLFxuICBpc1N5bWJvbCxcbiAgZ2V0T2JqQWxsS2V5cyxcbiAgaXNBcnJheSxcbiAgaXNPYmplY3QsXG4gIGh0bWxFbmNvZGUsXG4gIGlzTWFwLFxuICBpc1NldCxcbn0gZnJvbSAnLi4vdXRpbC90b29sJztcbmltcG9ydCB7IFN0cmluZzJEb20sIGhhc0NsYXNzLCByZW1vdmVDbGFzcywgYWRkQ2xhc3MgfSBmcm9tICcuLi91dGlsL2RvbSc7XG5pbXBvcnQgJy4vaW5kZXgubGVzcyc7XG5cbmNsYXNzIExvZyB7XG4gIF9nZXRPdXRlcihvYmopIHtcbiAgICBsZXQgb3V0ZXIgPSAnJztcbiAgICBsZXQganNvbiA9IEpTT05TdHJpbmdpZnkob2JqKTtcbiAgICBsZXQgcHJldmlldyA9IGpzb24uc3Vic3RyKDAsIDM2KTtcbiAgICBvdXRlciA9IGdldE9iak5hbWUob2JqKTtcbiAgICBpZiAoanNvbi5sZW5ndGggPiAzNikge1xuICAgICAgcHJldmlldyArPSAnLi4uJztcbiAgICB9XG4gICAgb3V0ZXIgKz0gJyAnICsgcHJldmlldztcbiAgICByZXR1cm4gb3V0ZXI7XG4gIH1cblxuICBnZXRGb2xkZWRMaW5lKG9iaiwgb3V0ZXI/KSB7XG4gICAgaWYgKCFvdXRlcikge1xuICAgICAgb3V0ZXIgPSB0aGlzLl9nZXRPdXRlcihvYmopO1xuICAgIH1cbiAgICBsZXQgJGxpbmUgPSA8SFRNTEVsZW1lbnQ+U3RyaW5nMkRvbShcbiAgICAgIG51bmp1Y2tzLnJlbmRlclN0cmluZyhmbG9kVHBsLCB7XG4gICAgICAgIG91dGVyOiBvdXRlcixcbiAgICAgICAgbGluZVR5cGU6ICdvYmonLFxuICAgICAgfSlcbiAgICApO1xuICAgICRsaW5lLnF1ZXJ5U2VsZWN0b3IoJy52Yy1mb2xkLW91dGVyJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICBjb25zdCAkaW5uZXIgPSA8SFRNTEVsZW1lbnQ+JGxpbmUucXVlcnlTZWxlY3RvcignLnZjLWZvbGQtaW5uZXInKTtcbiAgICAgIGNvbnN0ICRvdXRlciA9IDxIVE1MRWxlbWVudD4kbGluZS5xdWVyeVNlbGVjdG9yKCcudmMtZm9sZC1vdXRlcicpO1xuICAgICAgaWYgKGhhc0NsYXNzKCRsaW5lLCAndmMtdG9nZ2xlJykpIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoJGxpbmUsICd2Yy10b2dnbGUnKTtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoJGlubmVyLCAndmMtdG9nZ2xlJyk7XG4gICAgICAgIHJlbW92ZUNsYXNzKCRvdXRlciwgJ3ZjLXRvZ2dsZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkQ2xhc3MoJGxpbmUsICd2Yy10b2dnbGUnKTtcbiAgICAgICAgYWRkQ2xhc3MoJGlubmVyLCAndmMtdG9nZ2xlJyk7XG4gICAgICAgIGFkZENsYXNzKCRvdXRlciwgJ3ZjLXRvZ2dsZScpO1xuICAgICAgfVxuICAgICAgbGV0ICRjb250ZW50ID0gJGlubmVyO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICgkY29udGVudC5jaGlsZHJlbi5sZW5ndGggPiAwIHx8ICFvYmopIHJldHVybjtcbiAgICAgICAgaWYgKGlzTWFwKG9iaikgJiYgaXNNYXAob2JqLl9fcHJvdG9fXykpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJNYXBLZXlzKG9iaiwgJGNvbnRlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJlbmRlciBvYmplY3QncyBrZXlzXG4gICAgICAgICAgdGhpcy5fcmVuZGVyT2JqZWN0S2V5cyhvYmosICRjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW5kZXIgb2JqZWN0J3MgcHJvdG90eXBlXG4gICAgICAgIHRoaXMuX3JlbmRlclByb3RvdHlwZShvYmosICRjb250ZW50KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiAkbGluZTtcbiAgfVxuXG4gIF9yZW5kZXJPYmplY3RLZXlzKG9iaiwgJGNvbnRlbnQpIHtcbiAgICBsZXQga2V5cyA9IGdldE9iakFsbEtleXMob2JqKTtcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGxldCB2YWw7XG4gICAgICB0cnkge1xuICAgICAgICB2YWwgPSBvYmpba2V5XTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB0aGlzLl9yZW5kZXJGbG93KG9iaiwgdmFsLCBrZXksICRjb250ZW50KTtcbiAgICB9KTtcbiAgfVxuICBfcmVuZGVyTWFwS2V5cyhvYmosICRjb250ZW50KSB7XG4gICAgb2JqLmZvckVhY2goKHZhbCwga2V5KSA9PiB7XG4gICAgICB0aGlzLl9yZW5kZXJGbG93KG9iaiwgdmFsLCBrZXksICRjb250ZW50KTtcbiAgICB9KTtcbiAgfVxuICBfcmVuZGVyRmxvdyhvYmosIHZhbCwga2V5LCAkY29udGVudCkge1xuICAgIGxldCB2YWx1ZVR5cGUgPSAndW5kZWZpbmVkJyxcbiAgICAgIGtleVR5cGUgPSAnJztcbiAgICAvLyByZW5kZXJcbiAgICBsZXQgJHN1YjtcbiAgICBpZiAoaXNNYXAodmFsKSkge1xuICAgICAgJHN1YiA9IHRoaXMuX2dlbmVyYXRlTWFwKHZhbCwga2V5LCBrZXlUeXBlKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsKSkge1xuICAgICAgJHN1YiA9IHRoaXMuX2dlbmVyYXRlQXJyYXkodmFsLCBrZXksIGtleVR5cGUpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgJHN1YiA9IHRoaXMuX2dlbmVyYXRlT2JqZWN0KHZhbCwga2V5LCBrZXlUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eSAmJiAhb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAga2V5VHlwZSA9ICdwcml2YXRlJztcbiAgICAgIH1cbiAgICAgICRzdWIgPSB0aGlzLl9nZW5lcmF0ZU5vcm1hbCh2YWwsIGtleSwgdmFsdWVUeXBlLCBrZXlUeXBlKTtcbiAgICB9XG4gICAgJGNvbnRlbnQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdiZWZvcmVlbmQnLCAkc3ViKTtcbiAgfVxuXG4gIF9nZW5lcmF0ZU1hcCh2YWwsIGtleSwga2V5VHlwZSkge1xuICAgIGxldCBuYW1lID0gZ2V0T2JqTmFtZSh2YWwpICsgJ1snICsgdmFsLnNpemUgKyAnXSc7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Rm9sZGVkTGluZShcbiAgICAgIHZhbCxcbiAgICAgIG51bmp1Y2tzLnJlbmRlclN0cmluZyhmbG9kQ29kZVRwbCwge1xuICAgICAgICBrZXksXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB2YWx1ZVR5cGU6ICdhcnJheScsXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgX2dlbmVyYXRlQXJyYXkodmFsLCBrZXksIGtleVR5cGUpIHtcbiAgICBsZXQgbmFtZSA9IGdldE9iak5hbWUodmFsKSArICdbJyArIHZhbC5sZW5ndGggKyAnXSc7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Rm9sZGVkTGluZShcbiAgICAgIHZhbCxcbiAgICAgIG51bmp1Y2tzLnJlbmRlclN0cmluZyhmbG9kQ29kZVRwbCwge1xuICAgICAgICBrZXksXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB2YWx1ZVR5cGU6ICdhcnJheScsXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgX2dlbmVyYXRlT2JqZWN0KHZhbCwga2V5LCBrZXlUeXBlKSB7XG4gICAgbGV0IG5hbWUgPSBnZXRPYmpOYW1lKHZhbCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Rm9sZGVkTGluZShcbiAgICAgIHZhbCxcbiAgICAgIG51bmp1Y2tzLnJlbmRlclN0cmluZyhmbG9kQ29kZVRwbCwge1xuICAgICAgICBrZXk6IGh0bWxFbmNvZGUoa2V5KSxcbiAgICAgICAga2V5VHlwZToga2V5VHlwZSxcbiAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgIHZhbHVlVHlwZTogJ29iamVjdCcsXG4gICAgICB9KVxuICAgICk7XG4gIH1cbiAgX2dlbmVyYXRlTm9ybWFsKHZhbCwga2V5LCB2YWx1ZVR5cGUsIGtleVR5cGUpIHtcbiAgICAvLyBoYW5kbGUgdmFsdWVcbiAgICBpZiAoaXNTdHJpbmcodmFsKSkge1xuICAgICAgdmFsdWVUeXBlID0gJ3N0cmluZyc7XG4gICAgICB2YWwgPSAnXCInICsgdmFsICsgJ1wiJztcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKHZhbCkpIHtcbiAgICAgIHZhbHVlVHlwZSA9ICdudW1iZXInO1xuICAgIH0gZWxzZSBpZiAoaXNCb29sZWFuKHZhbCkpIHtcbiAgICAgIHZhbHVlVHlwZSA9ICdib29sZWFuJztcbiAgICB9IGVsc2UgaWYgKGlzTnVsbCh2YWwpKSB7XG4gICAgICB2YWx1ZVR5cGUgPSAnbnVsbCc7XG4gICAgICB2YWwgPSAnbnVsbCc7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICB2YWx1ZVR5cGUgPSAndW5kZWZpbmVkJztcbiAgICAgIHZhbCA9ICd1bmRlZmluZWQnO1xuICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICB2YWx1ZVR5cGUgPSAnZnVuY3Rpb24nO1xuICAgICAgdmFsID0gJ2Z1bmN0aW9uKCknO1xuICAgIH0gZWxzZSBpZiAoaXNTeW1ib2wodmFsKSkge1xuICAgICAgdmFsdWVUeXBlID0gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcyRG9tKFxuICAgICAgbnVuanVja3MucmVuZGVyU3RyaW5nKGZsb2RUcGwsIHtcbiAgICAgICAgbGluZVR5cGU6ICdrdicsXG4gICAgICAgIGtleTogaHRtbEVuY29kZShrZXkpLFxuICAgICAgICBrZXlUeXBlOiBrZXlUeXBlLFxuICAgICAgICB2YWx1ZTogaHRtbEVuY29kZSh2YWwpLFxuICAgICAgICB2YWx1ZVR5cGU6IHZhbHVlVHlwZSxcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIF9yZW5kZXJQcm90b3R5cGUob2JqLCAkY29udGVudCkge1xuICAgIC8vIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuO1xuICAgIGxldCBwcm90byA9IG9iai5fX3Byb3RvX18sXG4gICAgICAkcHJvdG87XG4gICAgLy8gaWYgKGlzT2JqZWN0KHByb3RvKSkge1xuICAgICRwcm90byA9IHRoaXMuZ2V0Rm9sZGVkTGluZShcbiAgICAgIHByb3RvLFxuICAgICAgbnVuanVja3MucmVuZGVyU3RyaW5nKGZsb2RDb2RlVHBsLCB7XG4gICAgICAgIGtleTogJ19fcHJvdG9fXycsXG4gICAgICAgIGtleVR5cGU6ICdwcml2YXRlJyxcbiAgICAgICAgdmFsdWU6IGdldE9iak5hbWUocHJvdG8pLFxuICAgICAgICB2YWx1ZVR5cGU6ICdvYmplY3QnLFxuICAgICAgfSlcbiAgICApO1xuICAgIC8vIH0gZWxzZSB7XG4gICAgLy8gICAvLyBpZiBwcm90byBpcyBub3QgYW4gb2JqZWN0LCBpdCBzaG91bGQgYmUgYG51bGxgXG4gICAgLy8gICAkcHJvdG8gPSBTdHJpbmcyRG9tKFxuICAgIC8vICAgICBudW5qdWNrcy5yZW5kZXJTdHJpbmcoZmxvZENvZGVUcGwsIHtcbiAgICAvLyAgICAgICBrZXk6ICdfX3Byb3RvX18nLFxuICAgIC8vICAgICAgIGtleVR5cGU6ICdwcml2YXRlJyxcbiAgICAvLyAgICAgICB2YWx1ZTogJ251bGwnLFxuICAgIC8vICAgICAgIHZhbHVlVHlwZTogJ251bGwnLFxuICAgIC8vICAgICB9KVxuICAgIC8vICAgKTtcbiAgICAvLyB9XG4gICAgJGNvbnRlbnQuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdiZWZvcmVlbmQnLCAkcHJvdG8pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExvZztcbiIsImltcG9ydCB7IGlzQXJyYXksIGlzU3RyaW5nLCBpc0Z1bmN0aW9uIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBpbmRleFRwbCBmcm9tICcuL3Bhbm5lbC5odG1sJztcbmltcG9ydCAnLi9pbmRleC5sZXNzJztcbmltcG9ydCB7IGFkZERvbVN0cmluZyB9IGZyb20gJy4uL3V0aWwvZG9tJztcbmltcG9ydCBMb2cgZnJvbSAnLi4vbG9nJztcblxuY2xhc3MgU3VyZmFjZSB7XG4gICRyb290OiBIVE1MRWxlbWVudDtcbiAgJGNvbnRlbnQ6IEhUTUxFbGVtZW50O1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIHRoaXMuX2luaXRVbml0KCk7XG4gICAgdGhpcy5faW5pdEV2ZW50KCk7XG4gIH1cbiAgX2luaXRVbml0KCkge1xuICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgY29uc3Qgdmlld3BvcnRFbDogSFRNTE1ldGFFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICdbbmFtZT1cInZpZXdwb3J0XCJdJ1xuICAgICk7XG4gICAgaWYgKHZpZXdwb3J0RWwgJiYgdmlld3BvcnRFbC5jb250ZW50KSB7XG4gICAgICBsZXQgaW5pdGlhbFNjYWxlID0gdmlld3BvcnRFbC5jb250ZW50Lm1hdGNoKFxuICAgICAgICAvaW5pdGlhbFxcLXNjYWxlXFw9XFxkKyhcXC5cXGQrKT8vXG4gICAgICApO1xuICAgICAgbGV0IHNjYWxlID0gaW5pdGlhbFNjYWxlID8gcGFyc2VGbG9hdChpbml0aWFsU2NhbGVbMF0uc3BsaXQoJz0nKVsxXSkgOiAxO1xuICAgICAgaWYgKHNjYWxlIDwgMSkge1xuICAgICAgICB0aGlzLiRyb290LnN0eWxlLmZvbnRTaXplID0gMTMgKiBkcHIgKyAncHgnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGREb21TdHJpbmcoXG4gICAgICAgIGRvY3VtZW50LmhlYWQsXG4gICAgICAgICc8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTEuMCwgdXNlci1zY2FsYWJsZT1ubywgdmlld3BvcnQtZml0PWNvdmVyXCI+J1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBfcmVuZGVyKCkge1xuICAgIHRoaXMuX3JlbmRlckdlbmVyYWwoKTtcbiAgfVxuICBfcmVuZGVyR2VuZXJhbCgpIHtcbiAgICB0aGlzLiRyb290ID0gPEhUTUxFbGVtZW50PmFkZERvbVN0cmluZyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGluZGV4VHBsKTtcbiAgICB0aGlzLiRjb250ZW50ID0gdGhpcy4kcm9vdC5xdWVyeVNlbGVjdG9yKCcubG9nX2NvbnRlbnQnKTtcbiAgfVxuICBfaW5pdEV2ZW50KCkge1xuICAgIGNvbnN0IHsgJHJvb3QgfSA9IHRoaXM7XG4gICAgY29uc3QgJGJ0bjogSFRNTEVsZW1lbnQgPSAkcm9vdC5xdWVyeVNlbGVjdG9yKCcubG9nX2J0bicpO1xuICAgIGNvbnN0ICRwYW5lbDogSFRNTEVsZW1lbnQgPSAkcm9vdC5xdWVyeVNlbGVjdG9yKCcubG9nX3BhbmVsJyk7XG4gICAgY29uc3QgJGhpZGU6IEhUTUxFbGVtZW50ID0gJHJvb3QucXVlcnlTZWxlY3RvcignLmxvZ19oaWRlJyk7XG4gICAgY29uc3QgJG1hc2s6IEhUTUxFbGVtZW50ID0gJHJvb3QucXVlcnlTZWxlY3RvcignLmxvZ19tYXNrJyk7XG4gICAgY29uc3QgJGNsZWFyOiBIVE1MRWxlbWVudCA9ICRyb290LnF1ZXJ5U2VsZWN0b3IoJy5sb2dfY2xlYXInKTtcbiAgICAkYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgJHBhbmVsLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAkYnRuLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAkbWFzay5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB9KTtcbiAgICAkaGlkZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICRwYW5lbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgJGJ0bi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICRtYXNrLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfSk7XG4gICAgJGNsZWFyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdGhpcy4kY29udGVudC5pbm5lckhUTUwgPSAnJztcbiAgICB9KTtcbiAgfVxuXG4gIGFwcGVuZChkb20pIHtcbiAgICB0aGlzLiRjb250ZW50LmFwcGVuZChkb20pO1xuICB9XG4gIHJlZnJlc2goZnVuKSB7XG4gICAgY29uc3QgJHJlZnJlc2g6IEhUTUxFbGVtZW50ID0gdGhpcy4kcm9vdC5xdWVyeVNlbGVjdG9yKCcubG9nX3JlZnJlc2gnKTtcbiAgICAkcmVmcmVzaC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIHRoaXMuJGNvbnRlbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICBmdW4oKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTdXJmYWNlO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIGFkZERvbVN0cmluZyhkaXN0LCB0cGwpIHtcbiAgY29uc3QgZG9tID0gU3RyaW5nMkRvbSh0cGwpO1xuICBkaXN0Lmluc2VydEFkamFjZW50RWxlbWVudCgnYmVmb3JlZW5kJywgZG9tKTtcbiAgcmV0dXJuIGRvbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFN0cmluZzJEb20odHBsKSB7XG4gIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZS5pbm5lckhUTUwgPSB0cGw7XG4gIGNvbnN0IGNoaWxkID0gZS5jaGlsZHJlbjtcbiAgcmV0dXJuIGNoaWxkLmxlbmd0aCA+IDEgPyBBcnJheS5mcm9tKGNoaWxkKSA6IGNoaWxkWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBjbGFzc05hbWU6IHN0cmluZykge1xuICBjb25zdCByZWcgPSBuZXcgUmVnRXhwKCcoXnxcXFxccyspJyArIGNsYXNzTmFtZSArICcoJHxcXFxccyspJyk7XG4gIHJldHVybiByZWcudGVzdChlbC5jbGFzc05hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBjbGFzc05hbWU6IHN0cmluZykge1xuICByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ2xhc3MoZWw6IEhUTUxFbGVtZW50LCBjbGFzc05hbWU6IHN0cmluZykge1xuICByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IE51bWJlcl0nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgU3ltYm9sXSc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgTWFwXSc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IFdlYWtNYXBdJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBTZXRdJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgV2Vha1NldF0nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBPYmplY3RdJyB8fFxuICAgIC8vIGlmIGl0IGlzbid0IGEgcHJpbWl0aXZlIHZhbHVlLCB0aGVuIGl0IGlzIGEgY29tbW9uIG9iamVjdFxuICAgICghaXNOdW1iZXIodmFsdWUpICYmXG4gICAgICAhaXNTdHJpbmcodmFsdWUpICYmXG4gICAgICAhaXNCb29sZWFuKHZhbHVlKSAmJlxuICAgICAgIWlzQXJyYXkodmFsdWUpICYmXG4gICAgICAhaXNOdWxsKHZhbHVlKSAmJlxuICAgICAgIWlzRnVuY3Rpb24odmFsdWUpICYmXG4gICAgICAhaXNVbmRlZmluZWQodmFsdWUpICYmXG4gICAgICAhaXNTeW1ib2wodmFsdWUpICYmXG4gICAgICAhaXNNYXAodmFsdWUpICYmXG4gICAgICAhaXNXZWFrTWFwKHZhbHVlKSAmJlxuICAgICAgIWlzU2V0KHZhbHVlKSAmJlxuICAgICAgIWlzV2Vha1NldCh2YWx1ZSkpXG4gICk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzV2luZG93KHZhbHVlKSB7XG4gIHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIHJldHVybiAoXG4gICAgdG9TdHJpbmcgPT0gJ1tvYmplY3QgZ2xvYmFsXScgfHxcbiAgICB0b1N0cmluZyA9PSAnW29iamVjdCBXaW5kb3ddJyB8fFxuICAgIHRvU3RyaW5nID09ICdbb2JqZWN0IERPTVdpbmRvd10nXG4gICk7XG59XG5cbi8qKlxuICog57qv5a+56LGh77yM5a2X6Z2i6YeP5ZKMT2JqZWN0LmNyZWF0ZVxuICogQHBhcmFtIG9ialxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iajogYW55KSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgbGV0IHByb3RvID0gb2JqO1xuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIFNpbXBsZSBKU09OIHN0cmluZ2lmeSwgc3RyaW5naWZ5IHRvcCBsZXZlbCBrZXktdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEpTT05TdHJpbmdpZnkoc3RyaW5nT2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qoc3RyaW5nT2JqZWN0KSAmJiAhaXNBcnJheShzdHJpbmdPYmplY3QpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cmluZ09iamVjdCk7XG4gIH1cblxuICBsZXQgcHJlZml4ID0gJ3snLFxuICAgIHN1ZmZpeCA9ICd9JztcbiAgaWYgKGlzQXJyYXkoc3RyaW5nT2JqZWN0KSkge1xuICAgIHByZWZpeCA9ICdbJztcbiAgICBzdWZmaXggPSAnXSc7XG4gIH1cbiAgbGV0IHN0ciA9IHByZWZpeDtcbiAgY29uc3Qga2V5cyA9IGdldE9iakFsbEtleXMoc3RyaW5nT2JqZWN0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBjb25zdCB2YWx1ZSA9IHN0cmluZ09iamVjdFtrZXldO1xuICAgIHRyeSB7XG4gICAgICAvLyBrZXlcbiAgICAgIGlmICghaXNBcnJheShzdHJpbmdPYmplY3QpKSB7XG4gICAgICAgIGlmIChpc09iamVjdChrZXkpIHx8IGlzQXJyYXkoa2V5KSB8fCBpc1N5bWJvbChrZXkpKSB7XG4gICAgICAgICAgc3RyICs9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciArPSBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9ICc6ICc7XG4gICAgICB9XG5cbiAgICAgIC8vIHZhbHVlXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgc3RyICs9ICdBcnJheVsnICsgdmFsdWUubGVuZ3RoICsgJ10nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkgfHwgaXNTeW1ib2wodmFsdWUpIHx8IGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHN0ciArPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyICs9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpIDwga2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHN0ciArPSAnLCAnO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICBzdHIgKz0gc3VmZml4O1xuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIGdldCBhbiBvYmplY3QncyBhbGwga2V5cyBpZ25vcmUgd2hldGhlciB0aGV5IGFyZSBub3QgZW51bWVyYWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T2JqQWxsS2V5cyhvYmopIHtcbiAgLy8gaWYgKCFpc09iamVjdChvYmopICYmICFpc0FycmF5KG9iaikpIHtcbiAgLy8gICByZXR1cm4gW107XG4gIC8vIH1cbiAgLy8gaWYgKGlzQXJyYXkob2JqKSkge1xuICAvLyAgIGNvbnN0IG0gPSBbXTtcbiAgLy8gICBvYmouZm9yRWFjaCgoXywgaW5kZXgpID0+IHtcbiAgLy8gICAgIG0ucHVzaChpbmRleCk7XG4gIC8vICAgfSk7XG4gIC8vICAgcmV0dXJuIG07XG4gIC8vIH1cbiAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuc29ydCgpO1xufVxuXG4vKipcbiAqIGdldCBhbiBvYmplY3QncyBwcm90b3R5cGUgbmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T2JqTmFtZShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAuY2FsbChvYmopXG4gICAgLnJlcGxhY2UoJ1tvYmplY3QgJywgJycpXG4gICAgLnJlcGxhY2UoJ10nLCAnJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBodG1sRW5jb2RlKHRleHQpIHtcbiAgcmV0dXJuIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJykuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpXG4gICAgLnBhcmVudE5vZGUgYXMgYW55KS5pbm5lckhUTUw7XG59XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi52Yy1mb2xkLW91dGVyIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbiAgcGFkZGluZy1sZWZ0OiAwLjc2OTIzMDc3ZW07XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxufVxcbi52Yy1mb2xkLW91dGVyOmJlZm9yZSB7XFxuICBjb250ZW50OiAnJztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMC4zMDc2OTIzMWVtO1xcbiAgbGVmdDogMC4xNTM4NDYxNWVtO1xcbiAgd2lkdGg6IDA7XFxuICBoZWlnaHQ6IDA7XFxuICBib3JkZXI6IHRyYW5zcGFyZW50IHNvbGlkIDAuMzA3NjkyMzFlbTtcXG4gIGJvcmRlci1sZWZ0LWNvbG9yOiB2YXIoLS1WQy1GRy0xKTtcXG59XFxuLnZjLWZvbGQtb3V0ZXIudmMtdG9nZ2xlOmJlZm9yZSB7XFxuICB0b3A6IDAuNDYxNTM4NDZlbTtcXG4gIGxlZnQ6IDA7XFxuICBib3JkZXItdG9wLWNvbG9yOiB2YXIoLS1WQy1GRy0xKTtcXG4gIGJvcmRlci1sZWZ0LWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuLnZjLWZvbGQtaW5uZXIge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIG1hcmdpbi1sZWZ0OiAwLjc2OTIzMDc3ZW07XFxufVxcbi52Yy1mb2xkLWlubmVyLnZjLXRvZ2dsZSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuLnZjLWNvZGUta2V5IHtcXG4gIGNvbG9yOiAjZTM2ZWVjO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgbWFyZ2luLWxlZnQ6IDAuNzY5MjMwNzdlbTtcXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2xvZy9pbmRleC5sZXNzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsY0FBQTtFQUNBLGtCQUFBO0VBQ0EsMEJBQUE7RUFDQSxrQkFBQTtBQUNGO0FBQUU7RUFDRSxXQUFBO0VBQ0Esa0JBQUE7RUFDQSxpQkFBQTtFQUNBLGtCQUFBO0VBQ0EsUUFBQTtFQUNBLFNBQUE7RUFDQSxzQ0FBQTtFQUNBLGlDQUFBO0FBRUo7QUFDSTtFQUNFLGlCQUFBO0VBQ0EsT0FBQTtFQUNBLGdDQUFBO0VBQ0EsOEJBQUE7QUFDTjtBQUdBO0VBQ0UsYUFBQTtFQUlBLHlCQUFBO0FBSkY7QUFDRTtFQUNFLGNBQUE7QUFDSjtBQUdBO0VBQ0UsY0FBQTtFQUNBLGtCQUFBO0VBQ0EseUJBQUE7QUFERlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIudmMtZm9sZC1vdXRlciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYztcXG4gIHBhZGRpbmctbGVmdDogMC43NjkyMzA3N2VtO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgJjpiZWZvcmUge1xcbiAgICBjb250ZW50OiAnJztcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDAuMzA3NjkyMzFlbTtcXG4gICAgbGVmdDogMC4xNTM4NDYxNWVtO1xcbiAgICB3aWR0aDogMDtcXG4gICAgaGVpZ2h0OiAwO1xcbiAgICBib3JkZXI6IHRyYW5zcGFyZW50IHNvbGlkIDAuMzA3NjkyMzFlbTtcXG4gICAgYm9yZGVyLWxlZnQtY29sb3I6IHZhcigtLVZDLUZHLTEpO1xcbiAgfVxcbiAgJi52Yy10b2dnbGUge1xcbiAgICAmOmJlZm9yZSB7XFxuICAgICAgdG9wOiAwLjQ2MTUzODQ2ZW07XFxuICAgICAgbGVmdDogMDtcXG4gICAgICBib3JkZXItdG9wLWNvbG9yOiB2YXIoLS1WQy1GRy0xKTtcXG4gICAgICBib3JkZXItbGVmdC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIH1cXG4gIH1cXG59XFxuLnZjLWZvbGQtaW5uZXIge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gICYudmMtdG9nZ2xlIHtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICB9XFxuICBtYXJnaW4tbGVmdDogMC43NjkyMzA3N2VtO1xcbn1cXG4udmMtY29kZS1rZXkge1xcbiAgY29sb3I6ICNlMzZlZWM7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxuICBtYXJnaW4tbGVmdDogMC43NjkyMzA3N2VtO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIubG9nIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG59XFxuLmxvZyAubG9nX2J0biB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDUwJTtcXG4gIHJpZ2h0OiAwO1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxuICB6LWluZGV4OiAxMDAwMDtcXG4gIGJvcmRlci1yYWRpdXM6IDEwJTtcXG4gIHBhZGRpbmc6IDAuM2VtIDAuNWVtO1xcbiAgYm94LXNoYWRvdzogMCAwIDAuNjE1Mzg0NjJlbSByZ2JhKDAsIDAsIDAsIDAuNCk7XFxuICBib3JkZXI6IG5vbmU7XFxuICBmb250LXNpemU6IDEuNWVtO1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcbi5sb2cgLmxvZ19wYW5lbCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1mbG93OiBjb2x1bW4gbm93cmFwO1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDcwJTtcXG4gIGJvdHRvbTogMDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiAxJTtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAxJTtcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgei1pbmRleDogMjAwMDtcXG59XFxuLmxvZyAubG9nX3BhbmVsIC5sb2dfY29udGVudCB7XFxuICBmbGV4OiAxO1xcbiAgb3ZlcmZsb3cteTogYXV0bztcXG4gIHBhZGRpbmc6IDAuM2VtO1xcbn1cXG4ubG9nIC5sb2dfcGFuZWwgLmxvZ190b29sIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxufVxcbi5sb2cgLmxvZ19wYW5lbCAubG9nX3Rvb2wgLmxvZ19vcCB7XFxuICBmbGV4OiAxO1xcbiAgcGFkZGluZzogMC41ZW0gMDtcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgZm9udC1zaXplOiAxLjVlbTtcXG59XFxuLmxvZyAubG9nX3BhbmVsIC5sb2dfdG9vbCAubG9nX2hpZGUge1xcbiAgYmFja2dyb3VuZDogcmdiYSgxMzksIDExMCwgMTEwLCAwLjc2KTtcXG59XFxuLmxvZyAubG9nX3BhbmVsIC5sb2dfdG9vbCAubG9nX2NsZWFyIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMTA1LCA4NywgODcsIDAuMzAxKTtcXG59XFxuLmxvZyAubG9nX3BhbmVsIC5sb2dfdG9vbCAubG9nX3JlZnJlc2gge1xcbiAgYmFja2dyb3VuZDogI2VlZTtcXG59XFxuLmxvZyAubG9nX21hc2sge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB0b3A6IDA7XFxuICBsZWZ0OiAwO1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIHotaW5kZXg6IDEwMDA7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMSk7XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdXJmYWNlL2luZGV4Lmxlc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxlQUFBO0FBQ0Y7QUFGQTtFQUlJLGVBQUE7RUFDQSxRQUFBO0VBQ0EsUUFBQTtFQUNBLGNBQUE7RUFDQSxjQUFBO0VBQ0Esa0JBQUE7RUFDQSxvQkFBQTtFQUNBLCtDQUFBO0VBQ0EsWUFBQTtFQUNBLGdCQUFBO0VBQ0EsY0FBQTtBQUNKO0FBZkE7RUFpQkksYUFBQTtFQUNBLHdCQUFBO0VBQ0EsZUFBQTtFQUNBLFdBQUE7RUFDQSxXQUFBO0VBQ0EsU0FBQTtFQUNBLHNCQUFBO0VBQ0EsMEJBQUE7RUFDQSwyQkFBQTtFQUNBLGFBQUE7RUFDQSxnQkFBQTtFQUNBLGFBQUE7QUFDSjtBQTdCQTtFQThCTSxPQUFBO0VBQ0EsZ0JBQUE7RUFDQSxjQUFBO0FBRU47QUFsQ0E7RUFtQ00sYUFBQTtBQUVOO0FBckNBO0VBcUNRLE9BQUE7RUFDQSxnQkFBQTtFQUNBLGNBQUE7RUFDQSxrQkFBQTtFQUNBLGdCQUFBO0FBR1I7QUE1Q0E7RUE0Q1EscUNBQUE7QUFHUjtBQS9DQTtFQStDUSxvQ0FBQTtBQUdSO0FBbERBO0VBa0RRLGdCQUFBO0FBR1I7QUFyREE7RUF1REksZUFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0VBQ0EsTUFBQTtFQUNBLE9BQUE7RUFDQSxhQUFBO0VBQ0EsYUFBQTtFQUNBLDhCQUFBO0FBQ0pcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLmxvZyB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICAubG9nX2J0biB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogNTAlO1xcbiAgICByaWdodDogMDtcXG4gICAgbGluZS1oZWlnaHQ6IDE7XFxuICAgIHotaW5kZXg6IDEwMDAwO1xcbiAgICBib3JkZXItcmFkaXVzOiAxMCU7XFxuICAgIHBhZGRpbmc6IDAuM2VtIDAuNWVtO1xcbiAgICBib3gtc2hhZG93OiAwIDAgMC42MTUzODQ2MmVtIHJnYmEoMCwgMCwgMCwgMC40KTtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBmb250LXNpemU6IDEuNWVtO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gIH1cXG4gIC5sb2dfcGFuZWwge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWZsb3c6IGNvbHVtbiBub3dyYXA7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogNzAlO1xcbiAgICBib3R0b206IDA7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDElO1xcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogMSU7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIGJhY2tncm91bmQ6ICNmZmY7XFxuICAgIHotaW5kZXg6IDIwMDA7XFxuICAgIC5sb2dfY29udGVudCB7XFxuICAgICAgZmxleDogMTtcXG4gICAgICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgICAgIHBhZGRpbmc6IDAuM2VtO1xcbiAgICB9XFxuICAgIC5sb2dfdG9vbCB7XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgICAubG9nX29wIHtcXG4gICAgICAgIGZsZXg6IDE7XFxuICAgICAgICBwYWRkaW5nOiAwLjVlbSAwO1xcbiAgICAgICAgbGluZS1oZWlnaHQ6IDE7XFxuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgICAgICBmb250LXNpemU6IDEuNWVtO1xcbiAgICAgIH1cXG4gICAgICAubG9nX2hpZGUge1xcbiAgICAgICAgYmFja2dyb3VuZDogcmdiYSgxMzksIDExMCwgMTEwLCAwLjc2KTtcXG4gICAgICB9XFxuICAgICAgLmxvZ19jbGVhciB7XFxuICAgICAgICBiYWNrZ3JvdW5kOiByZ2JhKDEwNSwgODcsIDg3LCAwLjMwMSk7XFxuICAgICAgfVxcbiAgICAgIC5sb2dfcmVmcmVzaCB7XFxuICAgICAgICBiYWNrZ3JvdW5kOiAjZWVlO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgLmxvZ19tYXNrIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgIHotaW5kZXg6IDEwMDA7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4xKTtcXG4gIH1cXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxzcGFuPlxcbiAgPGkgY2xhc3M9XFxcInZjLWNvZGUta2V5eyUgaWYga2V5VHlwZSAlfSB2Yy1jb2RlLXt7a2V5VHlwZX19LWtleXslIGVuZGlmICV9XFxcIlxcbiAgICA+e3trZXl9fTwvaVxcbiAgPjogPGkgY2xhc3M9XFxcInZjLWNvZGUte3t2YWx1ZVR5cGV9fVxcXCI+e3t2YWx1ZX19PC9pPlxcbjwvc3Bhbj5cXG5cIjtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZGl2IGNsYXNzPVxcXCJ2Yy1mb2xkXFxcIj5cXG4gIHslIGlmIGxpbmVUeXBlID09ICdvYmonICV9XFxuICA8aSBjbGFzcz1cXFwidmMtZm9sZC1vdXRlclxcXCI+e3tvdXRlcnxzYWZlfX08L2k+XFxuICA8ZGl2IGNsYXNzPVxcXCJ2Yy1mb2xkLWlubmVyXFxcIj48L2Rpdj5cXG4gIHslIGVsaWYgbGluZVR5cGUgPT0gJ3ZhbHVlJyAlfVxcbiAgPGkgY2xhc3M9XFxcInZjLWNvZGUte3t2YWx1ZVR5cGV9fVxcXCI+e3t2YWx1ZX19PC9pPlxcbiAgeyUgZWxpZiBsaW5lVHlwZSA9PSAna3YnICV9XFxuICA8aSBjbGFzcz1cXFwidmMtY29kZS1rZXl7JSBpZiBrZXlUeXBlICV9IHZjLWNvZGUte3trZXlUeXBlfX0ta2V5eyUgZW5kaWYgJX1cXFwiXFxuICAgID57e2tleX19PC9pXFxuICA+OiA8aSBjbGFzcz1cXFwidmMtY29kZS17e3ZhbHVlVHlwZX19XFxcIj57e3ZhbHVlfX08L2k+XFxuICB7JSBlbmRpZiAlfVxcbjwvZGl2PlxcblwiO1xuLy8gRXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxkaXYgY2xhc3M9XFxcImxvZ1xcXCI+XFxuICA8YnV0dG9uIGNsYXNzPVxcXCJsb2dfYnRuXFxcIj5jaGVjazwvYnV0dG9uPlxcbiAgPGRpdiBjbGFzcz1cXFwibG9nX3BhbmVsXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibG9nX2NvbnRlbnRcXFwiPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJsb2dfdG9vbFxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibG9nX2hpZGUgbG9nX29wXFxcIj5oaWRlPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibG9nX2NsZWFyIGxvZ19vcFxcXCI+Y2xlYXI8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJsb2dfcmVmcmVzaCBsb2dfb3BcXFwiPnJlZnJlc2g8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG4gIDxkaXYgY2xhc3M9XFxcImxvZ19tYXNrXFxcIj48L2Rpdj5cXG48L2Rpdj5cXG5cIjtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gY29kZTsiLCJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5sZXNzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307IiwiaW1wb3J0IGFwaSBmcm9tIFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vaW5kZXgubGVzc1wiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuXHRcdHJldHVybiBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdGxvYWRlZDogZmFsc2UsXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuXHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IG1vZHVsZVsnZGVmYXVsdCddIDpcblx0XHQoKSA9PiBtb2R1bGU7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5ubWQgPSAobW9kdWxlKSA9PiB7XG5cdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdHJldHVybiBtb2R1bGU7XG59OyIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlXG5fX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9zcmMvaW5kZXgudHNcIik7XG4vLyBUaGlzIGVudHJ5IG1vZHVsZSB1c2VkICdleHBvcnRzJyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4iXSwic291cmNlUm9vdCI6IiJ9